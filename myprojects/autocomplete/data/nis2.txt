# OUT_BINARY  - Set binary name (exe, static or dynamic lib name)
SET(OUT_BINARY nsaed_protections)
# PROJECT_FILE_LIST -  Set list of files in the project
#file(GLOB_RECURSE PROJECT_FILE_LIST *.c)
file(STRINGS src.txt PROJECT_FILE_LIST)

# Add All definitions 
add_definitions(-D${CMAKE_OSX_ARCHITECTURES}=1 ${WIN_SPECIFIC_INCLUDES} -DLONG=LONG_NS -DULONG=ULONG_NS -DGTP_MOBILITY_LB_ENABLE -DSTATIC_NVVM_LIB=1 -DPLIST_ENTRY=PLIST_ENTRY_NS -DHAVE_STRUCT_TIMESPEC=1 -D_POS=0 -D_WAN=0 -D_ATM=0 -DPCAP_DRV=0 -DVTAP_DRV=1 -DVTAP_DRV_2000=1 -DNFR=1 -DUTIL_MIB=1 -DM3UA_ASSERT=0 -D_GEMINI=1 -DNAP10G=0 -DANIC=0 -DXYRATEX=0 -DFBC2XLG=0 -DNT3GD=0 -D_SF=1 -D_NF=1 -DRTTMON_POLLING_SUPPORT=1 -D_FLOWEXPT=0 -DIPSLA_DRV=1 -D_SDT_MULT=0 -DSFLOW_DRV=0 -DNETFLOW_DRV=0 -D_S1MME_SANITY=0 -D_FETM=1 -D_FET=1 -D_ET=1 -D_ETM=1 -D_NS_STORE=1  -DVTAP_DRV_1000=1 -DNSAGENT_VERSION_BUILDNUM=$(NSAGENT_VERSION_BUILDNUM) -DSUPPORT_RMON2_DOMAIN=1 -DTRACK_SESSION=1 -DENVOY_SUPPORT=1 -DPROXY_PORT_SUPPORT=1 -DSTART_OTHER_DOMAINS_ON_BOOT=1 -DMODEL_60xx=1 -DMODEL_90xx=1 -DMODEL_5500=1 -DSOFTWARE_PROBE=1 -DPKT_DUMP -D_GEI=1 -D_LINKAGGR=1 -DOS_LINUX=1 -D_SFP_DBM=1 -D_TAG_ENABLED_=0 -DDBG=0 -D_GTP=1 -DTS_NANOSECOND_SUPPORT=1 -DWATCHDOG=0 -DMUTEX_CHK=0 -DCAP_COPY_THREAD=0 -D_APN=1 -DNS_LEGACY_PROBES=1 -D_NSA=1 -D_RIVERBED=1 -DISO8583_RT=1 -DPOP3_SUPPORTED=1 -DSMTP_SUPPORTED=1 -DOS_LINUX_USER -D_CDM_FLOWS=1 -D_CDMA2K=1 -D_CORBA=1 -D_H323=1 -D_IP_OTHER_ENABLED=1 -D_LARGE=1 -D_MGCP=1 -D_P2P=1 -D_PROBE_MODE=1 -D_QOS_GROUP=1 -D_SCCP=1 -D_SIP=1 -D_SITE=1 -D_SUBNET=1 -D_VIFN_MODE=1 -D_VOIP=1 -DCITRIX_XML_SUPPORT=1 -D_CITRIX_XDR_=1 -DFASTPATH=1 -DFIX_ENABLED=1 -DFULL_PROBE_CONFIG=1 -DHCRMON_SUPPORT=1 -DPROBE_CONFIG_BACKEND=1 -D_XDR_ENABLED=1 -D_ASI_SUB_553=1 -D_GTPV2=0 -D_IMS_SIP=1 -D_GTPLTE=0 -D_GTP_MOBILITY_AND_INTEROP=1 -DVRF_VLAN=1 -D_TLV_TUNNEL_ADDR=1 -D_IMS_SIP_PARSER=1 -DDEBUG=0 -DMEM_DEBUG=0 -DLOGICAL_IFN=1 -D_LTE_NAS_DECIPHER=0 -D_GTPV2_PARENT_XDRID=1 -D_MOB_XDR_IPV6_MODE=1 -D_MGCP_IPV6_MODE=1 -D_SCCP_IPV6_MODE=1 -DSMB_XDR_ENABLED=1 -D_XDR_COL_50=1 -DSSL_DECRYPT=1 -D_MOB_XDR_COMMON_CHANGES=1 -DCDM_QOE_ON=1 -D_MOB_51_XDR_FIELDS=0 -DASI_2X_CONFIG=0 -DASI_2X_CONFIG_52=0 -DXML_SAX_CONFIG=0 -DIMAP_ASR_=1 -DIMAP_ASR_EVENT_IE=0 -DREPORT_GENERIC_XDR=1 -DTCM_PARSER=1 -DLB_CTRL_FLOW_TYPE=1 -DLB_IUPS=0 -DSMB_XDR_EVENT_IE=0 -DMSRPC_ASR_ENABLED=1 -D_HTTP_EXT_KEY_SUPPORT=0 -DLB_DLC_OFFSET=0 -D_OTT_SPECIAL=0 -DDC_CONFIG=1 -DSW_DEBUG=0 -DGM_IF_ESP_NULL=1 -D_55_ASI_ASR=1 -D_GTP_TEK_INTG_D=1 -D_55_ASI_ASR_ACTIVITY_MAP=0 -D_GEO_TEST_SKT_AGE_INTERVAL=1 -DSTP_MOB_S11_S1_CORRELATION -DS1_PERFORMANCE_ENHANCEMENT -DS2A_INTG_ENABLE -DGTP_CELLID_ENABLE -DOAM_SERVER_DOWNLOAD=1 -DUSE_OPENSSL=1 )

# Inlcude Dir
if (MSVC)
include_directories(${CMAKE_SOURCE_DIR}/h/windows)
include_directories(${VC_IncludePath})
endif ()
include_directories(${CMAKE_SOURCE_DIR}/../nvvm/vv_engine/include)
include_directories(${CMAKE_SOURCE_DIR}/../nvvm/common/include)
include_directories(${CMAKE_SOURCE_DIR}/drivers/h)
include_directories(${CMAKE_SOURCE_DIR}/ipsla/inc)

include_directories(${CMAKE_SOURCE_DIR}/h)
include_directories(${CMAKE_SOURCE_DIR}/../common)
include_directories(${CMAKE_SOURCE_DIR}/../tfaengine/communication/common)
include_directories(${CMAKE_SOURCE_DIR}/linux/h)
include_directories(${CMAKE_SOURCE_DIR}/confsubs)
include_directories(${CMAKE_SOURCE_DIR}/linux/stubs)
include_directories(${CMAKE_SOURCE_DIR}/mibmgr/aed)
include_directories(${CMAKE_SOURCE_DIR}/mibmgr/threads)
include_directories(${CMAKE_SOURCE_DIR}/mibmgr/parser/inc)
include_directories(${CMAKE_SOURCE_DIR}/mibmgr/parser/enterprise/inc)
include_directories(${CMAKE_SOURCE_DIR}/mibmgr/common/inc)
include_directories(${CMAKE_SOURCE_DIR}/mibmgr/collector/inc)
include_directories(${CMAKE_SOURCE_DIR}/mibmgr/collector/asiflows)
include_directories(${CMAKE_SOURCE_DIR}/mibmgr)
include_directories(${CMAKE_SOURCE_DIR}/epilogue/port/msdos)
include_directories(${CMAKE_SOURCE_DIR}/epilogue)
include_directories(${CMAKE_SOURCE_DIR}/epilogue/envoy/h)
if (MSVC)
include_directories(${CMAKE_SOURCE_DIR}/h/windows/libxml)
endif()
include_directories(${CMAKE_SOURCE_DIR}/gbdecrypt)
include_directories(${CMAKE_SOURCE_DIR}/mibmgr/ret/inc)
include_directories(${CMAKE_SOURCE_DIR}/decipher/h)
include_directories(${CMAKE_SOURCE_DIR}/nsdecrypt/ssldecrypt/include)

# Creating static lib
add_library(${OUT_BINARY} STATIC ${PROJECT_FILE_LIST})

import re
import fileinput
import sys, os

class BulkUpdater:
    def __init__(
        self,
        filelist: str,
        filelistpath: str,
        filetype: str, # ex : c,py,cpp
        per_line_patterns: list,
        per_line_replacements: list,
        full_match_patterns: list = None,
        full_match_replacements: list = None,
    ) -> None:
        with open(filelist, "r") as f:
            files = f.readlines()

        print(f"{files = }")
        files = [f"{s.strip('\n')}.{filetype}" for s in files]
        self.files = [os.path.join(filelistpath, file) for file in files]
        # self.files = [f"{s.strip("\n")}" for s in files]
        print(f"{files = }")

        self.per_line_patterns = per_line_patterns
        self.per_line_replacements = per_line_replacements

        if full_match_patterns is not None:
            print("Full file data match expected")
            self.full_match_patterns = full_match_patterns
            self.full_match_replacements = full_match_replacements

    def per_line_match_and_update(self) -> None:
        patterns, replacements = self.per_line_patterns, self.per_line_replacements
        for fname in self.files:
            print(f"Per line pattern update start for { fname = }")
            # update from list
            for pattern, replacement in zip(patterns, replacements):
                print(f"{pattern = }, { replacement = }")
                pattern = re.compile(pattern)
                with fileinput.FileInput(fname, inplace=True) as file:
                    for line in file:
                        # rep = line + replacement
                        rep = replacement
                        line = re.sub(pattern, rep, line)
                        print(line, end="")
            print("Per line pattern update ends")

    def full_file_data_match_and_update(self) -> None:
        patterns, replacements = self.full_match_patterns, self.full_match_replacements
        for fname in self.files:
            print(f"Complete data match and update update start for {fname = }")
            # update special case
            with open(fname) as file:
                data = file.read()

            print("!!!Data read!!!")

            for pattern, replacement in zip(patterns, replacements):
                matched = re.search(pattern, data)
                if matched:
                    print("MATCHED")
                    # rep = repr(matched.group(0)).strip('\'') + replacement
                    rep = replacement
                    data = re.sub(pattern, rep, data)
                    with open(fname, "w") as f:
                        f.write(data)
            print("Complete data match and update update ends")


if __name__ == "__main__":
    per_line_patterns = [
        # r'(\s+)N64 pkt_dropped;',
        # r'(\s+)state->stats\.pkt_dropped(\s*\+=\s*1|\+\+);',
        # r'(\s+)total->stats.pkt_dropped \+= cur->stats.pkt_dropped;',
        # r'(\s+)cJSON_AddNumberToObject\((\w+), "packets_dropped", stats->pkt_dropped\);'
        # r'stats.pkt_dropped',
        # r'stats.l3_byte_dropped',
        # r'stats->pkt_dropped',
        # r'stats->l3_byte_dropped',
        r'.{4}NSAED_[\w]+_STATS_BASE stats_base;'

    ]

    per_line_replacements = [
        # r'\1N64 l3_byte_dropped;',
        # r'\1state->stats.l3_byte_dropped += L3_BYTES(info);',
        # r'\1total->stats.l3_byte_dropped += cur->stats.l3_byte_dropped;',
        # r'\1cJSON_AddNumberToObject(\2, "l3_bytes_dropped", stats->l3_byte_dropped);'
        # r'stats.stats_base.pkt_dropped',
        # r'stats.stats_base.l3_byte_dropped',
        # r'stats->stats_base.pkt_dropped',
        # r'stats->stats_base.l3_byte_dropped',
        r'    NSAED_PROTECTION_STATS_BASE stats_base;',
    ]

    full_match_patterns = [
        # r'(\s+)rcon_printf\(\"Packets dropped by \%s: \%llu\\n\",\n(\s+)(\w+), state->stats.pkt_dropped\);',
        # r'typedef struct\n\{\n {4}N64 pkt_dropped;\n {4}N64 l3_byte_dropped;\n([\s\S]*?)} NSAED_(\w+)_STATS;'
        # r'typedef struct\n[\s\S]+} NSAED_(\w+)_CONFIG;'
        r'\n\ntypedef struct\n{\n.{4}atomic_uint_fast64_t pkt_dropped;\n.{4}atomic_uint_fast64_t l3_byte_dropped;\n} NSAED_[\w]+_STATS_BASE;'
    ]
    full_match_replacements = [
        # r'\1rcon_printf("L3 Bytes dropped by %s: %llu\\n",\n\2\3, state->stats.l3_byte_dropped);',
        # r'typedef struct\n{\n    NSAED_\2_STATS_BASE stats_base;\n\1} NSAED_\2_STATS;'
        # r'\n\ntypedef struct\n{\n    atomic_uint_fast64_t pkt_dropped;\n    atomic_uint_fast64_t l3_byte_dropped;\n} NSAED_\1_STATS_BASE;'
        r'',
    ]

    filelist = sys.argv[1]
    filelistpath = sys.argv[2]
    filetype = sys.argv[3]

    updater = BulkUpdater(
        filelist=filelist,
        filelistpath=filelistpath,
        filetype=filetype,
        per_line_patterns=per_line_patterns,
        per_line_replacements=per_line_replacements,
        full_match_patterns=full_match_patterns,
        full_match_replacements=full_match_replacements,
    )

    updater.per_line_match_and_update()
    updater.full_file_data_match_and_update()
#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2024                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
*                                                                       *
************************************************************************/

#include <netinet/ip.h>
#include <netinet/ip6.h>
#include <netinet/tcp.h>

#include "eventlog.h"
#include "aed/action.h"
#include "aed/aed.h"
#include "aed/aedmacros.h"
#include "aed/aed_sktcache.h"
#include "aed/cJSON.h"
#include "aed/srcstate.h"
#include "aed/state.h"
#include "aed/foundation/hash_functions.h"
#include "aed/foundation/lru.h"
#include "aed/foundation/pool.h"
#include "xmibflow.h"
#include "sktapi.h"
#include "ppflowapi.h"
#include "ppformat.h"

#define CONNLIMIT_NAME "TCP Connection Limiting"
#define CONNLIMIT_ELEMENT_NAME "connlimit"

#define IDLE_TIMEOUT_US (60 * 1000000)

typedef struct
{
    BOOL enabled;
    N32 max_connections;
    NSAED_ACTION action; // NSAED_ACTION_DROP or NSAED_ACTION_BLOCK
} NSAED_CONNLIMIT_CONFIG;

typedef struct
{
    NSAED_PROTECTION_STATS_BASE stats_base;
    N64 src_blocked;
    N64 conn_muted;
} NSAED_CONNLIMIT_STATS;

typedef struct
{
    NSAED_CONNLIMIT_STATS stats;
} NSAED_CONNLIMIT_STATE;

typedef struct
{
    N32 flags;
} NSAED_CONNLIMIT_SKTCACHE;

PRIVATE VOID* connlimit_config_alloc();
PRIVATE VOID connlimit_config_dump(const VOID *prot_config);
PRIVATE VOID connlimit_config_free(VOID *prot);
PRIVATE BOOL connlimit_config_get_enabled(VOID *prot_config);
PRIVATE VOID connlimit_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *json);
PRIVATE VOID connlimit_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE N32 connlimit_get_protection_id();
PRIVATE NSAED_ACTION connlimit_inspect(const VOID *prot_config, VOID *prot_state, XMIB_FLOW_INFO *info);
PRIVATE VOID connlimit_registered(N32 id);
PRIVATE VOID connlimit_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur);
PRIVATE VOID connlimit_stat_dump(const VOID *config, const VOID* state);
PRIVATE VOID connlimit_stat_dump_json(cJSON*, const VOID *config, const VOID* state);
PRIVATE VOID* connlimit_state_alloc();
PRIVATE VOID connlimit_state_free(VOID *prot);

EXPORT const NSAED_PROTECTION connlimit_protection = {
    .name = CONNLIMIT_ELEMENT_NAME,
    .features = NSAED_FEATURE_SRCSTATE | NSAED_FEATURE_SOCKET,
    .sktcache_blocksize = sizeof(NSAED_CONNLIMIT_SKTCACHE),

    .config_allocator = connlimit_config_alloc,
    .config_deallocator = connlimit_config_free,
    .config_dumper = connlimit_config_dump,
    .config_get_enabled = connlimit_config_get_enabled,
    .config_handler = connlimit_config_handler,
    .config_set_enabled = connlimit_config_set_enabled,
    .get_protection_id = connlimit_get_protection_id,
    .inspector = connlimit_inspect,
    .registered = connlimit_registered,
    .stat_accumulator = connlimit_stat_add,
    .stat_dumper = connlimit_stat_dump,
    .stat_dumper_json = connlimit_stat_dump_json,
    .state_allocator = connlimit_state_alloc,
    .state_deallocator = connlimit_state_free,
};

PRIVATE N32 protection_id = 0;

PRIVATE INLINE VOID
connlimit_connection_set_flags(AED_SKT_CACHE_DATA *conn, N32 mask)
{
    NSAED_CONNLIMIT_SKTCACHE *skt = aed_sktcache_data_get_protection(conn, protection_id);
    skt->flags |= mask;
}

PRIVATE INLINE VOID
connlimit_connection_clear_flags(AED_SKT_CACHE_DATA *conn, N32 mask)
{
    NSAED_CONNLIMIT_SKTCACHE *skt = aed_sktcache_data_get_protection(conn, protection_id);
    skt->flags &= ~mask;
}

PRIVATE VOID ss_insert_conn(SRCSTATE *ss, AED_SKT_CACHE_DATA *aed_skt_cache_data, N64 timestamp_us)
{
    srcstate_insert_conn(ss, aed_skt_cache_data);
    connlimit_connection_set_flags(aed_skt_cache_data, AED_SKT_COUNTED);
    aed_skt_cache_data->last_update_time_us = timestamp_us;
}

PRIVATE VOID ss_remove_conn(SRCSTATE *ss, AED_SKT_CACHE_DATA *aed_skt_cache_data)
{
    srcstate_remove_conn(ss, aed_skt_cache_data);
    connlimit_connection_clear_flags(aed_skt_cache_data, AED_SKT_SEENSYN | AED_SKT_COUNTED);
}

PRIVATE VOID* connlimit_config_alloc()
{
    return calloc(1, sizeof(NSAED_CONNLIMIT_CONFIG));
}

PRIVATE VOID connlimit_config_dump(const VOID *c)
{
    const NSAED_CONNLIMIT_CONFIG* config = c;
    rcon_printf("%s\n  Enabled: %s\n", CONNLIMIT_NAME,
        IS_PROTECTION_ENABLED(config->enabled));
    if (!config->enabled)
    {
        return;
    }
    rcon_printf("  Max Connections: %u\n", config->max_connections);

    const TEXT *action_str;
    switch (config->action)
    {
        case NSAED_ACTION_DROP:
            action_str = "drop";
            break;
        case NSAED_ACTION_BLOCK:
            action_str = "block";
            break;
        default:
            action_str = "UNKNOWN";
    }
    rcon_printf("  Action: %s\n", action_str);
}

PRIVATE VOID connlimit_config_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    free(prot);
}

PRIVATE BOOL connlimit_config_get_enabled(VOID *prot_config)
{
    NSAED_CONNLIMIT_CONFIG *config = prot_config;
    return config->enabled;
}

PRIVATE VOID connlimit_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *connlimit_json)
{
    NSAED_CONNLIMIT_CONFIG *config = prot_config;

    config->action = NSAED_ACTION_DROP;
    cJSON *action_json = cJSON_GetObjectItemCaseSensitive(connlimit_json, "action");
    if (action_json)
    {
        config->action = NSAED_ACTION_NONE;
        if (cJSON_IsString(action_json))
        {
            TEXT *action = cJSON_GetStringValue(action_json);
            if (strcmp(action, "drop") == 0)
            {
                config->action = NSAED_ACTION_DROP;
            }
            else if (strcmp(action, "block") == 0)
            {
                config->action = NSAED_ACTION_BLOCK;
            }
        }
    }

    if (config->action != NSAED_ACTION_NONE)
    {
        // arbritrary default, change if necessary
        config->max_connections = 50;
        cJSON *max_connections = cJSON_GetObjectItemCaseSensitive(connlimit_json, "max_connections");
        if (max_connections)
        {
            if (cJSON_IsNumber(max_connections))
            {
                config->max_connections = (N32)cJSON_GetNumberValue(max_connections);
                if (config->max_connections > 0)
                {
                    return;
                }
            }
        }
    }

    // if we are here, something's wrong with the config
    connlimit_config_set_enabled(config, FALSE);
}

PRIVATE VOID connlimit_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_CONNLIMIT_CONFIG *config = prot_config;
    config->enabled = state;
}

PRIVATE N32 connlimit_get_protection_id()
{
    return protection_id;
}

// Safe when the current element is removed from the queue
// XXX move to some header file if used elsewhere in the future.
#ifndef TAILQ_FOREACH_REVERSE_SAFE
#define	TAILQ_FOREACH_REVERSE_SAFE(var, head, headname, field, tvar)	\
	for ((var) = TAILQ_LAST((head), headname);			\
	    (var) && ((tvar) = TAILQ_PREV((var), headname, field), 1);	\
	    (var) = (tvar))
#endif

PRIVATE BOOL connlimit_is_dropped(SRCSTATE *ss,
        const NSAED_CONNLIMIT_CONFIG *config,
        AED_SKT_CACHE_DATA *aed_skt_cache_data, N64 timestamp_us)
{
    // idle connection pruning
    if (srcstate_get_conn_count(ss))
    {
        const SRCSTATE_CONNS *conns = srcstate_get_conns(ss);
        AED_SKT_CACHE_DATA *conn = NULL, *tmp_conn = NULL;
        TAILQ_FOREACH_REVERSE_SAFE(conn, conns, SRCSTATE_CONNS, link, tmp_conn)
        {
            if ((timestamp_us - conn->last_update_time_us) > IDLE_TIMEOUT_US)
            {
                // Stop tracking the connection
                ss_remove_conn(ss, conn);
            }
            else
            {
                // Since the queue is ordered, on encountering a connection that's
                // within the timeout, we can safely assume that that all the remaining
                // connections won't need to be pruned.
                break;
            }
        }
    }

    INT conn_count = srcstate_get_conn_count(ss);
    if (conn_count > config->max_connections ||
            (conn_count == config->max_connections &&
             // connlimit adds a connection to the srcstate when it sees the
             // ACK of its 3-way handshake.
             //
             // For a connection that is not AED_SKT_COUNTED yet, when
             // connlimit sees an ACK, it would mute the connection if a SYN on
             // this connection is seen and the source already has
             // max_connections connections. This is fine when connlimit is the
             // only proteciton enabled, because the ACK would be for the 3-way
             // handshake of the (max_connections + 1)-th connection.
             //
             // However, if connreset is also enabled, that protection would
             // have added the connection to the srcstate already when it saw
             // the SYN, which means the ACK is of the max_connections-th
             // connection, and the limit is not exceeded.
             //
             // Therefore, we should check if the connection is already in
             // the srcstate, and claim the limit is exceeded only when this
             // connection is not yet added to the srcstate.
             !aed_skt_is_in_srcstate(aed_skt_cache_data)))
    {
        log_event(BOTH_LOG, "#AEDSKT conn count exceeded, muting %d", aed_skt_cache_data->index);
        return TRUE;
    }

    return FALSE;
}

PRIVATE INLINE NSAED_ACTION connlimit_on_new_conn(SRCSTATE *ss,
        const NSAED_CONNLIMIT_CONFIG *config,
        NSAED_CONNLIMIT_STATE *state,
        AED_SKT_CACHE_DATA *aed_skt_cache_data,
        XMIB_FLOW_INFO *info)
{
    if (connlimit_is_dropped(ss, config, aed_skt_cache_data, info->frame_time_us))
    {
        if (aed_skt_mute_by_pkt(aed_skt_cache_data, info, protection_id))
        {
            state->stats.conn_muted++;
        }
        if (config->action == NSAED_ACTION_BLOCK)
        {
            state->stats.src_blocked++;
        }

        state->stats.stats_base.pkt_dropped++;
        state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);

        return config->action;
    }
    return NSAED_ACTION_NONE;
}

PRIVATE NSAED_ACTION connlimit_inspect(const VOID *c, VOID *s, XMIB_FLOW_INFO *info)
{
    // ignore packet if not TCP
    if (info->ip_parse_info.protocol != IPPROTO_TCP)
    {
        return NSAED_ACTION_NONE;
    }

    // If no skt key, skip.
    if (info->skt_cache_key.version == 0)
    {
        return NSAED_ACTION_NONE;
    }


    log_event(BOTH_LOG, "#AEDSKT tcp flags %x", info->tcp_flags);

    const NSAED_CONNLIMIT_CONFIG *config = c;
    NSAED_CONNLIMIT_STATE *state = s;

    SRCSTATE *ss = info->srcstate;
    AED_SKT_CACHE_DATA *aed_skt_cache_data = info->skt_cache_data;
    if (!aed_skt_cache_data)
    {
        log_event(BOTH_LOG, "#AEDSKT connlimit got null data: %u", info->pifn);
        return NSAED_ACTION_NONE;
    }

    NSAED_CONNLIMIT_SKTCACHE *skt = aed_sktcache_data_get_protection(aed_skt_cache_data, protection_id);

    // If connection teardown, remove tracking info.
    if (info->tcp_flags & (TCP_FIN | TCP_RST))
    {
        if ((skt->flags & (AED_SKT_COUNTED|AED_SKT_CLOSED)) == AED_SKT_COUNTED)
        {
            ss_remove_conn(ss, aed_skt_cache_data);
            skt->flags |= AED_SKT_CLOSED;
        }
        log_event(BOTH_LOG, "#AEDSKT clean teardown on %d", aed_skt_cache_data->index);
        return NSAED_ACTION_NONE;
    }

    if (skt->flags & AED_SKT_COUNTED)
    {
        // This is an established, allowed connection; move connection to head of connlist.
        srcstate_insert_conn(ss, aed_skt_cache_data);
        aed_skt_cache_data->last_update_time_us = info->frame_time_us;
        return NSAED_ACTION_NONE;
    }

    if (info->tcp_flags & TCP_SYN)
    {
        if (info->tcp_flags & TCP_ACK)
        {
            // We never want to block SYN|ACK to a protected host.
            log_event(BOTH_LOG, "#AEDSKT skipping synack");
            return NSAED_ACTION_NONE;
        }

        NSAED_ACTION action = connlimit_on_new_conn(ss, config, state, aed_skt_cache_data, info);
        if (action == NSAED_ACTION_NONE)
        {
            skt->flags |= AED_SKT_SEENSYN;
            aed_skt_see_syn(aed_skt_cache_data);
        }

        return action;
    }

    if (info->tcp_flags & TCP_ACK)
    {
        // If we've seen a SYN and an ACK, then we count it,
        // unless this connection has already been closed.
        if ((skt->flags & (AED_SKT_SEENSYN|AED_SKT_CLOSED)) == AED_SKT_SEENSYN)
        {
            NSAED_ACTION action = connlimit_on_new_conn(ss, config, state, aed_skt_cache_data, info);
            if (action == NSAED_ACTION_NONE)
                ss_insert_conn(ss, aed_skt_cache_data, info->frame_time_us);

            return action;
        }
    }

    return NSAED_ACTION_NONE;
}

PRIVATE VOID connlimit_registered(N32 id)
{
    protection_id = id;
}

PRIVATE VOID connlimit_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur)
{
    NSAED_CONNLIMIT_STATE* total = state_total;
    const NSAED_CONNLIMIT_STATE* cur = state_cur;
    total->stats.stats_base.pkt_dropped += cur->stats.stats_base.pkt_dropped;
    total->stats.stats_base.l3_byte_dropped += cur->stats.stats_base.l3_byte_dropped;
    total->stats.src_blocked += cur->stats.src_blocked;
    total->stats.conn_muted += cur->stats.conn_muted;
}

PRIVATE VOID connlimit_stat_dump(const VOID *c, const VOID *s)
{
    const NSAED_CONNLIMIT_STATE* state = s;
    if (state)
    {
        rcon_printf("Packets dropped by %s: %llu\n",
                CONNLIMIT_NAME, state->stats.stats_base.pkt_dropped);
        rcon_printf("L3 Bytes dropped by %s: %llu\n",
                CONNLIMIT_NAME, state->stats.stats_base.l3_byte_dropped);
        rcon_printf("Sources blocked by %s: %llu\n",
                CONNLIMIT_NAME, state->stats.src_blocked);
        rcon_printf("Connections muted by %s: %llu\n",
                CONNLIMIT_NAME, state->stats.conn_muted);
    }
}

PRIVATE VOID connlimit_stat_dump_json(cJSON* cj, const VOID *c, const VOID *s)
{
    const NSAED_CONNLIMIT_STATE* state = s;
    const NSAED_CONNLIMIT_STATS* stats = &state->stats;

    cJSON* connlimit = cJSON_AddObjectToObject(cj, CONNLIMIT_ELEMENT_NAME);
    cJSON_AddNumberToObject(connlimit, "packets_dropped", stats->stats_base.pkt_dropped);
    cJSON_AddNumberToObject(connlimit, "l3_bytes_dropped", stats->stats_base.l3_byte_dropped);
    cJSON_AddNumberToObject(connlimit, "sources_blocked", stats->src_blocked);
    cJSON_AddNumberToObject(connlimit, "connections_muted", stats->conn_muted);
}

PRIVATE VOID* connlimit_state_alloc()
{
    return calloc(1, sizeof(NSAED_CONNLIMIT_STATE));
}

PRIVATE VOID connlimit_state_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }
    free(prot);
}
#endif // ISNG_BASED_AED
#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2024                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
*                                                                       *
************************************************************************/

#include <netinet/ip.h>
#include <netinet/ip6.h>
#include <netinet/tcp.h>

#include "eventlog.h"
#include "aed/aed.h"
#include "aed/aedmacros.h"
#include "aed/cJSON.h"
#include "aed/srcstate.h"
#include "aed/aed_sktcache.h"
#include "ppformat.h"
#include "sktapi.h"
#include "timer.h"
#include "xmibflow.h"
#include "aed/protection_group.h"
#include "aed/aed_sktcache.h"
#include "aed/thread/aed_insp_thread.h"
#include <sys/queue.h>

#define CONNRESET_NAME "TCP Connection Reset"
#define CONNRESET_ELEMENT_NAME "connreset"

// Note: this doesn't need to be configurable for now, so keep the check
// simple. If it needs to be configurable, or we need to check a longer list of
// hardcoded ports, do something smarter.
#define CONNRESET_IS_MONITORED_PORT(port) \
    (port == 25 || port == 80 || port == 443)

#define SECONDS_TO_MICRO(s) (s * 1000000ULL)
#define MICRO_TO_SECONDS(u) (u / 1000000ULL)

typedef struct
{
    BOOL enabled;
    N64 initial_timeout_us;
    N32 initial_bytes;
    BOOL track_longlived;
    N64 timeout_us;
    N32 consecutive_idles;
} NSAED_CONNRESET_CONFIG;

typedef struct
{
    NSAED_PROTECTION_STATS_BASE stats_base;
    N64 conn_muted;
    N64 src_blocked;
} NSAED_CONNRESET_STATS;

typedef struct
{
    N32 idles;
} NSAED_CONNRESET_SRCSTATE;

typedef enum
{
    UNINIT = 0,
    INITIAL,
    ACTIVE,
    UNTRACKED,
    UNTRACKED_ACTIVE,
} CONNRESET_SKT_STATE;

PRIVATE const char* connreset_skt_state_name(CONNRESET_SKT_STATE state)
{
    #define SKT_STATE_CASE(s)   case s: return #s;
    switch (state)
    {
        SKT_STATE_CASE(UNINIT)
        SKT_STATE_CASE(INITIAL)
        SKT_STATE_CASE(ACTIVE)
        SKT_STATE_CASE(UNTRACKED)
        SKT_STATE_CASE(UNTRACKED_ACTIVE)
        default: return "Unknown";
    }
}

typedef struct NSAED_CONNRESET_SKTCACHE
{
    N64 data_bytes;
    N64 start_time_us;
    N64 last_uptime_time_us;
    CONNRESET_SKT_STATE state;
    AED_SKT_CACHE_DATA *skt;
    TAILQ_ENTRY(NSAED_CONNRESET_SKTCACHE) link;
} NSAED_CONNRESET_SKTCACHE;

TAILQ_HEAD(CONNRESET_SKT_Q, NSAED_CONNRESET_SKTCACHE);
typedef struct CONNRESET_SKT_Q CONNRESET_SKT_Q;

typedef struct
{
    NSAED_CONNRESET_STATS stats;
    CONNRESET_SKT_Q initial_q;
    CONNRESET_SKT_Q longlived_q;
} NSAED_CONNRESET_STATE;

PRIVATE VOID* connreset_config_alloc();
PRIVATE VOID connreset_config_dump(const VOID *prot_config);
PRIVATE VOID connreset_config_free(VOID *prot);
PRIVATE BOOL connreset_config_get_enabled(VOID *prot_config);
PRIVATE VOID connreset_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *json);
PRIVATE VOID connreset_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE N32 connreset_get_protection_id();
PRIVATE NSAED_ACTION connreset_inspect(const VOID *prot_config, VOID *prot_state, XMIB_FLOW_INFO *info);
PRIVATE VOID connreset_registered(N32 id);
PRIVATE VOID connreset_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur);
PRIVATE VOID connreset_stat_dump(const VOID *config, const VOID* state);
PRIVATE VOID connreset_stat_dump_json(cJSON*, const VOID *config, const VOID* state);
PRIVATE VOID* connreset_state_alloc();
PRIVATE VOID connreset_state_free(VOID *prot);
PRIVATE VOID connreset_tick(const VOID *prot_config, VOID *prot_state, NSAED_PG_STATE *pg_state, NSAED_INSP_THREAD *);

EXPORT const NSAED_PROTECTION connreset_protection = {
    .name = CONNRESET_ELEMENT_NAME,
    .features = NSAED_FEATURE_SRCSTATE | NSAED_FEATURE_SOCKET,
    .srcstate_blocksize = sizeof(NSAED_CONNRESET_SRCSTATE),
    .sktcache_blocksize = sizeof(NSAED_CONNRESET_SKTCACHE),

    .config_allocator = connreset_config_alloc,
    .config_deallocator = connreset_config_free,
    .config_dumper = connreset_config_dump,
    .config_get_enabled = connreset_config_get_enabled,
    .config_handler = connreset_config_handler,
    .config_set_enabled = connreset_config_set_enabled,
    .get_protection_id = connreset_get_protection_id,
    .inspector = connreset_inspect,
    .registered = connreset_registered,
    .stat_accumulator = connreset_stat_add,
    .stat_dumper = connreset_stat_dump,
    .stat_dumper_json = connreset_stat_dump_json,
    .state_allocator = connreset_state_alloc,
    .state_deallocator = connreset_state_free,
    .tick = connreset_tick,
};

PRIVATE N32 protection_id = 0;

PRIVATE VOID* connreset_config_alloc()
{
    return calloc(1, sizeof(NSAED_CONNRESET_CONFIG));
}

PRIVATE VOID connreset_config_dump(const VOID *c)
{
    const NSAED_CONNRESET_CONFIG* config = c;
    rcon_printf("%s\n  Enabled: %s\n", CONNRESET_NAME,
        IS_PROTECTION_ENABLED(config->enabled));
    if (!config->enabled)
    {
        return;
    }
    rcon_printf("  Initial Timeout: %llu\n", MICRO_TO_SECONDS(config->initial_timeout_us));
    rcon_printf("  Initial Bytes: %u\n", config->initial_bytes);
    rcon_printf("  Track Long Lived: %s\n", config->track_longlived ? "True" : "False");
    rcon_printf("  Timeout: %llu\n", MICRO_TO_SECONDS(config->timeout_us));
    rcon_printf("  Consecutive Idles: %u\n", config->consecutive_idles);
}

PRIVATE VOID connreset_config_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    free(prot);
}

PRIVATE BOOL connreset_config_get_enabled(VOID *prot_config)
{
    NSAED_CONNRESET_CONFIG *config = prot_config;
    return config->enabled;
}

PRIVATE VOID connreset_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *connreset_json)
{
    NSAED_CONNRESET_CONFIG *config = prot_config;

    // default values:
    config->track_longlived = FALSE;
    config->consecutive_idles = 5;

    cJSON *initial_timeout_json = cJSON_GetObjectItemCaseSensitive(connreset_json, "initial_timeout");
    cJSON *initial_bytes_json = cJSON_GetObjectItemCaseSensitive(connreset_json, "initial_bytes");
    if (initial_timeout_json == NULL ||
            initial_bytes_json == NULL ||
            !cJSON_IsNumber(initial_timeout_json) ||
            !cJSON_IsNumber(initial_bytes_json))
    {
        connreset_config_set_enabled(config, FALSE);
        return;
    }
    config->initial_timeout_us = SECONDS_TO_MICRO((N64)cJSON_GetNumberValue(initial_timeout_json));
    config->initial_bytes = (N32)cJSON_GetNumberValue(initial_bytes_json);

    cJSON *track_longlived_json = cJSON_GetObjectItemCaseSensitive(connreset_json, "track_longlived");
    cJSON *timeout_json = cJSON_GetObjectItemCaseSensitive(connreset_json, "timeout");
    cJSON *consecutive_idles_json = cJSON_GetObjectItemCaseSensitive(connreset_json, "consecutive_idles");

    if (track_longlived_json && cJSON_IsBool(track_longlived_json))
    {
        // XXX protection will act weird if timeout isn't set (i.e. is 0), but
        // that's fine
        config->track_longlived = cJSON_IsTrue(track_longlived_json);
    }

    if (timeout_json && cJSON_IsNumber(timeout_json))
    {
        // XXX this will be ignored if track_longlived=false, but that's fine
        config->timeout_us = SECONDS_TO_MICRO((N32)cJSON_GetNumberValue(timeout_json));
    }

    if (consecutive_idles_json && cJSON_IsNumber(consecutive_idles_json))
    {
        config->consecutive_idles = (N32)cJSON_GetNumberValue(consecutive_idles_json);
    }
}

PRIVATE VOID connreset_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_CONNRESET_CONFIG *config = prot_config;
    config->enabled = state;
}

PRIVATE N32 connreset_get_protection_id()
{
    return protection_id;
}

PRIVATE VOID connreset_remove_sktcache_entry(AED_SKT_CACHE_DATA *conn, VOID *cookie)
{
    NSAED_CONNRESET_STATE* state = (NSAED_CONNRESET_STATE *)cookie;
    NSAED_CONNRESET_SKTCACHE *skt = aed_sktcache_data_get_protection(conn, connreset_get_protection_id());

    switch(skt->state)
    {
        case INITIAL:
            TAILQ_REMOVE(&state->initial_q, skt, link);
            break;
        case ACTIVE:
            TAILQ_REMOVE(&state->longlived_q, skt, link);
            break;
        default:
            log_event(BOTH_LOG, "#CONNRESET UNINIT: destructor called with socket in unhandled state %d", skt->state);
            break;
    }
}

// NOTE: This inspector never drops packets!
// It only mutes connections (and possibly blocks sources) via the tick callback.
PRIVATE NSAED_ACTION connreset_inspect(const VOID *c, VOID *s, XMIB_FLOW_INFO *info)
{
    const NSAED_CONNRESET_CONFIG* config = c;
    NSAED_CONNRESET_STATE* state = s;

    // First, see if this is a packet we want to inspect:
    if (
            // - ignore packet if not TCP
            info->ip_parse_info.protocol != IPPROTO_TCP ||
            // - ignore if this is a SYN-ACK (we don't want to block inbound
            //   SYN-ACK to a protected client)
            (info->tcp_flags & (TCP_SYN | TCP_ACK)) == (TCP_SYN | TCP_ACK) ||
            // - ignore if tcp dest port is not one of the monitored_ports
            !CONNRESET_IS_MONITORED_PORT(info->ip_parse_info.dest_port) ||
            // - skip if no no skt_cache_data
            info->skt_cache_data == NULL
    )
    {
        log_event(BOTH_LOG, "#CONNRESET early quit");
        return NSAED_ACTION_NONE;
    }

    SRCSTATE *ss = info->srcstate;
    assert(ss != NULL);

    NSAED_CONNRESET_SKTCACHE *skt = aed_sktcache_data_get_protection(info->skt_cache_data, connreset_get_protection_id());
    skt->last_uptime_time_us = info->frame_time_us;
    skt->skt = info->skt_cache_data;

    switch(skt->state)
    {
        case UNTRACKED:
            log_event(BOTH_LOG, "#CONNRESET UNTRACKED %p", skt);
            return NSAED_ACTION_NONE;
        case UNINIT:
            log_event(BOTH_LOG, "#CONNRESET UNINIT %p", skt);
            // This is the first time we've seen this connection.
            if (info->tcp_flags & TCP_SYN)
            {
                // if the packet is a SYN: add skt to initial q, state=INITIAL
                TAILQ_INSERT_HEAD(&state->initial_q, skt, link);
                skt->state = INITIAL;
                skt->start_time_us = info->frame_time_us;
                aed_skt_see_syn(skt->skt);
                aed_sktcache_data_set_destructor(skt->skt, connreset_remove_sktcache_entry, state);
                log_event(BOTH_LOG, "#CONNRESET UNINIT --> INITIAL (SYN) @ %llu", skt->start_time_us);
                srcstate_insert_conn(ss, info->skt_cache_data);
            }
            else
            {
                // this packet is from mid-connection
                if (config->track_longlived)
                {
                    // Continue tracking this socket on the longlived queue.
                    skt->state = ACTIVE;
                    TAILQ_INSERT_HEAD(&state->longlived_q, skt, link);
                    aed_sktcache_data_set_destructor(skt->skt, connreset_remove_sktcache_entry, state);
                    log_event(BOTH_LOG, "#CONNRESET UNINIT --> ACTIVE");
                    srcstate_insert_conn(ss, info->skt_cache_data);
                }
                else
                {
                    // Stop tracking this socket.
                    skt->state = UNTRACKED;
                    log_event(BOTH_LOG, "#CONNRESET UNINIT --> UNTRACKED");
                }
            }
            return NSAED_ACTION_NONE;
        case INITIAL:
            log_event(BOTH_LOG, "#CONNRESET INITIAL %p", skt);
            if (info->tcp_flags & (TCP_FIN | TCP_RST))
            {
                // FIN|RST means conn is closing; clean up / stop tracking.
                TAILQ_REMOVE(&state->initial_q, skt, link);
                skt->state = UNTRACKED;
                if ((info->tcp_flags & TCP_FIN) && info->srcstate)
                {
                    // This is a "clean close", so reset the idle count.
                    NSAED_CONNRESET_SRCSTATE *srcstate = srcstate_get_protection(
                            info->srcstate, connreset_get_protection_id());
                    srcstate->idles = 0;
                }
                log_event(BOTH_LOG, "#CONNRESET INITIAL --> UNTRACKED (%s)", (info->tcp_flags & TCP_FIN) ? "FIN" : "RST");
                srcstate_remove_conn(ss, info->skt_cache_data);
            }
            else if (info->ip_parse_info.app_data_len > 0)
            {
                // if packet contains data payload: increment data_bytes by size of payload
                skt->data_bytes += info->ip_parse_info.app_data_len;
                log_event(BOTH_LOG, "#CONNRESET INITIAL data (%lu/%u)", skt->data_bytes, config->initial_bytes);
                if (skt->data_bytes >= config->initial_bytes)
                {
                    // We got enough data, move out of the initial queue.
                    TAILQ_REMOVE(&state->initial_q, skt, link);
                    aed_sktcache_data_set_destructor(skt->skt, NULL, NULL);
                    if (config->track_longlived)
                    {
                        // Continue tracking this socket on the longlived queue.
                        skt->state = ACTIVE;
                        TAILQ_INSERT_HEAD(&state->longlived_q, skt, link);
                        aed_sktcache_data_set_destructor(skt->skt, connreset_remove_sktcache_entry, state);
                        log_event(BOTH_LOG, "#CONNRESET INITIAL --> ACTIVE");
                    }
                    else
                    {
                        // Stop tracking this socket in the queues, but we will
                        // keep an eye on it being closed.
                        skt->state = UNTRACKED_ACTIVE;
                        log_event(BOTH_LOG, "#CONNRESET INITIAL --> UNTRACKED_ACTIVE");
                    }
                }
            }
            else
            {
                // Just move to head of initial TAILQ.
                TAILQ_REMOVE(&state->initial_q, skt, link);
                TAILQ_INSERT_HEAD(&state->initial_q, skt, link);
            }
            return NSAED_ACTION_NONE;

        case ACTIVE:
        case UNTRACKED_ACTIVE:
            log_event(BOTH_LOG, "#CONNRESET %s %p", connreset_skt_state_name(skt->state), skt);
            if (info->tcp_flags & (TCP_FIN | TCP_RST))
            {
                log_event(BOTH_LOG, "#CONNRESET %s --> UNTRACKED (%s)",
                        connreset_skt_state_name(skt->state),
                        (info->tcp_flags & TCP_FIN) ? "FIN" : "RST");
                // FIN|RST means conn is closing; clean up / stop tracking.
                TAILQ_REMOVE(&state->longlived_q, skt, link);
                skt->state = UNTRACKED;
                if ((info->tcp_flags & TCP_FIN) && info->srcstate)
                {
                    // This is a "clean close", so reset the idle count.
                    NSAED_CONNRESET_SRCSTATE *srcstate = srcstate_get_protection(
                            info->srcstate, connreset_get_protection_id());
                    srcstate->idles = 0;
                }
                srcstate_remove_conn(ss, info->skt_cache_data);
            }
            else if (skt->state == ACTIVE)
            {
                // Just move to head of longlived TAILQ.
                // Do this only for ACTIVE skt, because UNTRACKED_ACTIVE skts
                // are not in any queue.
                TAILQ_REMOVE(&state->longlived_q, skt, link);
                TAILQ_INSERT_HEAD(&state->longlived_q, skt, link);
            }
            return NSAED_ACTION_NONE;
    } // end switch
    return NSAED_ACTION_NONE;
}

PRIVATE VOID connreset_registered(N32 id)
{
    protection_id = id;
}

PRIVATE VOID connreset_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur)
{
    NSAED_CONNRESET_STATE* total = state_total;
    const NSAED_CONNRESET_STATE* cur = state_cur;
    total->stats.conn_muted += cur->stats.conn_muted;
    total->stats.src_blocked += cur->stats.src_blocked;
}

PRIVATE VOID connreset_stat_dump(const VOID *c, const VOID *s)
{
    const NSAED_CONNRESET_STATE* state = s;
    if (state)
    {
        rcon_printf("Connections muted by %s: %llu\n",
                CONNRESET_NAME, state->stats.conn_muted);
        rcon_printf("Sources blocked by %s: %llu\n",
                CONNRESET_NAME, state->stats.src_blocked);
    }
}

PRIVATE VOID connreset_stat_dump_json(cJSON* cj, const VOID *c, const VOID *s)
{
    const NSAED_CONNRESET_STATE* state = s;
    const NSAED_CONNRESET_STATS* stats = &state->stats;

    cJSON* connreset = cJSON_AddObjectToObject(cj, CONNRESET_ELEMENT_NAME);

    // Include `packets_dropped` for consistency with other protections in case
    // external systems (eg regression) depend on having this always reported.
    // Hard coded to zero here because connreset never drops packets directly.
    cJSON_AddNumberToObject(connreset, "packets_dropped", 0);
    cJSON_AddNumberToObject(connreset, "l3_bytes_dropped", 0);

    cJSON_AddNumberToObject(connreset, "connections_muted", stats->conn_muted);
    cJSON_AddNumberToObject(connreset, "sources_blocked", stats->src_blocked);
}

PRIVATE VOID* connreset_state_alloc()
{
    NSAED_CONNRESET_STATE *state = calloc(1, sizeof(NSAED_CONNRESET_STATE));
    TAILQ_INIT(&state->initial_q);
    TAILQ_INIT(&state->longlived_q);
    return state;
}

PRIVATE VOID connreset_state_free(VOID *prot)
{
    free(prot);
}

PRIVATE SRCSTATE* skt_get_srcstate(NSAED_CONNRESET_SKTCACHE *prot_skt, NSAED_PG_STATE *pg_state)
{
    AED_SKT_CACHE_DATA *skt = prot_skt->skt;
    return pg_state_get_srcstate_addr(pg_state, &skt->src_addr);
}

// Remove all connreset sockets of the specified source from both queues
PRIVATE INT connreset_remove_src_in_queues(NSAED_CONNRESET_STATE *state, const IPV4_IPV6_ADDR *addr)
{
    INT total = 0;
    NSAED_CONNRESET_SKTCACHE *prot_skt = NULL;
    CONNRESET_SKT_Q *queues[] = {
        &state->initial_q,
        &state->longlived_q,
        NULL,
    };

    for (CONNRESET_SKT_Q **q = queues; *q != NULL; ++q)
    {
        TAILQ_FOREACH_REVERSE(prot_skt, *q, CONNRESET_SKT_Q, link)
        {
            if (IS_IP_ADDR_EQUAL(*addr, prot_skt->skt->src_addr))
            {
                TAILQ_REMOVE(*q, prot_skt, link);
                ++total;
            }
        }
    }

    return total;
}

PRIVATE VOID connreset_tick(const VOID *prot_config, VOID *prot_state, NSAED_PG_STATE *pg_state, NSAED_INSP_THREAD *it)
{
    const NSAED_CONNRESET_CONFIG* config = prot_config;
    NSAED_CONNRESET_STATE* state = prot_state;
    NSAED_CONNRESET_SKTCACHE *prot_skt = NULL;

    N64 now_us = 1000ULL * timer_get_uptime();
    const N32 prot_id = connreset_get_protection_id();

    // parameters needed for walking through the connreset socket queues
    struct {
        CONNRESET_SKT_Q *queue; // the socket queue to walk through
        const char *name;       // queue name used for logging
        N64 timeout_us;         // timeout for sockets in this queue
        size_t ts_offset;       // offset of the timeout field in the connreset socket

        // Given a connreset socket in the current queue, return its timestamp
        // for determining if the socket has timed out.
        #define connreset_skt_timestamp(prot_skt, param) \
            (*(N64*)((N8*)(prot_skt) + param->ts_offset))
    } *p, params[] = {
        {
            &state->initial_q,
            "initial",
            config->initial_timeout_us,
            offsetof(NSAED_CONNRESET_SKTCACHE, start_time_us),
        }, {
            &state->longlived_q,
            "active",
            config->timeout_us,
            offsetof(NSAED_CONNRESET_SKTCACHE, last_uptime_time_us),
        }, {
            NULL,
        },
    };

    for (p = params; p->queue != NULL; p++)
    {
        TAILQ_FOREACH_REVERSE(prot_skt, p->queue, CONNRESET_SKT_Q, link)
        {
            N64 elapsed_us = now_us - connreset_skt_timestamp(prot_skt, p);
            if (elapsed_us > p->timeout_us)
            {
                SRCSTATE *ss = skt_get_srcstate(prot_skt, pg_state);
                assert(ss != NULL);
                NSAED_CONNRESET_SRCSTATE *prot_ss = srcstate_get_protection(ss, prot_id);

                prot_ss->idles++;
                if (aed_skt_mute(prot_skt->skt, it->pbi, nsaed_insp_id(it), protection_id))
                    state->stats.conn_muted++;

                if (prot_ss->idles > config->consecutive_idles)
                {
                    prot_ss->idles = 0;
                    state->stats.src_blocked++;
                    pg_blocklist_add_src(pg_state, &(prot_skt->skt->src_addr), now_us, prot_id);
                    INT conns_muted = srcstate_mute_all_conns(ss, it->pbi, nsaed_insp_id(it), protection_id);
                    // When blocking a source, we need to remove all connreset
                    // sockets of that source.
                    INT skts_found = connreset_remove_src_in_queues(state, &(prot_skt->skt->src_addr));
                    log_event(BOTH_LOG, "#CONNRESET BLOCK CONN %s %p, %d muted, %d removed",
                            p->name, prot_skt, conns_muted, skts_found);
                }
                else
                {
                    TAILQ_REMOVE(p->queue, prot_skt, link);
                    log_event(BOTH_LOG, "#CONNRESET MUTE CONN %s %p", p->name, prot_skt);
                }
            }
            else
            {
                // Since the list is sorted, there are no other entries that could
                // be timed-out.
                break;
            }
        }
    }
}

#endif // ISNG_BASED_AED
#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2024                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
                                                                        *
************************************************************************/
#include "dns_ndqf.h"
#include "spin_lock.h"

#include <string.h>
#include <arpa/inet.h>
#include <netinet/in.h>

#include "eventlog.h"
#include "xmibip.h"
#include "aed/action.h"
#include "aed/aed.h"
#include "aed/config.h"
#include "aed/foundation/aging_bloom_filter.h"
#include "aed/foundation/containers.h"
#include "aed/foundation/hash_functions.h"
#include "aed/foundation/hseih_hash.h"
#include "aed/foundation/lru.h"
#include "aed/foundation/pool.h"
#include "aed/protections/protection.h"
#include "aed/rdn.h"
#include "aed/tokenshare.h"
#include "aed/cJSON.h"
#include "rconapi.h"
#include "xmibflow.h"

#define DNSNDQF_NAME "Nonexistent Domain Query Flood"

IMPORT N32 currentUpTimeMSec;

struct XMIB_FLOW_INFO;
struct NSAED_ROOT;
struct NSAED_STATS;

#define MAX_TRACKED_ZONES 1000

typedef struct
{
    BOOL enabled;
    BOOL enforcing;
    N32 aging;
    N32 capacity;
    N32 precision;
    N32 attack_qps;
    N32 ratelimit_qps;
    N32 reporting_cutoff;
} NSAED_DNSNDQF_CONFIG;

typedef struct
{
    NSAED_PROTECTION_STATS_BASE stats_base;
    N64 total_failed_responses;
    N64 total_queries;
    N64 total_blocked_queries;
} NSAED_DNSNDQF_STATS;

typedef struct
{
    N64 total_queries;
    N64 blocked_queries;
} NSAED_DNSNDQF_ZONE_STATS;

typedef struct
{
    SPINLOCK lock;
    // Pool that contains the zone structs and manages their allocation/freeing
    pool_t *zone_pool;
    // LRU that contains pointers to the zone structs in zone_pool, for fast access
    lru_t *zone_lru;
} NSAED_DNSNDQF_STATE_SHARED;

typedef struct
{
    NSAED_DNSNDQF_STATS stats;
    N64 last_ageout;
    struct aging_bloom_filter *bfilter;
    NSAED_DNSNDQF_STATE_SHARED* shared;
} NSAED_DNSNDQF_STATE;

typedef struct
{
    // Lock free tokenshare. These must be on a 16-byte boundary.
    // When we allocate from the pool, they are on that boundary.
    // If you want to move these elsewhere in this struct, be careful about
    // alignment.
    tokenshare detect;
    tokenshare limiter;

    char zone[AED_DNS_DOMAIN_NAME_MAX];
    // Last time the zone was attacked, in microseconds since UTCbootuptimeUS
    N64 attacked;
    NSAED_DNSNDQF_ZONE_STATS stats;
} NSAED_DNSNDQF_ZONE;

PRIVATE VOID* dns_ndqf_config_alloc();
PRIVATE VOID dns_ndqf_config_free(VOID *prot);
PRIVATE VOID* dns_ndqf_state_alloc();
PRIVATE VOID dns_ndqf_state_free(VOID *prot);
PRIVATE VOID* dns_ndqf_state_shared_alloc();
PRIVATE VOID dns_ndqf_state_shared_free(VOID *shared);
PRIVATE VOID dns_ndqf_stats_dump(const VOID *c, const VOID *s);
PRIVATE VOID dns_ndqf_stats_dump_json(cJSON *cj, const VOID *c, const VOID *s);
PRIVATE VOID dns_ndqf_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur);
PRIVATE NSAED_ACTION dns_ndqf_inspect(const VOID *prot_config, VOID *prot_state, struct XMIB_FLOW_INFO *info);
PRIVATE VOID dns_ndqf_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *dns_ndqf_json);
PRIVATE BOOL dns_ndqf_config_get_enabled(VOID *prot_config);
PRIVATE VOID dns_ndqf_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE VOID dns_ndqf_config_dump(const VOID *c);
PRIVATE VOID dns_ndqf_config_loaded(const VOID *prot_config, VOID *prot_state, VOID *shared_state);
PRIVATE VOID dns_ndqf_registered(N32 id);
PRIVATE N32 dns_ndqf_get_protection_id();
PRIVATE VOID dns_ndqf_tick(const VOID *prot_config, VOID *prot_state, NSAED_PG_STATE *pg_state, NSAED_INSP_THREAD *);

PRIVATE VOID on_outbound_response(NSAED_DNSNDQF_STATE *state, char *dn, unsigned int rcode);
PRIVATE NSAED_ACTION on_inbound_query(const NSAED_DNSNDQF_CONFIG *config, NSAED_DNSNDQF_STATE *state, XMIB_FLOW_INFO* info, char *dn);

EXPORT const NSAED_PROTECTION dns_ndqf_protection = {
    .name = "dns_ndqf",
    .features = NSAED_FEATURE_REVERSE_CLASS,

    .config_allocator = dns_ndqf_config_alloc,
    .config_deallocator = dns_ndqf_config_free,
    .config_handler = dns_ndqf_config_handler,
    .config_get_enabled = dns_ndqf_config_get_enabled,
    .config_set_enabled = dns_ndqf_config_set_enabled,
    .config_dumper = dns_ndqf_config_dump,
    .config_loaded = dns_ndqf_config_loaded,
    .state_allocator = dns_ndqf_state_alloc,
    .state_deallocator = dns_ndqf_state_free,
    .state_shared_allocator = dns_ndqf_state_shared_alloc,
    .state_shared_deallocator = dns_ndqf_state_shared_free,
    .inspector = dns_ndqf_inspect,
    .stat_dumper = dns_ndqf_stats_dump,
    .stat_dumper_json = dns_ndqf_stats_dump_json,
    .stat_accumulator = dns_ndqf_stat_add,
    .registered = dns_ndqf_registered,
    .get_protection_id = dns_ndqf_get_protection_id,
    .tick = dns_ndqf_tick,
};

PRIVATE N32 protection_id = 0;

/*
 * Given an FQDN `www.example.com`, return its zone `example.com`.
 * Valid FQDN are handled by finding its RDN's offset and shifting right.
 * Invalid FQDNs are handled by skipping the left most label if it is at
 * least 3 labels long, else return the FQDN itself as the zone.
 * Egs: www.example.com        -> example.com
 *      _invalid_..example.com -> example.com
 *     _invalid_.com           -> _invalid_.com
 */
PRIVATE inline const char*
get_dn_zone(const char *dn)
{
    int idx, label_cnt;
    bool empty_label;
    const char *base_zone = dn, *zone = NULL;
    size_t len = strlen(dn);

    // If this is a valid FQDN, we can get the RDN's offset and
    // find the zone
    int offset;

    offset = nsaed_rdn_offset_calc(dn, strlen(dn));
    if (offset != RDN_OFFSET_INVALID)
    {
        return dn + offset;
    }

    // Check if the length exceeds the maximum DNS name length
    // Downstream mallocs might assume this as the zone's max length
    if (len < 1 || len > DNS_MAXNAMELEN)
    {
        return NULL;
    }

    // Check if the input is an IP address, return the IP as the zone if so.
    // TODO Do we need this check? Or handle it like any other string?
    struct in_addr addr4;
    struct in6_addr addr6;
    if (inet_pton(AF_INET, dn, &addr4) == 1 ||
        inet_pton(AF_INET6, dn, &addr6) == 1)
    {
        return dn;
    }
    // Start at the end of the dn and walk left to find the last 2 labels
    // We'll call this the base_zone
    // Eg abc.xyz.foo.com -> foo.com is the base_zone
    for (idx = len - 1, label_cnt = 0, empty_label = true; idx >= 0; idx--) {
        if (dn[idx] == '.') {
            // Skip consecutive dots
            if (empty_label)
            {
                continue;
            }
            // Reset the empty label flag
            empty_label = true;

            // Found 2 non-empty labels, make it the base-zone
            if (++label_cnt == 2) {
                // idx+1 to move to the right of the dot char
                base_zone = &dn[idx+1];
                break;
            }
        } else {
            // Seen a non-dot char, the label is not empty
            empty_label = false;
        }
    }

    // If the dn has lesser than 2 labels, there's not much we can
    // do to infer a zone. Return the dn as the zone.
    if (label_cnt < 2) {
        return dn;
    }

    // Now start at the beginning of the dn and walk right
    // to find the first label
    for (idx = 0, empty_label = true; idx < len; idx++) {
        if (dn[idx] == '.') {
            // Skip consecutive dots
            if (empty_label)
                continue;

            // Found the first non-empty label, set the remaining dn as
            // the zone, also remove any consecutive dots
            while (dn[++idx] == '.') {}
            zone = &dn[idx];

            // Return the inferred zone only if it is longer than the
            // base_zone, else return the base_zone
            // Eg: foo.com -> base_zone: foo.com, zone: com -> Return foo.com
            return (strlen(zone) > strlen(base_zone)) ? zone : base_zone;
        } else {
            // Seen a non-dot char, the label is not empty
            empty_label = false;
        }
    }

    // Should never reach here
    return NULL;
}

PRIVATE VOID
dns_ndqf_gen_hashes(const char *zone, N32 *hash1, N32 *hash2)
{
    size_t len = strlen(zone);
    *hash1 = fnv1a_hash(zone, len);
    *hash2 = inline_mixer_hash(zone, len);
}

PRIVATE int
cmp_zone(const VOID* key1, const VOID* key2)
{
    return strcmp(key1, key2);
}

PRIVATE N32
hash_zone(const VOID* key)
{
    return hseih_hash(key, strlen(key));
}

PRIVATE VOID dns_ndqf_stats_dump(const VOID *c, const VOID *s)
{
    const NSAED_DNSNDQF_STATE *state = s;
    if (state)
    {
        rcon_printf("Packets dropped by %s: %llu\n",
                DNSNDQF_NAME, state->stats.stats_base.pkt_dropped);
        rcon_printf("L3 Bytes dropped by %s: %llu\n",
                DNSNDQF_NAME, state->stats.stats_base.l3_byte_dropped);
        rcon_printf("Total queries by %s: %llu\n",
                DNSNDQF_NAME, state->stats.total_queries);
        rcon_printf("Total blocked queries by %s: %llu\n",
                DNSNDQF_NAME, state->stats.total_blocked_queries);
        rcon_printf("Total failed responses by %s: %llu\n",
                DNSNDQF_NAME, state->stats.total_failed_responses);
    }
}

PRIVATE VOID dns_ndqf_stats_dump_json(cJSON *cj, const VOID *c, const VOID *s)
{
    const NSAED_DNSNDQF_STATE* state = s;
    const NSAED_DNSNDQF_STATS* stats = &state->stats;

    cJSON* dns_ndqf = cJSON_AddObjectToObject(cj, dns_ndqf_protection.name);
    cJSON_AddNumberToObject(dns_ndqf, "packets_dropped", stats->stats_base.pkt_dropped);
    cJSON_AddNumberToObject(dns_ndqf, "l3_bytes_dropped", stats->stats_base.l3_byte_dropped);
    cJSON_AddNumberToObject(dns_ndqf, "total_queries", stats->total_queries);
    cJSON_AddNumberToObject(dns_ndqf, "total_blocked_queries", stats->total_blocked_queries);
    cJSON_AddNumberToObject(dns_ndqf, "total_failed_responses", stats->total_failed_responses);
}

PRIVATE VOID dns_ndqf_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur)
{
    NSAED_DNSNDQF_STATE* total = state_total;
    const NSAED_DNSNDQF_STATE* cur = state_cur;
    total->stats.stats_base.pkt_dropped += cur->stats.stats_base.pkt_dropped;
    total->stats.stats_base.l3_byte_dropped += cur->stats.stats_base.l3_byte_dropped;
    total->stats.total_queries += cur->stats.total_queries;
    total->stats.total_blocked_queries += cur->stats.total_blocked_queries;
    total->stats.total_failed_responses += cur->stats.total_failed_responses;
}

PRIVATE NSAED_ACTION dns_ndqf_inspect(const VOID *c, VOID* s, XMIB_FLOW_INFO *info)
{
    const NSAED_DNSNDQF_CONFIG *config = c;
    NSAED_DNSNDQF_STATE *state = s;
    NSAED_ACTION action = NSAED_ACTION_NONE;
    AED_DNS_INFO *dns_info = &info->aed_app_info.aed_dns_info;
    BOOL outbound;

    if (dns_info->app_info_type != AED_APP_DNS_TYPE)
    {
        return action;
    }

    // outbound/inbound packet
    outbound = !nsaed_is_external_ifn(info->orig_ifn);

    // response - QR flag set
    if (dns_info->msg_type)
    {
        if (outbound)
        {
            on_outbound_response(state, dns_info->domain_name, dns_info->rcode);
        }
    }
    else
    {
        if (!outbound)
        {
            action = on_inbound_query(config, state, info, dns_info->domain_name);
        }
    }
    return action;
}

PRIVATE NSAED_ACTION on_inbound_query(const NSAED_DNSNDQF_CONFIG *config, NSAED_DNSNDQF_STATE *state, XMIB_FLOW_INFO* info, char *dn)
{
    NSAED_DNSNDQF_ZONE* zone_ent;
    N32 h1, h2;
    pair_t ejected;
    const char *zone;

    state->stats.total_queries += 1;

    dns_ndqf_gen_hashes(dn, &h1, &h2);
    if (aging_bloom_filter_search(state->bfilter, h1, h2))
    {
        return NSAED_ACTION_NONE;
    }

    zone = get_dn_zone(dn);
    if (zone == NULL)
    {
        state->stats.stats_base.pkt_dropped += 1;
        state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
        state->stats.total_blocked_queries += 1;
        return NSAED_ACTION_DROP;
    }

    NSAED_DNSNDQF_STATE_SHARED* shared = state->shared;
    // Acquiring a lock here would impact performance.
    zone_ent = (NSAED_DNSNDQF_ZONE *)lru_get(shared->zone_lru, zone);

    if (zone_ent == NULL)
    {
        if (!spinlock_get(&shared->lock))
        {
            log_event(BOTH_LOG, "#DNSNDQF on_inbound_query: Unable to get the lock");
            return NSAED_ACTION_NONE;
        }

        // it's expensive to lookup twice, but this should be infrequent and
        // overall less expensive than taking the lock every time.
        zone_ent = (NSAED_DNSNDQF_ZONE *)lru_get(shared->zone_lru, zone);
        if (zone_ent == NULL)
        {
            zone_ent = pool_calloc(shared->zone_pool);
            if (zone_ent == NULL)
            {
                spinlock_release(&shared->lock);
                return NSAED_ACTION_NONE;
            }
            strlcpy(zone_ent->zone, zone, sizeof(zone_ent->zone));

            tokenshare_init(&zone_ent->detect, info->frame_time_us, config->attack_qps);
            tokenshare_init(&zone_ent->limiter, info->frame_time_us, config->ratelimit_qps);
            ejected = lru_put(shared->zone_lru, pair((VOID *)zone_ent->zone, (VOID *)zone_ent));
            if (ejected.key != NULL)
            {
                // pair was ejected from LRU cache; free the value
                pool_free(shared->zone_pool, ejected.value);
            }
        }

        spinlock_release(&shared->lock);
    }

    zone_ent->stats.total_queries += 1;

    tokenshare_fill(&zone_ent->detect, info->frame_time_us, config->attack_qps, config->attack_qps);
    if (tokenshare_consume(&zone_ent->detect, 1))
    {
        zone_ent->attacked = info->frame_time_us;
        if (config->enforcing)
        {
            tokenshare_fill(&zone_ent->limiter, info->frame_time_us, config->ratelimit_qps, config->ratelimit_qps);
            if (tokenshare_consume(&zone_ent->limiter, 1))
            {
                state->stats.stats_base.pkt_dropped += 1;
                state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
                state->stats.total_blocked_queries += 1;
                zone_ent->stats.blocked_queries += 1;
                return NSAED_ACTION_DROP;
            }
        }
    }

    return NSAED_ACTION_NONE;
}

PRIVATE VOID on_outbound_response(NSAED_DNSNDQF_STATE *state, char *dn, unsigned int rcode)
{
    if (rcode == 0) // NOERROR
    {
        N32 h1, h2;
        dns_ndqf_gen_hashes(dn, &h1, &h2);
        aging_bloom_filter_set(state->bfilter, h1, h2);
    }
    else
    {
        state->stats.total_failed_responses += 1;
    }
}

PRIVATE VOID dns_ndqf_tick(const VOID *prot_config, VOID *prot_state, NSAED_PG_STATE *pg_state, NSAED_INSP_THREAD *)
{
    NSAED_DNSNDQF_STATE *state = prot_state;
    if (aging_bloom_filter_ageout(state->bfilter, currentUpTimeMSec) == ABF_AGEOUT_NO_MEMORY)
    {
        log_event(BOTH_LOG, "#NSAED-DNSNDQF: failed to allocate bloom filter");
        exit(1);
    }
}

PRIVATE VOID dns_ndqf_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *dns_ndqf_json)
{
    NSAED_DNSNDQF_CONFIG *config = prot_config;
    cJSON *attack_qps = cJSON_GetObjectItemCaseSensitive(dns_ndqf_json, "attack_qps");
    cJSON *ratelimit_qps = cJSON_GetObjectItemCaseSensitive(dns_ndqf_json, "ratelimit_qps");
    cJSON *enforcing = cJSON_GetObjectItemCaseSensitive(dns_ndqf_json, "enforcing");
    cJSON *aging = cJSON_GetObjectItemCaseSensitive(dns_ndqf_json, "aging");
    cJSON *capacity = cJSON_GetObjectItemCaseSensitive(dns_ndqf_json, "capacity");
    cJSON *precision = cJSON_GetObjectItemCaseSensitive(dns_ndqf_json, "precision");
    cJSON *reporting_cutoff = cJSON_GetObjectItemCaseSensitive(dns_ndqf_json, "reporting_cutoff");

    config->enforcing = FALSE;
    config->attack_qps = 25;
    config->ratelimit_qps = 20;
    config->aging = 1073741824; // This will effectively disable aging by default
    config->capacity = 400000;
    config->precision = 3;
    config->reporting_cutoff = 100;

    if (attack_qps && cJSON_IsNumber(attack_qps))
    {
        config->attack_qps = (INT)cJSON_GetNumberValue(attack_qps);
    }

    if (ratelimit_qps && cJSON_IsNumber(ratelimit_qps))
    {
        config->ratelimit_qps = (INT)cJSON_GetNumberValue(ratelimit_qps);
    }

    if (aging && cJSON_IsNumber(aging))
    {
        config->aging = (INT)cJSON_GetNumberValue(aging);
    }

    if (capacity && cJSON_IsNumber(capacity))
    {
        config->capacity = (INT)cJSON_GetNumberValue(capacity);
    }

    if (precision && cJSON_IsNumber(precision))
    {
        config->precision = (INT)cJSON_GetNumberValue(precision);
    }

    if (reporting_cutoff && cJSON_IsNumber(reporting_cutoff))
    {
        config->reporting_cutoff = (INT)cJSON_GetNumberValue(reporting_cutoff);
    }

    if (enforcing && cJSON_IsBool(enforcing))
    {
        config->enforcing = cJSON_IsTrue(enforcing) ? TRUE : FALSE;
    }
}

PRIVATE BOOL dns_ndqf_config_get_enabled(VOID *prot_config)
{
    NSAED_DNSNDQF_CONFIG *config = prot_config;
    return config->enabled;
}

PRIVATE VOID dns_ndqf_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_DNSNDQF_CONFIG *config = prot_config;
    config->enabled = state;
}

PRIVATE VOID dns_ndqf_config_dump(const VOID *c)
{
    const NSAED_DNSNDQF_CONFIG *config = c;
    rcon_printf("%s\n  Enabled: %s\n", DNSNDQF_NAME,
        IS_PROTECTION_ENABLED(config->enabled));
    if (config->enabled)
    {
        rcon_printf("  Enforcing: %s\n", IS_PROTECTION_ENABLED(config->enforcing));
        rcon_printf("  Attack QPS: %u\n", config->attack_qps);
        rcon_printf("  Ratelimit QPS: %u\n", config->ratelimit_qps);
        rcon_printf("  Aging: %u\n", config->aging);
        rcon_printf("  Capacity: %u\n", config->capacity);
        rcon_printf("  Precision: %u\n", config->precision);
        rcon_printf("  Reporting Cutoff: %u\n", config->reporting_cutoff);
    }

}

PRIVATE VOID dns_ndqf_config_loaded(const VOID *c, VOID *s, VOID *sh)
{
    const NSAED_DNSNDQF_CONFIG *config = c;
    NSAED_DNSNDQF_STATE *state = s;
    state->shared = sh;

    if (state->bfilter == NULL)
    {
        state->bfilter = aging_bloom_filter_create(config->capacity, config->precision, config->aging * 1000ULL);
        if (state->bfilter == NULL)
        {
            log_event(BOTH_LOG, "#NSAED-DNSNDQF: failed to allocate bloom filter");
            exit(1);
        }
    }
    else
    {
        aging_bloom_filter_set_params(state->bfilter, config->capacity, config->precision, config->aging * 1000ULL);
    }
}

PRIVATE VOID* dns_ndqf_config_alloc()
{
    return calloc(1, sizeof(NSAED_DNSNDQF_CONFIG));
}

PRIVATE VOID dns_ndqf_config_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    free(prot);
}

PRIVATE VOID* dns_ndqf_state_alloc()
{
    return calloc(1, sizeof(NSAED_DNSNDQF_STATE));
}

PRIVATE VOID dns_ndqf_state_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    NSAED_DNSNDQF_STATE *protection = (NSAED_DNSNDQF_STATE *)prot;
    aging_bloom_filter_destroy(protection->bfilter);
    free(protection);
}

PRIVATE VOID* dns_ndqf_state_shared_alloc()
{
    NSAED_DNSNDQF_STATE_SHARED* shared = calloc(1, sizeof(NSAED_DNSNDQF_STATE_SHARED));
    shared->zone_pool = pool_new(sizeof(NSAED_DNSNDQF_ZONE));
    shared->zone_lru = lru_new(MAX_TRACKED_ZONES, cmp_zone, hash_zone);
    if (!shared->zone_pool || !shared->zone_lru)
    {
        dns_ndqf_state_shared_free(shared);
        return NULL;
    }
    spinlock_init(&shared->lock);
    return shared;
}

PRIVATE VOID dns_ndqf_state_shared_free(VOID *shared)
{
    NSAED_DNSNDQF_STATE_SHARED* s = shared;
    if (s == NULL)
    {
        return;
    }

    pool_release(&s->zone_pool);
    lru_release(&s->zone_lru);
    spinlock_release(&s->lock);
    free(s);
}

// Macro for use in dns_ndqf_zua_dump*()
//
// The macro converts zone->attacked to a unix timestamp in seconds, for an
// apples-to-apples comparison with other time values.
// The macro also checks whether `zone->attacked` is 0. It can be 0 if the zone has never
// hit the detect threshold. That 0 is not a real time value, and we don't want to report
// such zones.
#define CONTINUE_IF_STALE(now, zone, config)                                                      \
    if (!zone->attacked ||                                                                        \
        (now.tv_sec - (zone->attacked + UTCbootuptimeUS) / 1000000 > config->reporting_cutoff))   \
    {                                                                                             \
        continue;                                                                                 \
    }

// Each thread has access to the shared view of the LRU. Hence, we use the
// shared ndqf state to dump the common ZUA list just once.
EXPORT VOID dns_ndqf_zua_dump(const VOID* c, VOID* s)
{
    const NSAED_DNSNDQF_CONFIG *config = c;
    NSAED_DNSNDQF_STATE_SHARED *shared = s;
    if (!config || !shared || !shared->zone_lru) {
        return;
    }

    // Get current time
    struct timespec now;
    clock_gettime(CLOCK_REALTIME, &now);

    // Acquiring the lock to avoid inconsistencies in dump.
    if (!spinlock_get(&shared->lock))
    {
        log_event(BOTH_LOG, "#DNSNDQF config_loaded: Unable to get the lock.");
        return;
    }

    // Loop through the LRU of zones
    lru_iter_t li;
    pair_t entry;
    container_foreach(lru, shared->zone_lru, li, entry) {
        NSAED_DNSNDQF_ZONE *zone = entry.value;

        CONTINUE_IF_STALE(now, zone, config);

        rcon_printf("  Zone: %s\n", zone->zone);
        rcon_printf("    Total queries: %llu\n", zone->stats.total_queries);
        rcon_printf("    Blocked queries: %llu\n", zone->stats.blocked_queries);
    }

    spinlock_release(&shared->lock);
}

EXPORT VOID dns_ndqf_zua_dump_json(cJSON *cj, const VOID* c, VOID* s)
{
    const NSAED_DNSNDQF_CONFIG *config = c;
    NSAED_DNSNDQF_STATE_SHARED *shared = s;
    if (!config || !shared || !shared->zone_lru) {
        return;
    }

    // Get current time
    struct timespec now;
    clock_gettime(CLOCK_REALTIME, &now);

    // Acquiring the lock to avoid inconsistencies in dump.
    if (!spinlock_get(&shared->lock))
    {
        log_event(BOTH_LOG, "#DNSNDQF config_loaded: Unable to get the lock.");
        return;
    }

    // Loop through the LRU of zones
    lru_iter_t li;
    pair_t entry;
    container_foreach(lru, shared->zone_lru, li, entry) {
        NSAED_DNSNDQF_ZONE *zone = entry.value;

        CONTINUE_IF_STALE(now, zone, config);

        cJSON* zone_json = cJSON_AddObjectToObject(cj, zone->zone);
        cJSON_AddNumberToObject(zone_json, "total_queries", zone->stats.total_queries);
        cJSON_AddNumberToObject(zone_json, "blocked_queries", zone->stats.blocked_queries);
    }

    spinlock_release(&shared->lock);
}

PRIVATE VOID dns_ndqf_registered(N32 id) {
    protection_id = id;
}

PRIVATE N32 dns_ndqf_get_protection_id() {
    return protection_id;
}
#endif //ISNG_BASED_AED
#pragma once
#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                         Copyright (c) 2024                            *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
                                                                        *
************************************************************************/
#include "fsdstd.h"
#include "aed/cJSON.h"

/*****************************************************************************
 * Function : dns_ndqf_zua_dump
 * Desc     : Dumps JSONfied DNS NDQF zone-under-attack stats for the current PG.
 *            This function needs the config to know the reporting cutoff.
 * Input    : c: pointer to the DNS NDQF protection config
 *          : s: pointer to the DNS NDQF shared protection state
 * Output Format:
   Zone: example.com
     Total queries: 12345
     Blocked queries: 123
   Zone: another.example.com
     Total queries: 23456
     Blocked queries: 234
****************************************************************************/
IMPORT VOID dns_ndqf_zua_dump(const VOID* c, VOID* s);

/*****************************************************************************
 * Function : dns_ndqf_zua_dump_json
 * Desc     : Dumps JSONfied DNS NDQF zone-under-attack stats for the current PG.
 *            This function needs the config to know the reporting cutoff.
 * Input    : cj: pointer to a cJSON object that will be populated with ZUA stats.
 *          : c: pointer to the DNS NDQF protection config
 *          : s: pointer to the DNS NDQF shared protection state
 * Output Format:
{
    "example.com": {
        "total_queries": 12345,
        "blocked_queries": 123
    },
    "another.example.com": {
        "total_queries": 23456,
        "blocked_queries": 234
    },
}
****************************************************************************/
IMPORT VOID dns_ndqf_zua_dump_json(cJSON *cj, const VOID* c, VOID* s);

#endif // ISNG_BASED_AED
#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2024                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
                                                                        *
************************************************************************/
#include <netinet/in.h>
#include <string.h>

#include "eventlog.h"
#include "aed/aed.h"
#include "dns.h"
#include "xmibip.h"
#include "aed/foundation/aging_bloom_filter.h"
#include "aed/foundation/hash_functions.h"
#include "aed/cJSON.h"
#include "rconapi.h"
#include "xmibflow.h"

#define DNS_RA_NAME "DNS Amplification"

IMPORT N32 currentUpTimeMSec;

struct XMIB_FLOW_INFO;
struct NSAED_ROOT;
struct NSAED_STATS;

typedef struct
{
    BOOL enabled;
    N32 aging;
    N32 capacity;
    N32 precision;
    N32 warmup;
} NSAED_DNSRA_CONFIG;

typedef struct
{
    NSAED_PROTECTION_STATS_BASE stats_base;
} NSAED_DNSRA_STATS;

typedef struct
{
    NSAED_DNSRA_STATS stats;
    N64 last_ageout;
    N64 warmup_time;
    BOOL warmed_up;
    struct aging_bloom_filter *bfilter;
} NSAED_DNSRA_STATE;

PRIVATE VOID* dns_ra_config_alloc();
PRIVATE VOID dns_ra_config_free(VOID *prot);
PRIVATE VOID* dns_ra_state_alloc();
PRIVATE VOID dns_ra_state_free(VOID *prot);
PRIVATE VOID dns_ra_stat_dump(const VOID *c, const VOID *s);
PRIVATE VOID dns_ra_stat_dump_json(cJSON *cj, const VOID *c, const VOID *s);
PRIVATE VOID dns_ra_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur);
PRIVATE NSAED_ACTION dns_ra_inspect(const VOID *prot_config, VOID *prot_state, struct XMIB_FLOW_INFO *info);
PRIVATE VOID dns_ra_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *dns_ra_json);
PRIVATE BOOL dns_ra_config_get_enabled(VOID *prot_config);
PRIVATE VOID dns_ra_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE VOID dns_ra_config_dump(const VOID *c);
PRIVATE VOID dns_ra_config_loaded(const VOID *prot_config, VOID *prot_state, VOID *shared_state);

PRIVATE VOID on_outbound_query(NSAED_DNSRA_STATE *state, IP_PARSER_INFO *ip_info, N16 id);
PRIVATE NSAED_ACTION on_inbound_response(NSAED_DNSRA_STATE *state, IP_PARSER_INFO* ip_info, N16 id);
PRIVATE VOID dns_ra_registered(N32 id);
PRIVATE N32 dns_ra_get_protection_id();
PRIVATE VOID dns_ra_tick(const VOID *prot_config, VOID *prot_state, NSAED_PG_STATE *pg_state, NSAED_INSP_THREAD *);


EXPORT const NSAED_PROTECTION dns_ra_protection = {
    .name = "dns_ra",
    .features = NSAED_FEATURE_REVERSE_CLASS,

    .config_allocator = dns_ra_config_alloc,
    .config_deallocator = dns_ra_config_free,
    .config_handler = dns_ra_config_handler,
    .config_get_enabled = dns_ra_config_get_enabled,
    .config_set_enabled = dns_ra_config_set_enabled,
    .config_dumper = dns_ra_config_dump,
    .config_loaded = dns_ra_config_loaded,
    .state_allocator = dns_ra_state_alloc,
    .state_deallocator = dns_ra_state_free,
    .inspector = dns_ra_inspect,
    .stat_dumper = dns_ra_stat_dump,
    .stat_dumper_json = dns_ra_stat_dump_json,
    .stat_accumulator = dns_ra_stat_add,
    .registered = dns_ra_registered,
    .get_protection_id = dns_ra_get_protection_id,
    .tick = dns_ra_tick,
};

PRIVATE N32 protection_id = 0;


PRIVATE N32
dns_ra_gen_hash1(const VOID *addr, N8 ip_version)
{
    size_t addr_len = ip_version == 6 ? 16 : 4;

    return fnv1a_hash(addr, addr_len);
}

PRIVATE N32
dns_ra_gen_hash2(N16 port, N16 dns_id)
{
    N32 id = (dns_id << 16) | port;

    return inline_mixer_hash(&id, sizeof(id));
}

PRIVATE VOID dns_ra_stat_dump(const VOID *c, const VOID *s)
{
    const NSAED_DNSRA_STATE *state = s;
    if (state)
    {
        rcon_printf("Packets dropped by %s: %llu\n",
                DNS_RA_NAME, state->stats.stats_base.pkt_dropped);
        rcon_printf("L3 Bytes dropped by %s: %llu\n",
                DNS_RA_NAME, state->stats.stats_base.l3_byte_dropped);
    }
}

PRIVATE VOID dns_ra_stat_dump_json(cJSON *cj, const VOID *c, const VOID *s)
{
    const NSAED_DNSRA_STATE* state = s;
    const NSAED_DNSRA_STATS* stats = &state->stats;

    cJSON* dns_ra = cJSON_AddObjectToObject(cj, dns_ra_protection.name);
    cJSON_AddNumberToObject(dns_ra, "packets_dropped", stats->stats_base.pkt_dropped);
    cJSON_AddNumberToObject(dns_ra, "l3_bytes_dropped", stats->stats_base.l3_byte_dropped);
}

PRIVATE VOID dns_ra_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur)
{
    NSAED_DNSRA_STATE* total = state_total;
    const NSAED_DNSRA_STATE* cur = state_cur;
    total->stats.stats_base.pkt_dropped += cur->stats.stats_base.pkt_dropped;
    total->stats.stats_base.l3_byte_dropped += cur->stats.stats_base.l3_byte_dropped;
}

PRIVATE NSAED_ACTION dns_ra_inspect(const VOID *c, VOID* s, XMIB_FLOW_INFO *info)
{
    const NSAED_DNSRA_CONFIG *config = c;
    NSAED_DNSRA_STATE *state = s;
    NSAED_ACTION action = NSAED_ACTION_NONE;
    AED_DNS_INFO *dns_info = &info->aed_app_info.aed_dns_info;
    BOOL outbound;

    if (info->ip_parse_info.protocol != IPPROTO_UDP)
    {
        return action;
    }

    if (dns_info->app_info_type != AED_APP_DNS_TYPE)
    {
        return action;
    }

    if (dns_info->opcode != OPCODE_QUERY)
    {
        return action;
    }

    // outbound/inbound packet
    outbound = !nsaed_is_external_ifn(info->orig_ifn);

    if (state->warmed_up == FALSE && (currentUpTimeMSec - state->warmup_time)/1000 >= config->warmup)
    {
        state->warmed_up = TRUE;
    }

    if (outbound)
    {
        if (dns_info->msg_type == QR_QUERY)
        {
            on_outbound_query(state, &info->ip_parse_info, dns_info->id);
        }
    }
    else if (state->warmed_up)
    {
        if (dns_info->msg_type == QR_RESPONSE)
        {
            action = on_inbound_response(state, &info->ip_parse_info, dns_info->id);
        }
    }
    return action;
}

PRIVATE NSAED_ACTION on_inbound_response(NSAED_DNSRA_STATE *state, IP_PARSER_INFO* ip_info, N16 id)
{
    N32 h1 = dns_ra_gen_hash1(&ip_info->addr[0].src, ip_info->ip_version);
    N32 h2 = dns_ra_gen_hash2(ip_info->dest_port, id);
    if (aging_bloom_filter_search(state->bfilter, h1, h2))
    {
        return NSAED_ACTION_NONE;
    }
    state->stats.stats_base.pkt_dropped += 1;
    // Not using L3_BYTES macro here to avoid modifying macro definition/call
    // to handle IP_PARSER_INFO* as input and to avoid this function from taking
    // XMIB_FLOW_INFO as input. Update here and macro or add another macro if we
    // have multiple similar occurrences.
    state->stats.stats_base.l3_byte_dropped += (ip_info->ip_hdr_len + ip_info->ip_payload_len);

    return NSAED_ACTION_DROP;
}

PRIVATE VOID on_outbound_query(NSAED_DNSRA_STATE *state, IP_PARSER_INFO *ip_info, N16 id)
{

    N32 h1 = dns_ra_gen_hash1(&ip_info->addr[0].dest, ip_info->ip_version);
    N32 h2 = dns_ra_gen_hash2(ip_info->src_port, id);
    aging_bloom_filter_set(state->bfilter, h1, h2);
}

PRIVATE VOID dns_ra_tick(const VOID *prot_config, VOID *prot_state, NSAED_PG_STATE *pg_state, NSAED_INSP_THREAD *)
{
    NSAED_DNSRA_STATE *state = prot_state;
    if (aging_bloom_filter_ageout(state->bfilter, currentUpTimeMSec) == ABF_AGEOUT_NO_MEMORY)
    {
        log_event(BOTH_LOG, "#NSAED-DNSRA: failed to allocate bloom filter");
        exit(1);
    }
}

PRIVATE VOID dns_ra_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *dns_ra_json)
{
    NSAED_DNSRA_CONFIG *config = prot_config;
    cJSON *warmup = cJSON_GetObjectItemCaseSensitive(dns_ra_json, "warmup");
    cJSON *aging = cJSON_GetObjectItemCaseSensitive(dns_ra_json, "aging");
    cJSON *capacity = cJSON_GetObjectItemCaseSensitive(dns_ra_json, "capacity");
    cJSON *precision = cJSON_GetObjectItemCaseSensitive(dns_ra_json, "precision");

    config->aging = 5;
    config->capacity = 1000000;
    config->precision = 3;
    config->warmup = 2;

    if (warmup && cJSON_IsNumber(warmup))
    {
        config->warmup = (INT)cJSON_GetNumberValue(warmup);
    }

    if (aging && cJSON_IsNumber(aging))
    {
        config->aging = (INT)cJSON_GetNumberValue(aging);
    }

    if (capacity && cJSON_IsNumber(capacity))
    {
        config->capacity = (INT)cJSON_GetNumberValue(capacity);
    }

    if (precision && cJSON_IsNumber(precision))
    {
        config->precision = (INT)cJSON_GetNumberValue(precision);
    }
}

PRIVATE BOOL dns_ra_config_get_enabled(VOID *prot_config)
{
    NSAED_DNSRA_CONFIG *config = prot_config;
    return config->enabled;
}

PRIVATE VOID dns_ra_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_DNSRA_CONFIG *config = prot_config;
    config->enabled = state;
}

PRIVATE VOID dns_ra_config_dump(const VOID *c)
{
    const NSAED_DNSRA_CONFIG *config = c;
    rcon_printf("%s\n  Enabled: %s\n", DNS_RA_NAME,
        IS_PROTECTION_ENABLED(config->enabled));
    if (config->enabled)
    {
        rcon_printf("  Aging: %u\n", config->aging);
        rcon_printf("  Warmup: %u\n", config->warmup);
        rcon_printf("  Capacity: %u\n", config->capacity);
        rcon_printf("  Precision: %u\n", config->precision);
    }

}

PRIVATE VOID dns_ra_config_loaded(const VOID *c, VOID *s, VOID *sh)
{
    const NSAED_DNSRA_CONFIG *config = c;
    NSAED_DNSRA_STATE *state = s;
    if (state->bfilter == NULL)
    {
        state->bfilter = aging_bloom_filter_create(config->capacity, config->precision, config->aging * 1000ULL);
        if (state->bfilter == NULL)
        {
            log_event(BOTH_LOG, "#NSAED-DNSRA: failed to allocate bloom filter");
            exit(1);
        }
        state->warmup_time = currentUpTimeMSec;
    }
    else
    {
        aging_bloom_filter_set_params(state->bfilter, config->capacity, config->precision, config->aging * 1000ULL);
    }
}

PRIVATE VOID* dns_ra_config_alloc()
{
    return calloc(1, sizeof(NSAED_DNSRA_CONFIG));
}

PRIVATE VOID dns_ra_config_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    free(prot);
}

PRIVATE VOID* dns_ra_state_alloc()
{
    NSAED_DNSRA_STATE* prot = calloc(1, sizeof(NSAED_DNSRA_STATE));
    if (prot == NULL)
    {
        return NULL;
    }
    // Bloom filters are allocated in the config loaded handler,
    // since we don't know the capacity or precision of the bloom
    // filters yet.
    return prot;
}

PRIVATE VOID dns_ra_state_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    NSAED_DNSRA_STATE *protection = (NSAED_DNSRA_STATE *)prot;
    aging_bloom_filter_destroy(protection->bfilter);
    free(protection);
}

PRIVATE VOID dns_ra_registered(N32 id)
{
    protection_id = id;
}

PRIVATE N32 dns_ra_get_protection_id()
{
    return protection_id;
}

#endif //ISNG_BASED_AED
#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2024                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
                                                                        *
************************************************************************/

#include <netinet/in.h>
#include <string.h>

#include "eventlog.h"
#include "aed/aed.h"
#include "aed/action.h"
#include "aed/cJSON.h"
#include "aed/regex.h"

#define DNSREGEX_NAME "DNS Regular Expression"
#define DNSREGEX_ELEMENT_NAME "dns_regex"
#define KEY_COMPILED_ID "compiled_id"

typedef struct
{
    BOOL enabled;
    TEXT *compiled_id;
    NSAED_REGEX regex;
} NSAED_DNSREGEX_CONFIG;

typedef struct
{
    NSAED_PROTECTION_STATS_BASE stats_base;
} NSAED_DNSREGEX_STATS;

typedef struct
{
    NSAED_DNSREGEX_STATS stats;
} NSAED_DNSREGEX_STATE;

PRIVATE VOID* dns_regex_config_alloc();
PRIVATE VOID dns_regex_config_free(VOID *prot);
PRIVATE VOID dns_regex_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *json);
PRIVATE BOOL dns_regex_config_get_enabled(VOID *prot_config);
PRIVATE VOID dns_regex_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE VOID dns_regex_config_dump(const VOID *prot_config);

PRIVATE NSAED_ACTION dns_regex_inspect(const VOID *prot_config, VOID *prot_state, struct XMIB_FLOW_INFO *info);
PRIVATE VOID dns_regex_stat_dump(const VOID *config, const VOID *state);
PRIVATE VOID dns_regex_stat_dump_json(cJSON* cj, const VOID *config, const VOID *state);
PRIVATE VOID dns_regex_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur);
PRIVATE VOID* dns_regex_state_alloc();
PRIVATE VOID dns_regex_state_free(VOID *prot);
PRIVATE VOID dns_regex_registered(N32 id);
PRIVATE N32 dns_regex_get_protection_id();

EXPORT const NSAED_PROTECTION dns_regex_protection = {
    .name = DNSREGEX_ELEMENT_NAME,
    // This protection doesn't do anything specific with srcstate but
    // we need this feature enabled for get_skt_cache_data() to work.
    .features = NSAED_FEATURE_SRCSTATE | NSAED_FEATURE_SOCKET,

    .config_allocator = dns_regex_config_alloc,
    .config_deallocator = dns_regex_config_free,
    .config_handler = dns_regex_config_handler,
    .config_get_enabled = dns_regex_config_get_enabled,
    .config_set_enabled = dns_regex_config_set_enabled,
    .config_dumper = dns_regex_config_dump,
    .inspector = dns_regex_inspect,
    .stat_dumper = dns_regex_stat_dump,
    .stat_dumper_json = dns_regex_stat_dump_json,
    .stat_accumulator = dns_regex_stat_add,
    .state_allocator = dns_regex_state_alloc,
    .state_deallocator = dns_regex_state_free,
    .registered = dns_regex_registered,
    .get_protection_id = dns_regex_get_protection_id,
};

PRIVATE N32 protection_id = 0;

PRIVATE VOID* dns_regex_config_alloc()
{
    return calloc(1, sizeof(NSAED_DNSREGEX_CONFIG));
}

PRIVATE VOID dns_regex_config_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    NSAED_DNSREGEX_CONFIG *config = prot;

    if (nsaed_regex_is_valid(config->regex))
    {
        nsaed_regex_unload(config->regex);
    }

    free(config->compiled_id);
    free(config);
}

PRIVATE VOID dns_regex_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *dns_regex_json)
{
    NSAED_DNSREGEX_CONFIG *config = prot_config;
    cJSON *compiled_id_json = cJSON_GetObjectItemCaseSensitive(dns_regex_json, KEY_COMPILED_ID);
    if (compiled_id_json && cJSON_IsString(compiled_id_json))
    {
        TEXT *compiled_id = cJSON_GetStringValue(compiled_id_json);
        config->regex = nsaed_regex_load(compiled_id);
        if (nsaed_regex_is_valid(config->regex))
        {
            log_event(DBG_LOG, "#NSAED-CFG dns regex loaded \"%s\"", compiled_id);
            // save it for config dump
            config->compiled_id = strdup(compiled_id);
            return;
        }
        else
        {
            log_event(BOTH_LOG, "#NSAED-CFG dns regex load \"%s\" failed", compiled_id);
        }
    }
    else
    {
        log_event(BOTH_LOG, "#NSAED-CFG invalid dns regex config, "
                "\"%s\" is not specified or not a string", KEY_COMPILED_ID);
    }

    dns_regex_config_set_enabled(config, FALSE);
}

PRIVATE BOOL dns_regex_config_get_enabled(VOID *prot_config)
{
    NSAED_DNSREGEX_CONFIG *config = prot_config;
    return config->enabled;
}

PRIVATE VOID dns_regex_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_DNSREGEX_CONFIG *config = prot_config;
    config->enabled = state;
}

PRIVATE VOID dns_regex_config_dump(const VOID *prot_config)
{
    const NSAED_DNSREGEX_CONFIG* config = prot_config;
    rcon_printf("%s\n  Enabled: %s\n", DNSREGEX_NAME,
            IS_PROTECTION_ENABLED(config->enabled));
    if (config->enabled)
    {
        rcon_printf("  Compiled ID: %s\n", config->compiled_id);
    }
}

PRIVATE NSAED_ACTION
dns_regex_inspect(const VOID *prot_config, VOID *prot_state, struct XMIB_FLOW_INFO *info)
{
    const NSAED_DNSREGEX_CONFIG *config = prot_config;
    NSAED_DNSREGEX_STATE *state = prot_state;
    AED_DNS_INFO *dns_info = &info->aed_app_info.aed_dns_info;

    if (dns_info->app_info_type != AED_APP_DNS_TYPE)
    {
        return NSAED_ACTION_NONE;
    }

    if (dns_info->msg_type)
    {
        // QR flag set - Skip inspection for responses
        return NSAED_ACTION_NONE;
    }

    if (nsaed_regex_match(config->regex, dns_info->domain_name, dns_info->domain_name_len))
    {
        if (info->ip_parse_info.protocol == IPPROTO_TCP)
        {
            aed_skt_mute_by_pkt(info->skt_cache_data, info, protection_id);
        }

        state->stats.stats_base.pkt_dropped++;
        state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
        return NSAED_ACTION_DROP;
    }

    return NSAED_ACTION_NONE;
}

PRIVATE VOID dns_regex_stat_dump(const VOID *c, const VOID *s)
{
    const NSAED_DNSREGEX_STATE* state = s;
    if (state)
    {
        rcon_printf("Packets dropped by %s: %llu\n",
                DNSREGEX_NAME, state->stats.stats_base.pkt_dropped);
        rcon_printf("L3 Bytes dropped by %s: %llu\n",
                DNSREGEX_NAME, state->stats.stats_base.l3_byte_dropped);
    }
}

PRIVATE VOID dns_regex_stat_dump_json(cJSON* cj, const VOID *c, const VOID *s)
{
    const NSAED_DNSREGEX_STATE* state = s;
    const NSAED_DNSREGEX_STATS* stats = &state->stats;

    cJSON* dnsregex = cJSON_AddObjectToObject(cj, DNSREGEX_ELEMENT_NAME);
    cJSON_AddNumberToObject(dnsregex, "packets_dropped", stats->stats_base.pkt_dropped);
    cJSON_AddNumberToObject(dnsregex, "l3_bytes_dropped", stats->stats_base.l3_byte_dropped);
}

PRIVATE VOID dns_regex_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur)
{
    NSAED_DNSREGEX_STATE* total = state_total;
    const NSAED_DNSREGEX_STATE* cur = state_cur;
    total->stats.stats_base.pkt_dropped += cur->stats.stats_base.pkt_dropped;
    total->stats.stats_base.l3_byte_dropped += cur->stats.stats_base.l3_byte_dropped;
}

PRIVATE VOID* dns_regex_state_alloc()
{
    return calloc(1, sizeof(NSAED_DNSREGEX_STATE));
}

PRIVATE VOID dns_regex_state_free(VOID *prot)
{
    free(prot);
}

PRIVATE VOID dns_regex_registered(N32 id)
{
    protection_id = id;
}

PRIVATE N32 dns_regex_get_protection_id()
{
    return protection_id;
}

#endif // ISNG_BASED_AED
#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2024                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
*                                                                       *
************************************************************************/

#include "eventlog.h"
#include "aed/aed.h"
#include "aed/aedmacros.h"
#include "aed/cJSON.h"
#include "xmibflow.h"
#include "ppdns.h"

#define DNSFORM_NAME "DNS Malformed"
#define DNSFORM_ELEMENT_NAME "dnsform"

typedef struct
{
    BOOL enabled;
    NSAED_ACTION action;
} NSAED_DNSFORM_CONFIG;

typedef struct
{
    NSAED_PROTECTION_STATS_BASE stats_base;
    N64 pkt_dropped_by_check[NUM_AED_DNS_MALFORMED_STATS];
} NSAED_DNSFORM_STATS;

typedef struct
{
    NSAED_DNSFORM_STATS stats;
} NSAED_DNSFORM_STATE;

/*
 * Short names of DNS malformed checks.
 */
PRIVATE const TEXT check_names[][64] =
{
    "udp_length_too_short",                // 00: UDP length was too short (< 12 bytes)
    "tcp_length_too_short",                // 01: TCP length was too short (< 12 bytes)

    "bad_rcode_query",                     // 02: 'rcode' was not NO_ERROR for a DNS query message
    "bad_rcode_response",                  // 03: 'rcode' was greater than the max value allowed for a DNS response message
    "query_status_all_zero_counts",        // 04: all counts were 0 for 'opcode' = QUERY or STATUS with 'rcode' = NO_ERROR
    "notify_query_count_zero",             // 05: 'query_count' was 0 for 'opcode' = NOTIFY with 'rcode' = NO_ERROR
    "update_query_count_not_one",          // 06: 'query_count' was not 1 for 'opcode' = UPDATE on a DNS request message
    "update_query_count_greater_than_one", // 07: 'query_count' was greater than 1 for 'opcode' = UPDATE on a DNS response message
    "unsupported_opcode",                  // 08: unsupported 'opcode' detected

    "qu_bad_class",                        // 09: invalid 'class' for a question in the 'query' section
    "qu_bad_type",                         // 10: invalid 'type' for a question in the 'query' section
    "qu_premature",                        // 11: not able to validate all questions in a DNS packet

    "rr_bad_ttl",                          // 12: invalid 'ttl' for a resource record
    "rr_bad_class",                        // 13: invalid 'class' for a resource record
    "rr_premature",                        // 14: not able to validate all resource records in a DNS packet
    "rr_len_past_end",                     // 15: 'length' for a resource record exceeded remaining length of message
    "rr_a_len",                            // 16: invalid 'length' for an 'A' resource record
    "rr_a_class",                          // 17: invalid 'class' for an 'A' resource record
    "rr_ns_len",                           // 18: invalid 'length' for an 'NS'/'CNAME'/'MB'/'MG'/'MR'/'PTR' resource record
    "rr_soa_len",                          // 19: invalid 'length' for an 'SOA' resource record
    "rr_wks_len",                          // 20: invalid 'length' for a 'WKS' resource record
    "rr_wks_class",                        // 21: invalid 'class' for a 'WKS' resource record
    "rr_wks_proto",                        // 22: invalid protocol for a 'WKS' resource record
    "rr_hinfo_len",                        // 23: invalid 'length' for an 'HINFO' resource record
    "rr_minfo_len",                        // 24: invalid 'length' for an 'MINFO' resource record
    "rr_mx_len",                           // 25: invalid 'length' for an 'MX' resource record
    "rr_txt_len",                          // 26: invalid 'length' for a 'TXT'/'SPF' resource record
    "rr_aaaa_len",                         // 27: invalid 'length' for an 'AAAA' resource record
    "rr_aaaa_class",                       // 28: invalid 'class' for an 'AAAA' resource record
    "rr_any_opcode",                       // 29: invalid 'opcode' for an 'ANY' resource record
    "rr_opt_name",                         // 30: invalid 'name' byte for an OPT resource record
    "rr_opt_rcode",                        // 31: invalid extended rcode value for an OPT resource record
    "rr_opt_len",                          // 32: invalid 'length' for an OPT resource record

    "qu_name_flags_01",                    // 33: flags are '01' for a 'name' in a query
    "qu_name_flags_10",                    // 34: flags are '10' for a 'name' in a query
    "qu_name_length",                      // 35: exceeded the maximum length of a 'name' in a query
    "qu_name_offset_small",                // 36: offset field is too small for a 'name' in a query
    "qu_name_offset_large",                // 37: offset field is too large for a 'name' in a query

    "rr_name_flags_01",                    // 38: flags are '01' for the top 'name' in a resource record
    "rr_name_flags_10",                    // 39: flags are '10' for the top 'name' in a resource record
    "rr_name_length",                      // 40: exceeded the maximum length of the top 'name' in a resource record
    "rr_name_offset_small",                // 41: offset field is too small for the top 'name' in a resource record
    "rr_name_offset_large",                // 42: offset field is too large for the top 'name' in a resource record

    "add_name_flags_01",                   // 43: flags are '01' for an additional 'name' in a resource record
    "add_name_flags_10",                   // 44: flags are '10' for an additional 'name' in a resource record
    "add_name_length",                     // 45: exceeded the maximum length of an additional 'name' in a resource record
    "add_name_offset_small",               // 46: offset field is too small for an additional 'name' in a resource record
    "add_name_offset_large",               // 47: offset field is too large for an additional 'name' in a resource record
};
_Static_assert(sizeof(check_names)/sizeof(check_names[0]) == NUM_AED_DNS_MALFORMED_STATS);

PRIVATE VOID* dnsform_config_alloc();
PRIVATE VOID dnsform_config_dump(const VOID *prot_config);
PRIVATE VOID dnsform_config_free(VOID *prot);
PRIVATE BOOL dnsform_config_get_enabled(VOID *prot_config);
PRIVATE VOID dnsform_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *json);
PRIVATE VOID dnsform_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE N32 dnsform_get_protection_id();
PRIVATE NSAED_ACTION dnsform_inspect(const VOID *prot_config, VOID *prot_state, XMIB_FLOW_INFO *info);
PRIVATE VOID dnsform_registered(N32 id);
PRIVATE VOID dnsform_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur);
PRIVATE VOID dnsform_stat_dump(const VOID *config, const VOID* state);
PRIVATE VOID dnsform_stat_dump_json(cJSON*, const VOID *config, const VOID* state);
PRIVATE VOID* dnsform_state_alloc();
PRIVATE VOID dnsform_state_free(VOID *prot);

EXPORT const NSAED_PROTECTION dnsform_protection = {
    .name = DNSFORM_ELEMENT_NAME,

    .config_allocator = dnsform_config_alloc,
    .config_deallocator = dnsform_config_free,
    .config_dumper = dnsform_config_dump,
    .config_get_enabled = dnsform_config_get_enabled,
    .config_handler = dnsform_config_handler,
    .config_set_enabled = dnsform_config_set_enabled,
    .get_protection_id = dnsform_get_protection_id,
    .inspector = dnsform_inspect,
    .registered = dnsform_registered,
    .stat_accumulator = dnsform_stat_add,
    .stat_dumper = dnsform_stat_dump,
    .stat_dumper_json = dnsform_stat_dump_json,
    .state_allocator = dnsform_state_alloc,
    .state_deallocator = dnsform_state_free,
};

PRIVATE N32 protection_id = 0;

PRIVATE VOID* dnsform_config_alloc()
{
    return calloc(1, sizeof(NSAED_DNSFORM_CONFIG));
}

PRIVATE VOID dnsform_config_dump(const VOID *c)
{
    const NSAED_DNSFORM_CONFIG* config = c;
    rcon_printf("%s\n  Enabled: %s\n", DNSFORM_NAME,
        IS_PROTECTION_ENABLED(config->enabled));

    if (config->enabled)
    {
        const TEXT *action_str;
        switch (config->action)
        {
            case NSAED_ACTION_DROP:
                action_str = "drop";
                break;
            case NSAED_ACTION_BLOCK:
                action_str = "block";
                break;
            default:
                action_str = "UNKNOWN";
        }
        rcon_printf("  Action: %s\n", action_str);
    }
}

PRIVATE VOID dnsform_config_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    free(prot);
}

PRIVATE BOOL dnsform_config_get_enabled(VOID *prot_config)
{
    NSAED_DNSFORM_CONFIG *config = prot_config;
    return config->enabled;
}

PRIVATE VOID dnsform_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *dnsform_json)
{
    NSAED_DNSFORM_CONFIG *config = prot_config;
    config->action = NSAED_ACTION_DROP;
    cJSON *action_json = cJSON_GetObjectItemCaseSensitive(dnsform_json, "action");
    if (action_json && cJSON_IsString(action_json))
    {
        TEXT* action = cJSON_GetStringValue(action_json);
        if (strcmp(action, "drop") == 0)
        {
            config->action = NSAED_ACTION_DROP;
        }
        else if (strcmp(action, "block") == 0)
        {
            config->action = NSAED_ACTION_BLOCK;
        }
        else
        {
            // Unknown action
            dnsform_config_set_enabled(config, FALSE);
            return;
        }
    }
}

PRIVATE VOID dnsform_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_DNSFORM_CONFIG *config = prot_config;
    config->enabled = state;
}

PRIVATE N32 dnsform_get_protection_id()
{
    return protection_id;
}

PRIVATE NSAED_ACTION dnsform_inspect(const VOID *c, VOID *s, XMIB_FLOW_INFO *info)
{
    const NSAED_DNSFORM_CONFIG *config = c;
    NSAED_DNSFORM_STATE *state = s;

    AED_DNS_INFO_POOL *dns_info = GET_AED_DNS_INFO_POOL(info);

    if (dns_info == NULL)
    {
        return NSAED_ACTION_NONE;
    }

    if (dns_info->val)
    {
        state->stats.stats_base.pkt_dropped++;
        state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
        for (N8 i = 0; i < NUM_AED_DNS_MALFORMED_STATS; i++) {
            /* Note: a single packet can match multiple checks. Such packet will count for
             * multiple pkt_dropped_by_check stats, so the sum of all pkt_dropped_by_check
             * stats may be greater than the total number of dropped packets.
             *
             * This behavior is intentional, because it is very useful for debugging -
             * packets that match multiple checks are some of hardest to debug, and
             * recording every check they matched makes debugging easier.
             */
            if (dns_info->val & (1ULL << i)) {
                state->stats.pkt_dropped_by_check[i]++;
            }
        }
        return config->action;
    }

    return NSAED_ACTION_NONE;
}

PRIVATE VOID dnsform_registered(N32 id)
{
    protection_id = id;
}

PRIVATE VOID dnsform_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur)
{
    NSAED_DNSFORM_STATE* total = state_total;
    const NSAED_DNSFORM_STATE* cur = state_cur;
    total->stats.stats_base.pkt_dropped += cur->stats.stats_base.pkt_dropped;
    total->stats.stats_base.l3_byte_dropped += cur->stats.stats_base.l3_byte_dropped;
    for (N8 i = 0; i < NUM_AED_DNS_MALFORMED_STATS; i++) {
        total->stats.pkt_dropped_by_check[i] += cur->stats.pkt_dropped_by_check[i];
    }
}

PRIVATE VOID dnsform_stat_dump(const VOID *c, const VOID *s)
{
    const NSAED_DNSFORM_STATE* state = s;
    if (state)
    {
        rcon_printf("Packets dropped by %s: %llu\n",
                DNSFORM_NAME, state->stats.stats_base.pkt_dropped);
        rcon_printf("L3 Bytes dropped by %s: %llu\n",
                DNSFORM_NAME, state->stats.stats_base.l3_byte_dropped);
        for (N8 i = 0; i < NUM_AED_DNS_MALFORMED_STATS; i++) {
            if (state->stats.pkt_dropped_by_check[i]) {
                rcon_printf("Packets dropped by %s (%s): %llu\n",
                    DNSFORM_NAME, check_names[i], state->stats.pkt_dropped_by_check[i]);
            }
        }
    }
}

PRIVATE VOID dnsform_stat_dump_json(cJSON* cj, const VOID *c, const VOID *s)
{
    const NSAED_DNSFORM_STATE* state = s;
    const NSAED_DNSFORM_STATS* stats = &state->stats;

    cJSON* dnsform = cJSON_AddObjectToObject(cj, DNSFORM_ELEMENT_NAME);
    cJSON_AddNumberToObject(dnsform, "packets_dropped", stats->stats_base.pkt_dropped);
    cJSON_AddNumberToObject(dnsform, "l3_bytes_dropped", stats->stats_base.l3_byte_dropped);

    cJSON* dropped_by_check = cJSON_AddObjectToObject(dnsform, "packets_dropped_by_check");
    for (N8 i = 0; i < NUM_AED_DNS_MALFORMED_STATS; i++) {
        cJSON_AddNumberToObject(dropped_by_check,
            check_names[i], stats->pkt_dropped_by_check[i]);
    }
}

PRIVATE VOID* dnsform_state_alloc()
{
    return calloc(1, sizeof(NSAED_DNSFORM_STATE));
}

PRIVATE VOID dnsform_state_free(VOID *prot)
{
    free(prot);
}
#endif // ISNG_BASED_AED
#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2024                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
                                                                        *
************************************************************************/

#include <string.h>

#include "eventlog.h"
#include "aed/aed.h"
#include "xmibip.h"
#include "aed/foundation/containers.h"
#include "aed/foundation/hash_functions.h"
#include "aed/foundation/pool.h"
#include "aed/tokenbucket.h"
#include "aed/srcstate.h"
#include "aed/cJSON.h"
#include "rconapi.h"
#include "xmibflow.h"

#define DNSRL_NAME "DNS Rate Limiting"

struct XMIB_FLOW_INFO;
struct NSAED_ROOT;
struct NSAED_STATS;

typedef struct
{
    BOOL enabled;
    N64 rate;
    NSAED_ACTION action; // NSAED_ACTION_DROP or NSAED_ACTION_BLOCK
} NSAED_DNSRL_CONFIG;

typedef struct
{
    NSAED_PROTECTION_STATS_BASE stats_base;
} NSAED_DNSRL_STATS;

typedef struct
{
    NSAED_DNSRL_STATS stats;
} NSAED_DNSRL_STATE;

#define DNSRL_ELEMENT_NAME "dns_rate_limiting"
#define DNSRL_SRCSTATE_BLOCKSIZE (sizeof(TOKENBUCKET))

PRIVATE VOID* dnsrl_config_alloc();
PRIVATE VOID dnsrl_config_free(VOID *prot);
PRIVATE VOID dnsrl_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *json);
PRIVATE BOOL dnsrl_config_get_enabled(VOID *prot_config);
PRIVATE VOID dnsrl_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE VOID dnsrl_config_dump(const VOID *prot_config);
PRIVATE NSAED_ACTION dnsrl_inspect(const VOID *prot_config, VOID *prot_state, struct XMIB_FLOW_INFO *info);
PRIVATE VOID dnsrl_stat_dump(const VOID *config, const VOID *state);
PRIVATE VOID dnsrl_stat_dump_json(cJSON* cj, const VOID *config, const VOID *state);
PRIVATE VOID dnsrl_stat_add(const VOID *config, VOID* state_total, const VOID* state_cur);
PRIVATE VOID* dnsrl_state_alloc();
PRIVATE VOID dnsrl_state_free(VOID *prot);
PRIVATE VOID dnsrl_registered(N32 id);
PRIVATE N32 dnsrl_get_protection_id();

EXPORT const NSAED_PROTECTION dnsrl_protection = {
    .name = DNSRL_ELEMENT_NAME,
    .features = NSAED_FEATURE_SRCSTATE,
    .srcstate_blocksize = DNSRL_SRCSTATE_BLOCKSIZE,

    .config_allocator = dnsrl_config_alloc,
    .config_deallocator = dnsrl_config_free,
    .config_handler = dnsrl_config_handler,
    .config_get_enabled = dnsrl_config_get_enabled,
    .config_set_enabled = dnsrl_config_set_enabled,
    .config_dumper = dnsrl_config_dump,
    .inspector = dnsrl_inspect,
    .stat_dumper = dnsrl_stat_dump,
    .stat_dumper_json = dnsrl_stat_dump_json,
    .stat_accumulator = dnsrl_stat_add,
    .state_allocator = dnsrl_state_alloc,
    .state_deallocator = dnsrl_state_free,
    .registered = dnsrl_registered,
    .get_protection_id = dnsrl_get_protection_id,
};

PRIVATE N32 protection_id = 0;

PRIVATE VOID* dnsrl_config_alloc()
{
    return calloc(1, sizeof(NSAED_DNSRL_CONFIG));
}

PRIVATE VOID dnsrl_config_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    free(prot);
}

PRIVATE VOID dnsrl_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *dnsrl_json)
{
    NSAED_DNSRL_CONFIG *config = prot_config;
    TEXT *action;
    cJSON *rate_json = cJSON_GetObjectItemCaseSensitive(dnsrl_json, "rate");
    cJSON *action_json = cJSON_GetObjectItemCaseSensitive(dnsrl_json, "action");

    config->rate = 0;
    config->action = NSAED_ACTION_DROP;

    if (rate_json && cJSON_IsNumber(rate_json))
    {
        config->rate = (INT)cJSON_GetNumberValue(rate_json);
    }
    if (action_json && cJSON_IsString(action_json))
    {
        action = cJSON_GetStringValue(action_json);
        if (strcmp(action, "drop") == 0)
        {
            config->action = NSAED_ACTION_DROP;
        }
        else if (strcmp(action, "block") == 0)
        {
            config->action = NSAED_ACTION_BLOCK;
        }
        else
        {
            // Unknown action
            dnsrl_config_set_enabled(config, FALSE);
            return;
        }
    }

    if (config->rate == 0) dnsrl_config_set_enabled(config, FALSE);
}

PRIVATE BOOL dnsrl_config_get_enabled(VOID *prot_config)
{
    NSAED_DNSRL_CONFIG *config = prot_config;
    return config->enabled;
}

PRIVATE VOID dnsrl_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_DNSRL_CONFIG *config = prot_config;
    config->enabled = state;
}

PRIVATE VOID dnsrl_config_dump(const VOID *c)
{
    const NSAED_DNSRL_CONFIG *config = c;
    rcon_printf("%s\n  Enabled: %s\n", DNSRL_NAME,
        IS_PROTECTION_ENABLED(config->enabled));
    if (config->enabled)
    {
        rcon_printf("  PPS: %llu\n", config->rate);

        const TEXT *action_str;
        switch (config->action)
        {
            case NSAED_ACTION_DROP:
                action_str = "drop";
                break;
            case NSAED_ACTION_BLOCK:
                action_str = "block";
                break;
            default:
                action_str = "UNKNOWN";
        }
        rcon_printf("  Action: %s\n", action_str);
    }
}

PRIVATE NSAED_ACTION dnsrl_inspect(const VOID *c, VOID* s, XMIB_FLOW_INFO *info)
{
    const NSAED_DNSRL_CONFIG *config = c;
    NSAED_DNSRL_STATE *state = s;
    NSAED_ACTION action = NSAED_ACTION_NONE;
    TOKENBUCKET *tb;

    // Only filter DNS.
    if (info->ip_parse_info.src_port != 53 && info->ip_parse_info.dest_port != 53)
    {
        return action;
    }

    switch (info->ip_parse_info.ip_version)
    {
        case 4:
        case 6:
            break;
        default:
            // Not IP? Don't inspect.
            return action;
    }

    if (!info->srcstate)
    {
        log_event(BOTH_LOG, DNSRL_NAME ": Missing srcstate");
        return action;
    }
    tb = srcstate_get_protection(info->srcstate, dnsrl_get_protection_id());

    tokenbucket_fill(tb, info->frame_time_us, config->rate, config->rate);
    if (tokenbucket_consume(tb, 1))
    {
        // Not enough tokens: drop/block the packet.
        action = config->action;
        state->stats.stats_base.pkt_dropped++;
        state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
    }

    return action;
}

PRIVATE VOID dnsrl_stat_dump(const VOID *c, const VOID *s)
{
    const NSAED_DNSRL_STATE* state = s;
    if (state)
    {
        rcon_printf("Packets dropped by %s: %llu\n",
                DNSRL_NAME, state->stats.stats_base.pkt_dropped);
        rcon_printf("L3 Bytes dropped by %s: %llu\n",
                DNSRL_NAME, state->stats.stats_base.l3_byte_dropped);
    }
}

PRIVATE VOID dnsrl_stat_dump_json(cJSON* cj, const VOID *c, const VOID *s)
{
    const NSAED_DNSRL_STATE* state = s;
    const NSAED_DNSRL_STATS* stats = &state->stats;

    cJSON* dnsrl = cJSON_AddObjectToObject(cj, "dns_rate_limiting");
    cJSON_AddNumberToObject(dnsrl, "packets_dropped", stats->stats_base.pkt_dropped);
    cJSON_AddNumberToObject(dnsrl, "l3_bytes_dropped", stats->stats_base.l3_byte_dropped);
}

PRIVATE VOID dnsrl_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur)
{
    NSAED_DNSRL_STATE* total = state_total;
    const NSAED_DNSRL_STATE* cur = state_cur;
    total->stats.stats_base.pkt_dropped += cur->stats.stats_base.pkt_dropped;
    total->stats.stats_base.l3_byte_dropped += cur->stats.stats_base.l3_byte_dropped;
}

PRIVATE VOID* dnsrl_state_alloc()
{
    return calloc(1, sizeof(NSAED_DNSRL_STATE));
}

PRIVATE VOID dnsrl_state_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    free(prot);
}

PRIVATE VOID dnsrl_registered(N32 id)
{
    protection_id = id;
}

PRIVATE N32 dnsrl_get_protection_id()
{
    return protection_id;
}

#endif // ISNG_BASED_AED
#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2024                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
                                                                        *
************************************************************************/

#include <string.h>

#include "eventlog.h"
#include "aed/aed.h"
#include "aed/action.h"
#include "aed/cJSON.h"
#include "aed/arf/api.h"

#define FCAP_FILTERING_NAME "FCAP Filtering"
#define FCAP_FILTERING_ELEMENT_NAME "fcap_filtering"
#define KEY_ARF_ID "arf_id"
#define MAX_TAG_IDS 32

typedef struct
{
    BOOL enabled;
    TEXT *arf_id;
    arf_t *arf;
} NSAED_FCAP_FILTERING_CONFIG;

typedef struct
{
    NSAED_PROTECTION_STATS_BASE stats_base;
    N64 pkt_forwarded;
    // TODO: We will fix the other members in the future PRs
    N64 per_tag_pkt_dropped[MAX_TAG_IDS];
    N64 per_tag_l3_byte_dropped[MAX_TAG_IDS];
    N64 per_tag_pkt_forwarded[MAX_TAG_IDS];
} NSAED_FCAP_FILTERING_STATS;

typedef struct
{
    NSAED_FCAP_FILTERING_STATS stats;
    arf_t *arf;
    arf_handle_t *arf_handle;
} NSAED_FCAP_FILTERING_STATE;

PRIVATE VOID* fcap_filtering_config_alloc();
PRIVATE VOID fcap_filtering_config_free(VOID *prot);
PRIVATE VOID fcap_filtering_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *json);
PRIVATE BOOL fcap_filtering_config_get_enabled(VOID *prot_config);
PRIVATE VOID fcap_filtering_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE VOID fcap_filtering_config_dump(const VOID *prot_config);
PRIVATE VOID fcap_filtering_config_loaded(const VOID *prot_config, VOID *prot_state, VOID *shared_state);
PRIVATE NSAED_ACTION fcap_filtering_inspect(const VOID *prot_config, VOID *prot_state, struct XMIB_FLOW_INFO *info);
PRIVATE VOID fcap_filtering_stat_dump(const VOID *config, const VOID *state);
PRIVATE VOID fcap_filtering_stat_dump_json(cJSON* cj, const VOID *config, const VOID *state);
PRIVATE VOID fcap_filtering_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur);
PRIVATE VOID* fcap_filtering_state_alloc();
PRIVATE VOID fcap_filtering_state_free(VOID *prot);
PRIVATE VOID fcap_filtering_registered(N32 id);
PRIVATE N32 fcap_filtering_get_protection_id();

EXPORT const NSAED_PROTECTION fcap_filtering_protection = {
    .name = FCAP_FILTERING_ELEMENT_NAME,

    .config_allocator = fcap_filtering_config_alloc,
    .config_deallocator = fcap_filtering_config_free,
    .config_handler = fcap_filtering_config_handler,
    .config_get_enabled = fcap_filtering_config_get_enabled,
    .config_set_enabled = fcap_filtering_config_set_enabled,
    .config_dumper = fcap_filtering_config_dump,
    .config_loaded = fcap_filtering_config_loaded,
    .inspector = fcap_filtering_inspect,
    .stat_dumper = fcap_filtering_stat_dump,
    .stat_dumper_json = fcap_filtering_stat_dump_json,
    .stat_accumulator = fcap_filtering_stat_add,
    .state_allocator = fcap_filtering_state_alloc,
    .state_deallocator = fcap_filtering_state_free,
    .registered = fcap_filtering_registered,
    .get_protection_id = fcap_filtering_get_protection_id,
};

PRIVATE N32 protection_id = 0;

PRIVATE VOID* fcap_filtering_config_alloc()
{
    return calloc(1, sizeof(NSAED_FCAP_FILTERING_CONFIG));
}

PRIVATE VOID fcap_filtering_config_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    NSAED_FCAP_FILTERING_CONFIG *config = prot;
    if (config->arf != NULL)
    {
        arf_release(&config->arf);
    }
    if (config->arf_id != NULL)
    {
        free(config->arf_id);
    }
    free(config);
}

PRIVATE VOID fcap_filtering_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *fcap_filtering_json)
{
    NSAED_FCAP_FILTERING_CONFIG *config = prot_config;
    cJSON *arf_id_json = cJSON_GetObjectItemCaseSensitive(fcap_filtering_json, KEY_ARF_ID);
    if (arf_id_json && cJSON_IsString(arf_id_json))
    {
        TEXT *arf_id = cJSON_GetStringValue(arf_id_json);
        config->arf = arf_get(arf_id, pg_config_get_ip_version(pg_config));
        if (config->arf != NULL)
        {
            log_event(DBG_LOG, "#NSAED-CFG %s loaded \"%s\"", FCAP_FILTERING_NAME, arf_id);
            // save it for config dump
            config->arf_id = strdup(arf_id);
            return;
        }
        else
        {
            log_event(BOTH_LOG, "#NSAED-CFG %s load \"%s\" failed", FCAP_FILTERING_NAME, arf_id);
        }
    }
    else
    {
        log_event(BOTH_LOG, "#NSAED-CFG invalid %s config, \"%s\" is not "
                "specified or not a string", FCAP_FILTERING_NAME, KEY_ARF_ID);
    }
    fcap_filtering_config_set_enabled(config, FALSE);
}

PRIVATE BOOL fcap_filtering_config_get_enabled(VOID *prot_config)
{
    NSAED_FCAP_FILTERING_CONFIG *config = prot_config;
    return config->enabled;
}

PRIVATE VOID fcap_filtering_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_FCAP_FILTERING_CONFIG *config = prot_config;
    config->enabled = state;
}

PRIVATE VOID fcap_filtering_config_dump(const VOID *prot_config)
{
    const NSAED_FCAP_FILTERING_CONFIG* config = prot_config;
    rcon_printf("%s\n  Enabled: %s\n", FCAP_FILTERING_NAME,
            IS_PROTECTION_ENABLED(config->enabled));
    if (config->enabled)
    {
        rcon_printf("  ARF ID: %s\n", config->arf_id);
    }
}

PRIVATE VOID fcap_filtering_config_loaded(const VOID *prot_config, VOID *prot_state, VOID *sh)
{
    const NSAED_FCAP_FILTERING_CONFIG *config = prot_config;
    NSAED_FCAP_FILTERING_STATE *state = prot_state;

    if (config->arf != state->arf)
    {
        // arf has changed, release the current arf handle
        if (state->arf_handle != NULL)
        {
            arf_release_handle(&state->arf_handle);
            state->arf = NULL;
        }

        if (config->arf != NULL)
        {
            state->arf_handle = arf_get_handle(config->arf);
            if (state->arf_handle != NULL)
            {
                // save the arf pointer for next config state syncing
                state->arf = config->arf;
            }
            else
            {
                log_event(BOTH_LOG, "#NSAED-CFG-STATE-SYNCING %s create arf "
                        "handle for \"%s\" failed", FCAP_FILTERING_NAME, config->arf_id);
            }
        }
    }
}

PRIVATE NSAED_ACTION fcap_filtering_inspect(const VOID *, VOID *prot_state, struct XMIB_FLOW_INFO *info)
{
    NSAED_FCAP_FILTERING_STATE *state = prot_state;
    NSAED_ACTION action = NSAED_ACTION_NONE;
    N32 tag_id;

    if (state->arf_handle != NULL)
    {
        action = arf_match_flow_info(state->arf_handle, info, &tag_id);
        if (tag_id >= MAX_TAG_IDS)
        {
            log_event(BOTH_LOG, "#NSAED-INSPECT %s: Invalid TAG ID - %u", FCAP_FILTERING_NAME, tag_id);
            return NSAED_ACTION_NONE;
        }

        switch (action)
        {
            case NSAED_ACTION_DROP:
                state->stats.stats_base.pkt_dropped++;
                state->stats.per_tag_pkt_dropped[tag_id]++;
                state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
                state->stats.per_tag_l3_byte_dropped[tag_id] += L3_BYTES(info);
                break;
            case NSAED_ACTION_FORWARD:
                state->stats.pkt_forwarded++;
                state->stats.per_tag_pkt_forwarded[tag_id]++;
                break;
            default:
                break;
        }
    }

    return action;
}

PRIVATE VOID fcap_filtering_stat_dump(const VOID *c, const VOID *s)
{
    const NSAED_FCAP_FILTERING_STATE* state = s;
    if (state)
    {
        // Dumping whole protection stats
        rcon_printf("Packets dropped by %s: %llu\n",
                FCAP_FILTERING_NAME, state->stats.stats_base.pkt_dropped);
        rcon_printf("L3 Bytes dropped by %s: %llu\n",
                FCAP_FILTERING_NAME, state->stats.stats_base.l3_byte_dropped);
        rcon_printf("Packets forwarded by %s: %llu\n",
                FCAP_FILTERING_NAME, state->stats.pkt_forwarded);

        // Dumping per tag stats
        for (N32 tag_id = 0; tag_id < MAX_TAG_IDS; ++tag_id)
        {
            N64 pkts_dropped = state->stats.per_tag_pkt_dropped[tag_id];
            N64 l3_bytes_dropped = state->stats.per_tag_l3_byte_dropped[tag_id];
            N64 pkts_forwarded = state->stats.per_tag_pkt_forwarded[tag_id];

            // Dump tag stats if either of the counters is incremented
            if (pkts_dropped || pkts_forwarded)
            {
                rcon_printf("Packets dropped by %s (id: %u): %llu\n",
                        FCAP_FILTERING_NAME, tag_id, pkts_dropped);
                rcon_printf("L3 Bytes dropped by %s (id: %u): %llu\n",
                        FCAP_FILTERING_NAME, tag_id, l3_bytes_dropped);
                rcon_printf("Packets forwarded by %s (id: %d): %llu\n",
                        FCAP_FILTERING_NAME, tag_id, pkts_forwarded);
            }
        }
    }
}

PRIVATE VOID fcap_filtering_stat_dump_json(cJSON* cj, const VOID *c, const VOID *s)
{
    const NSAED_FCAP_FILTERING_STATE* state = s;
    const NSAED_FCAP_FILTERING_STATS* stats = &state->stats;

    cJSON* fcap_filtering = cJSON_AddObjectToObject(cj, FCAP_FILTERING_ELEMENT_NAME);

    // whole protection stats
    cJSON_AddNumberToObject(fcap_filtering, "packets_dropped", stats->stats_base.pkt_dropped);
    cJSON_AddNumberToObject(fcap_filtering, "l3_bytes_dropped", stats->stats_base.l3_byte_dropped);
    cJSON_AddNumberToObject(fcap_filtering, "packets_forwarded", stats->pkt_forwarded);

    // per tag stats
    cJSON* tags = cJSON_AddObjectToObject(fcap_filtering, "tags");
    for (N32 tag_id = 0; tag_id < MAX_TAG_IDS; ++tag_id)
    {
        char tag_str[64];
        snprintf(tag_str, sizeof(tag_str), "%d", tag_id);
        cJSON* tag = cJSON_AddObjectToObject(tags, tag_str);
        cJSON_AddNumberToObject(tag, "packets_dropped", stats->per_tag_pkt_dropped[tag_id]);
        cJSON_AddNumberToObject(tag, "l3_bytes_dropped", stats->per_tag_l3_byte_dropped[tag_id]);
        cJSON_AddNumberToObject(tag, "packets_forwarded", stats->per_tag_pkt_forwarded[tag_id]);
    }
}

PRIVATE VOID fcap_filtering_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur)
{
    NSAED_FCAP_FILTERING_STATE* total = state_total;
    const NSAED_FCAP_FILTERING_STATE* cur = state_cur;
    total->stats.stats_base.pkt_dropped += cur->stats.stats_base.pkt_dropped;
    total->stats.stats_base.l3_byte_dropped += cur->stats.stats_base.l3_byte_dropped;
    total->stats.pkt_forwarded += cur->stats.pkt_forwarded;

    for (N32 tag_id = 0; tag_id < MAX_TAG_IDS; ++tag_id)
    {
        total->stats.per_tag_pkt_dropped[tag_id] += cur->stats.per_tag_pkt_dropped[tag_id];
        total->stats.per_tag_l3_byte_dropped[tag_id] += cur->stats.per_tag_l3_byte_dropped[tag_id];
        total->stats.per_tag_pkt_forwarded[tag_id] += cur->stats.per_tag_pkt_forwarded[tag_id];
    }
}

PRIVATE VOID* fcap_filtering_state_alloc()
{
    return calloc(1, sizeof(NSAED_FCAP_FILTERING_STATE));
}

PRIVATE VOID fcap_filtering_state_free(VOID *prot)
{
    NSAED_FCAP_FILTERING_STATE *state = prot;
    // DO NOT destroy or release the arf_t, it's owned by the config thread
    // and is only for determining if a new arf handled is needed.
    if (state->arf_handle != NULL)
    {
        arf_release_handle(&state->arf_handle);
    }
    free(state);
}

PRIVATE VOID fcap_filtering_registered(N32 id)
{
    protection_id = id;
}

PRIVATE N32 fcap_filtering_get_protection_id()
{
    return protection_id;
}

#endif // ISNG_BASED_AED

#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2024                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
                                                                        *
************************************************************************/
#include <netinet/in.h>
#include <string.h>

#include "eventlog.h"
#include "aed/aed.h"
#include "dns.h"
#include "xmibip.h"
#include "aed/cJSON.h"
#include "aed/foundation/vector.h"
#include "aed/tokenbucket.h"
#include "rconapi.h"
#include "xmibflow.h"

#define GEOIPFILTER_NAME "IP Location Filtering"

typedef enum {
    NSAED_GEOIPFILTER_ACTION_NONE,
    NSAED_GEOIPFILTER_ACTION_DROP,
} NSAED_GEOIPFILTER_ACTION;

typedef struct
{
    NSAED_GEOIPFILTER_ACTION action;
} NSAED_GEOIPFILTER_COUNTRY;

typedef struct
{
    BOOL enabled;
    const geoip_t *geoip;
    NSAED_GEOIPFILTER_COUNTRY *countries;
    region_size_t nregions;
} NSAED_GEOIPFILTER_CONFIG;

typedef struct
{
    NSAED_PROTECTION_STATS_BASE stats_base;
} NSAED_GEOIPFILTER_STATS;

typedef struct
{
    N64 pkt_dropped;
    N64 l3_byte_dropped;
} NSAED_GEOIPFILTER_COUNTRY_STATS;

typedef struct
{
    NSAED_GEOIPFILTER_STATS stats;
    NSAED_GEOIPFILTER_COUNTRY_STATS *country_stats;
    region_size_t nregions;
} NSAED_GEOIPFILTER_STATE;

PRIVATE VOID* geoipfilter_config_alloc();
PRIVATE VOID geoipfilter_config_free(VOID *prot);
PRIVATE VOID* geoipfilter_state_alloc();
PRIVATE VOID geoipfilter_state_free(VOID *prot);
PRIVATE VOID geoipfilter_stat_dump(const VOID *c, const VOID *s);
PRIVATE VOID geoipfilter_stat_dump_json(cJSON *cj, const VOID *c, const VOID *s);
PRIVATE VOID geoipfilter_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur);
PRIVATE NSAED_ACTION geoipfilter_inspect(const VOID *prot_config, VOID *prot_state, struct XMIB_FLOW_INFO *info);
PRIVATE VOID geoipfilter_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *geoipfilter_json);
PRIVATE BOOL geoipfilter_config_get_enabled(VOID *prot_config);
PRIVATE VOID geoipfilter_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE VOID geoipfilter_config_dump(const VOID *c);
PRIVATE VOID geoipfilter_config_loaded(const VOID *prot_config, VOID *prot_state, VOID *shared_state);

PRIVATE VOID geoipfilter_registered(N32 id);
PRIVATE N32 geoipfilter_get_protection_id();

EXPORT const NSAED_PROTECTION geoipfilter_protection = {
    .name = "geoipfilter",
    .features = NSAED_FEATURE_GEOIP,

    .config_allocator = geoipfilter_config_alloc,
    .config_deallocator = geoipfilter_config_free,
    .config_handler = geoipfilter_config_handler,
    .config_get_enabled = geoipfilter_config_get_enabled,
    .config_set_enabled = geoipfilter_config_set_enabled,
    .config_dumper = geoipfilter_config_dump,
    .config_loaded = geoipfilter_config_loaded,
    .state_allocator = geoipfilter_state_alloc,
    .state_deallocator = geoipfilter_state_free,
    .inspector = geoipfilter_inspect,
    .stat_dumper = geoipfilter_stat_dump,
    .stat_dumper_json = geoipfilter_stat_dump_json,
    .stat_accumulator = geoipfilter_stat_add,
    .registered = geoipfilter_registered,
    .get_protection_id = geoipfilter_get_protection_id,
};


PRIVATE N32 protection_id = 0;

PRIVATE VOID geoipfilter_stat_dump(const VOID *c, const VOID* s)
{
    const NSAED_GEOIPFILTER_STATE *state = s;
    const NSAED_GEOIPFILTER_CONFIG *config = c;
    if (state)
    {
        rcon_printf("Packets dropped by %s: %llu\n",
                GEOIPFILTER_NAME, state->stats.stats_base.pkt_dropped);
        rcon_printf("L3 Bytes dropped by %s: %llu\n",
                GEOIPFILTER_NAME, state->stats.stats_base.l3_byte_dropped);
        for (int i = 0; i < config->nregions; ++i) {
            if (config->countries[i].action == NSAED_GEOIPFILTER_ACTION_DROP) {
                rcon_printf("    Packets dropped by %s[%s]: %llu\n",
                        GEOIPFILTER_NAME, geoip_region_id_to_str(config->geoip, i),
                        state->country_stats[i].pkt_dropped);
                rcon_printf("    L3 Bytes dropped by %s[%s]: %llu\n",
                        GEOIPFILTER_NAME, geoip_region_id_to_str(config->geoip, i),
                        state->country_stats[i].l3_byte_dropped);
            }
        }
    }
}

PRIVATE VOID geoipfilter_stat_dump_json(cJSON *cj, const VOID *c, const VOID *s)
{
    const NSAED_GEOIPFILTER_STATE* state = s;
    const NSAED_GEOIPFILTER_CONFIG* config = c;
    const NSAED_GEOIPFILTER_STATS* stats = &state->stats;

    cJSON* geoipfilter = cJSON_AddObjectToObject(cj, geoipfilter_protection.name);
    cJSON_AddNumberToObject(geoipfilter, "packets_dropped", stats->stats_base.pkt_dropped);
    cJSON_AddNumberToObject(geoipfilter, "l3_bytes_dropped", stats->stats_base.l3_byte_dropped);

    // per region stats
    cJSON* regions = cJSON_AddObjectToObject(geoipfilter, "regions");
    for (int i = 1; i < config->nregions; ++i)
    {
        if (config->countries[i].action == NSAED_GEOIPFILTER_ACTION_DROP) {
            cJSON* region = cJSON_AddObjectToObject(regions, geoip_region_id_to_str(config->geoip, i));
            cJSON_AddNumberToObject(region, "packets_dropped", state->country_stats[i].pkt_dropped);
            cJSON_AddNumberToObject(region, "l3_bytes_dropped", state->country_stats[i].l3_byte_dropped);
        }
    }
}

PRIVATE VOID geoipfilter_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur)
{
    NSAED_GEOIPFILTER_STATE* total = state_total;
    const NSAED_GEOIPFILTER_STATE* cur = state_cur;
    const NSAED_GEOIPFILTER_CONFIG* cfg = config;

    if (total->country_stats == NULL)
    {
        total->country_stats = calloc(cfg->nregions, sizeof(NSAED_GEOIPFILTER_COUNTRY_STATS));
    }

    total->stats.stats_base.pkt_dropped += cur->stats.stats_base.pkt_dropped;
    total->stats.stats_base.l3_byte_dropped += cur->stats.stats_base.l3_byte_dropped;
    for (int i = 0; i < cfg->nregions; ++i)
    {
        total->country_stats[i].pkt_dropped += cur->country_stats[i].pkt_dropped;
        total->country_stats[i].l3_byte_dropped += cur->country_stats[i].l3_byte_dropped;
    }
}

PRIVATE NSAED_ACTION geoipfilter_inspect(const VOID *c, VOID* s, XMIB_FLOW_INFO *info)
{
    const NSAED_GEOIPFILTER_CONFIG *config = c;
    NSAED_GEOIPFILTER_STATE *state = s;

    // We only handle GEOIP for ip Version 4
    if (info->ip_parse_info.ip_version != 4)
    {
        return NSAED_ACTION_NONE;
    }

    if (config->countries[info->geoip_region].action == NSAED_GEOIPFILTER_ACTION_DROP)
    {
        state->stats.stats_base.pkt_dropped++;
        state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
        state->country_stats[info->geoip_region].pkt_dropped++;
        state->country_stats[info->geoip_region].l3_byte_dropped += L3_BYTES(info);
        return NSAED_ACTION_DROP;
    }
    return NSAED_ACTION_NONE;
}



PRIVATE VOID geoipfilter_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *geoipfilter_json)
{
    NSAED_GEOIPFILTER_CONFIG *config = prot_config;

    cJSON *countries_json = cJSON_GetObjectItemCaseSensitive(geoipfilter_json, "countries");

    config->geoip = pg_config_get_geoip(pg_config);

    region_size_t num_regions = geoip_nregions(config->geoip);
    config->countries = calloc(num_regions, sizeof(NSAED_GEOIPFILTER_COUNTRY));
    config->nregions = num_regions;

    if (config->countries && countries_json && cJSON_IsArray(countries_json))
    {
        for (int i = 0; i < cJSON_GetArraySize(countries_json); ++i)
        {
            cJSON *cc_json = cJSON_GetArrayItem(countries_json, i);
            if (cc_json && cJSON_IsString(cc_json))
            {
                region_size_t region_id = geoip_region_str_to_id(config->geoip, cJSON_GetStringValue(cc_json));
                config->countries[region_id].action = NSAED_GEOIPFILTER_ACTION_DROP;
            }

        }
    }
}

PRIVATE BOOL geoipfilter_config_get_enabled(VOID *prot_config)
{
    NSAED_GEOIPFILTER_CONFIG *config = prot_config;
    return config->enabled;
}

PRIVATE VOID geoipfilter_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_GEOIPFILTER_CONFIG *config = prot_config;
    config->enabled = state;
}

PRIVATE VOID geoipfilter_config_dump(const VOID *c)
{
    const NSAED_GEOIPFILTER_CONFIG *config = c;
    rcon_printf("%s\n  Enabled: %s\n", GEOIPFILTER_NAME,
        IS_PROTECTION_ENABLED(config->enabled));
    if (config->enabled)
    {
        if (config->countries != NULL)
        {
            rcon_printf("  Countries:");
            for (int i = 0; i < config->nregions; ++i)
            {
                if (config->countries[i].action == NSAED_GEOIPFILTER_ACTION_DROP)
                {
                    rcon_printf(" %s", geoip_region_id_to_str(config->geoip, i));
                }
            }
            rcon_printf("\n");
        }
    }
}

PRIVATE VOID geoipfilter_config_loaded(const VOID *c, VOID *s, VOID *sh)
{
    const NSAED_GEOIPFILTER_CONFIG *config = c;
    NSAED_GEOIPFILTER_STATE *state = s;

    /* If the number of geoip regions has changed since the last time a config has been loaded
     * we need to deallocate and then reallocate the per region stats, so that the arrays stay
     * in synch. This will have the side effect of clearing the per region stats if the geoip
     * database changes.
     */
    if (config->nregions != state->nregions)
    {
        free(state->country_stats);
        state->country_stats = calloc(config->nregions, sizeof(NSAED_GEOIPFILTER_COUNTRY_STATS));
        state->nregions = config->nregions;
    }
}

PRIVATE VOID* geoipfilter_config_alloc()
{
    return calloc(1, sizeof(NSAED_GEOIPFILTER_CONFIG));
}

PRIVATE VOID geoipfilter_config_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    NSAED_GEOIPFILTER_CONFIG *config = (NSAED_GEOIPFILTER_CONFIG *)prot;
    free(config->countries);
    free(config);
}

PRIVATE VOID* geoipfilter_state_alloc()
{
    NSAED_GEOIPFILTER_STATE* prot = calloc(1, sizeof(NSAED_GEOIPFILTER_STATE));
    if (prot == NULL)
    {
        return NULL;
    }
    return prot;
}

PRIVATE VOID geoipfilter_state_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    NSAED_GEOIPFILTER_STATE *protection = (NSAED_GEOIPFILTER_STATE *)prot;
    free(protection->country_stats);
    free(protection);
}

PRIVATE VOID geoipfilter_registered(N32 id)
{
    protection_id = id;
}

PRIVATE N32 geoipfilter_get_protection_id()
{
    return protection_id;
}

#endif //ISNG_BASED_AED
#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2024                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
                                                                        *
************************************************************************/
#include <netinet/in.h>
#include <string.h>

#include "eventlog.h"
#include "aed/aed.h"
#include "dns.h"
#include "xmibip.h"
#include "aed/cJSON.h"
#include "aed/foundation/vector.h"
#include "aed/tokenshare.h"
#include "rconapi.h"
#include "xmibflow.h"

#define GEOIPRATE_NAME "IP Location Policing"

#define ACTION2STR(x) (x == NSAED_GEOIPRATE_ACTION_RATELIMIT ? "rate_limit" : x == NSAED_GEOIPRATE_ACTION_DROP ? "drop" : "skip")

#define GEOIPRATE_NUMREGIONS 300

typedef enum {
    NSAED_GEOIPRATE_ACTION_NONE,
    NSAED_GEOIPRATE_ACTION_DROP,
    NSAED_GEOIPRATE_ACTION_RATELIMIT,
} NSAED_GEOIPRATE_ACTION;

typedef struct
{
    region_size_t region_id;
    NSAED_GEOIPRATE_ACTION action;
    N32  max_pps;
    N32  max_bps;
} NSAED_GEOIPRATE_COUNTRY_CONFIG;

typedef struct {
    tokenshare pps_limiter;
    tokenshare bps_limiter;
} NSAED_GEOIPRATE_LIMITER;

typedef struct {
    NSAED_GEOIPRATE_LIMITER *limiter;
} NSAED_GEOIPRATE_STATE_SHARED;

typedef struct
{
    BOOL enabled;
    const geoip_t *geoip;
    vector_t *countries;
    NSAED_GEOIPRATE_COUNTRY_CONFIG dflt;
} NSAED_GEOIPRATE_CONFIG;

typedef struct
{
    NSAED_PROTECTION_STATS_BASE stats_base;
} NSAED_GEOIPRATE_STATS;

typedef struct
{
    NSAED_GEOIPRATE_STATS stats;
    NSAED_GEOIPRATE_STATE_SHARED* shared;
} NSAED_GEOIPRATE_STATE;

PRIVATE VOID* geoiprate_config_alloc();
PRIVATE VOID geoiprate_config_free(VOID *prot);
PRIVATE VOID* geoiprate_state_alloc();
PRIVATE VOID geoiprate_state_free(VOID *prot);
PRIVATE VOID geoiprate_stat_dump(const VOID *c, const VOID *s);
PRIVATE VOID geoiprate_stat_dump_json(cJSON *cj, const VOID *c, const VOID *s);
PRIVATE VOID geoiprate_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur);
PRIVATE NSAED_ACTION geoiprate_inspect(const VOID *prot_config, VOID *prot_state, struct XMIB_FLOW_INFO *info);
PRIVATE VOID geoiprate_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *geoiprate_json);
PRIVATE BOOL geoiprate_config_get_enabled(VOID *prot_config);
PRIVATE VOID geoiprate_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE VOID geoiprate_config_dump(const VOID *c);
PRIVATE VOID geoiprate_config_loaded(const VOID *prot_config, VOID *prot_state, VOID *shared_state);
PRIVATE VOID* geoiprate_state_shared_alloc();
PRIVATE VOID geoiprate_state_shared_free(VOID *shared);

PRIVATE NSAED_ACTION geoiprate_action_eval(NSAED_GEOIPRATE_STATE *state, const NSAED_GEOIPRATE_COUNTRY_CONFIG *country, XMIB_FLOW_INFO *info);
PRIVATE VOID geoiprate_registered(N32 id);
PRIVATE N32 geoiprate_get_protection_id();

EXPORT const NSAED_PROTECTION geoiprate_protection = {
    .name = "geoiprate",
    .features = NSAED_FEATURE_GEOIP,

    .config_allocator = geoiprate_config_alloc,
    .config_deallocator = geoiprate_config_free,
    .config_handler = geoiprate_config_handler,
    .config_get_enabled = geoiprate_config_get_enabled,
    .config_set_enabled = geoiprate_config_set_enabled,
    .config_dumper = geoiprate_config_dump,
    .config_loaded = geoiprate_config_loaded,
    .state_allocator = geoiprate_state_alloc,
    .state_deallocator = geoiprate_state_free,
    .inspector = geoiprate_inspect,
    .stat_dumper = geoiprate_stat_dump,
    .stat_dumper_json = geoiprate_stat_dump_json,
    .stat_accumulator = geoiprate_stat_add,
    .registered = geoiprate_registered,
    .get_protection_id = geoiprate_get_protection_id,
    .state_shared_allocator = geoiprate_state_shared_alloc,
    .state_shared_deallocator = geoiprate_state_shared_free,
};


PRIVATE N32 protection_id = 0;

PRIVATE VOID geoiprate_stat_dump(const VOID *c, const VOID *s)
{
    const NSAED_GEOIPRATE_STATE *state = s;
    if (state)
    {
        rcon_printf("Packets dropped by %s: %llu\n",
                GEOIPRATE_NAME, state->stats.stats_base.pkt_dropped);
        rcon_printf("L3 Bytes dropped by %s: %llu\n",
                GEOIPRATE_NAME, state->stats.stats_base.l3_byte_dropped);
    }
}

PRIVATE VOID geoiprate_stat_dump_json(cJSON *cj, const VOID *c, const VOID *s)
{
    const NSAED_GEOIPRATE_STATE* state = s;
    const NSAED_GEOIPRATE_STATS* stats = &state->stats;

    cJSON* geoiprate = cJSON_AddObjectToObject(cj, geoiprate_protection.name);
    cJSON_AddNumberToObject(geoiprate, "packets_dropped", stats->stats_base.pkt_dropped);
    cJSON_AddNumberToObject(geoiprate, "l3_bytes_dropped", stats->stats_base.l3_byte_dropped);
}

PRIVATE VOID geoiprate_stat_add(const VOID *config, VOID* state_total, const VOID* state_cur)
{
    NSAED_GEOIPRATE_STATE* total = state_total;
    const NSAED_GEOIPRATE_STATE* cur = state_cur;
    total->stats.stats_base.pkt_dropped += cur->stats.stats_base.pkt_dropped;
    total->stats.stats_base.l3_byte_dropped += cur->stats.stats_base.l3_byte_dropped;
}

PRIVATE NSAED_ACTION geoiprate_inspect(const VOID *c, VOID* s, XMIB_FLOW_INFO *info)
{
    const NSAED_GEOIPRATE_CONFIG *config = c;
    NSAED_GEOIPRATE_STATE *state = s;
    NSAED_GEOIPRATE_COUNTRY_CONFIG *country;

    // We only handle GEOIP for ip Version 4
    if (info->ip_parse_info.ip_version != 4)
    {
        return NSAED_ACTION_NONE;
    }

    vector_iter_t vi;
    container_foreach(vector, config->countries, vi, country)
    {
        if (country->region_id == info->geoip_region)
        {
            return geoiprate_action_eval(state, country, info);
        }
    }
    return geoiprate_action_eval(state, &config->dflt, info);
}

PRIVATE NSAED_ACTION geoiprate_action_eval(NSAED_GEOIPRATE_STATE *state, const NSAED_GEOIPRATE_COUNTRY_CONFIG *country, XMIB_FLOW_INFO *info)
{
    NSAED_GEOIPRATE_LIMITER *limiter = &state->shared->limiter[country->region_id];
    switch(country->action)
    {
    case NSAED_GEOIPRATE_ACTION_DROP:
        state->stats.stats_base.pkt_dropped++;
        state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
        return NSAED_ACTION_DROP;
    case NSAED_GEOIPRATE_ACTION_RATELIMIT:
        if (country->max_bps)
        {
            N32 ip_len = info->ip_parse_info.ip_hdr_len + info->ip_parse_info.ip_payload_len;
            tokenshare_fill(&limiter->bps_limiter, info->frame_time_us, country->max_bps / 8, country->max_bps / 8);
            if (tokenshare_consume(&limiter->bps_limiter, ip_len))
            {
                state->stats.stats_base.pkt_dropped++;
                state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
                return NSAED_ACTION_DROP;
            }

        }
        if (country->max_pps)
        {
            tokenshare_fill(&limiter->pps_limiter, info->frame_time_us, country->max_pps, country->max_pps);
            if (tokenshare_consume(&limiter->pps_limiter, 1))
            {
                state->stats.stats_base.pkt_dropped++;
                state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
                return NSAED_ACTION_DROP;
            }
        }
        break;
    default:
        return NSAED_ACTION_NONE;
    }
    return NSAED_ACTION_NONE;
}


PRIVATE VOID geoiprate_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *geoiprate_json)
{
    TEXT * action;
    NSAED_GEOIPRATE_CONFIG *config = prot_config;
    NSAED_GEOIPRATE_COUNTRY_CONFIG country;

    cJSON *countries_json = cJSON_GetObjectItemCaseSensitive(geoiprate_json, "countries");
    cJSON *default_json = cJSON_GetObjectItemCaseSensitive(geoiprate_json, "default");

    config->geoip = pg_config_get_geoip(pg_config);

    if (default_json)
    {
        cJSON *action_json = cJSON_GetObjectItemCaseSensitive(default_json, "action");
        cJSON *bps_json = cJSON_GetObjectItemCaseSensitive(default_json, "max_bps");
        cJSON *pps_json = cJSON_GetObjectItemCaseSensitive(default_json, "max_pps");
        if (action_json && cJSON_IsString(action_json))
        {
            action = cJSON_GetStringValue(action_json);
            if (strcmp(action, "drop") == 0)
            {
                config->dflt.action = NSAED_GEOIPRATE_ACTION_DROP;
            }
            else if (strcmp(action, "rate_limit") == 0)
            {
                config->dflt.action = NSAED_GEOIPRATE_ACTION_RATELIMIT;
            }
            else
            {
                config->dflt.action = NSAED_GEOIPRATE_ACTION_NONE;
            }
        }
        if (bps_json && cJSON_IsNumber(bps_json))
        {
            config->dflt.max_bps = (INT)cJSON_GetNumberValue(bps_json);
        }
        if (pps_json && cJSON_IsNumber(pps_json))
        {
            config->dflt.max_pps = (INT)cJSON_GetNumberValue(pps_json);
        }
    }

    config->countries = vector_new(sizeof(NSAED_GEOIPRATE_COUNTRY_CONFIG), cJSON_GetArraySize(countries_json));
    if (countries_json && cJSON_IsArray(countries_json))
    {
        for (int i = 0; i < cJSON_GetArraySize(countries_json); ++i)
        {
            cJSON *country_json = cJSON_GetArrayItem(countries_json, i);
            cJSON *cc_json = cJSON_GetObjectItemCaseSensitive(country_json, "country");
            cJSON *action_json = cJSON_GetObjectItemCaseSensitive(country_json, "action");
            cJSON *bps_json = cJSON_GetObjectItemCaseSensitive(country_json, "max_bps");
            cJSON *pps_json = cJSON_GetObjectItemCaseSensitive(country_json, "max_pps");
            memset(&country, 0, sizeof(NSAED_GEOIPRATE_COUNTRY_CONFIG));
            if (cc_json && cJSON_IsString(cc_json))
            {
                country.region_id = geoip_region_str_to_id(config->geoip, cJSON_GetStringValue(cc_json));
            }
            if (action_json && cJSON_IsString(action_json))
            {
                action = cJSON_GetStringValue(action_json);
                if (strcmp(action, "drop") == 0)
                {
                    country.action = NSAED_GEOIPRATE_ACTION_DROP;
                }
                else if (strcmp(action, "rate_limit") == 0)
                {
                    country.action = NSAED_GEOIPRATE_ACTION_RATELIMIT;
                }
                else
                {
                    country.action = NSAED_GEOIPRATE_ACTION_NONE;
                }
            }
            if (bps_json && cJSON_IsNumber(bps_json))
            {
                country.max_bps = (INT)cJSON_GetNumberValue(bps_json);
            }
            if (pps_json && cJSON_IsNumber(pps_json))
            {
                country.max_pps = (INT)cJSON_GetNumberValue(pps_json);
            }
            log_event(BOTH_LOG, "#NSAED-GEOIPRATE: Adding %s, %s, %u, %u", geoip_region_id_to_str(config->geoip, country.region_id), ACTION2STR(country.action), country.max_pps, country.max_bps);
            vector_push_back(config->countries, &country);
        }
    }
}

PRIVATE BOOL geoiprate_config_get_enabled(VOID *prot_config)
{
    NSAED_GEOIPRATE_CONFIG *config = prot_config;
    return config->enabled;
}

PRIVATE VOID geoiprate_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_GEOIPRATE_CONFIG *config = prot_config;
    config->enabled = state;
}

PRIVATE VOID geoiprate_config_dump(const VOID *c)
{
    const NSAED_GEOIPRATE_CONFIG *config = c;
    const NSAED_GEOIPRATE_COUNTRY_CONFIG *country;
    rcon_printf("%s\n  Enabled: %s\n", GEOIPRATE_NAME,
        IS_PROTECTION_ENABLED(config->enabled));
    if (config->enabled)
    {
        if (config->countries != NULL)
        {
            vector_iter_t vi;
            container_foreach(vector, config->countries, vi, country)
            {
                rcon_printf("  Country: %s\n", geoip_region_id_to_str(config->geoip, country->region_id));
                rcon_printf("    Action: %s\n", ACTION2STR(country->action));
                rcon_printf("    Max BPS: %u\n", country->max_bps);
                rcon_printf("    Max PPS: %u\n", country->max_pps);
            }
        }
        rcon_printf("  Default:\n");
        rcon_printf("    Action: %s\n", ACTION2STR(config->dflt.action));
        rcon_printf("    Max BPS: %u\n", config->dflt.max_bps);
        rcon_printf("    Max PPS: %u\n", config->dflt.max_pps);
    }
}

PRIVATE VOID geoiprate_config_loaded(const VOID *c, VOID *s, VOID *sh)
{
    NSAED_GEOIPRATE_STATE *state = s;
    NSAED_GEOIPRATE_STATE_SHARED *shared = sh;
    state->shared = shared;
}

PRIVATE VOID* geoiprate_config_alloc()
{
    return calloc(1, sizeof(NSAED_GEOIPRATE_CONFIG));
}

PRIVATE VOID geoiprate_config_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    NSAED_GEOIPRATE_CONFIG *config = (NSAED_GEOIPRATE_CONFIG *)prot;
    vector_release(&config->countries);
    free(config);
}

PRIVATE VOID* geoiprate_state_alloc()
{
    NSAED_GEOIPRATE_STATE* prot = calloc(1, sizeof(NSAED_GEOIPRATE_STATE));
    if (prot == NULL)
    {
        return NULL;
    }
    return prot;
}

PRIVATE VOID geoiprate_state_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    NSAED_GEOIPRATE_STATE *protection = (NSAED_GEOIPRATE_STATE *)prot;
    free(protection);
}

PRIVATE VOID geoiprate_registered(N32 id)
{
    protection_id = id;
}

PRIVATE N32 geoiprate_get_protection_id()
{
    return protection_id;
}

PRIVATE VOID* geoiprate_state_shared_alloc()
{
    NSAED_GEOIPRATE_STATE_SHARED *shared = calloc(1, sizeof(NSAED_GEOIPRATE_STATE_SHARED));
    if (posix_memalign((VOID**)&shared->limiter, sizeof(tokenshare), sizeof(NSAED_GEOIPRATE_LIMITER) * GEOIPRATE_NUMREGIONS) != 0)
    {
        return NULL;
    }
    memset(shared->limiter, 0, sizeof(NSAED_GEOIPRATE_LIMITER) * GEOIPRATE_NUMREGIONS);
    return shared;
}

PRIVATE VOID geoiprate_state_shared_free(VOID *shared)
{
    free(shared);
}

#endif //ISNG_BASED_AED
#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2024                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
                                                                        *
************************************************************************/

#include <arpa/inet.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "eventlog.h"
#include "aed/aed.h"
#include "aed/aedmacros.h"
#include "aed/cJSON.h"
#include "aed/pfset.h"
#include "xmibflow.h"

#include "../foundation/hash.h"
#include "../foundation/hash_functions.h"
#include "../foundation/ptrie.h"
#include "../foundation/prefix.h"
#include "../foundation/vector.h"

#define IPV6_LENGTH  INET6_ADDRSTRLEN + 4
#define IPV4_LENGTH  INET_ADDRSTRLEN + 4

#define IP_FILTER_NAME "IP Filtering"

// 16 is a guess at a largeish number of flists per pg. Note that
// vectors/hash tables will realloc if needed. It seems unlikely we'll use
// 16 flists in the vast majority of cases, but it's also a minimal amount
// of wasted space.
#define INITIAL_FLISTS_PER_PG 16

typedef struct NSAED_IPFILTER_CONFIG NSAED_IPFILTER_CONFIG;

struct NSAED_IPFILTER_CONFIG
{
    BOOL ipfilter_enabled;
    vector_t *flist_ids;
    const ptrie_t *drop;
    const ptrie_t *forward;
    NSAED_ACTION action; // NSAED_ACTION_DROP or NSAED_ACTION_BLOCK
};

typedef struct
{
    NSAED_PROTECTION_STATS_BASE stats_base;
    N64 pkt_forwarded;

    // map from N32 flist id -> N64 *count
    hash_t *flist_stats;
} NSAED_IPFILTER_STATS;

typedef struct
{
    NSAED_IPFILTER_STATS stats;
} NSAED_IPFILTER_STATE;

#define IP_FILTERING_ELEMENT_NAME "ip_filtering"

PRIVATE VOID* ip_filtering_config_alloc();
PRIVATE VOID ip_filtering_config_free(VOID *prot);
PRIVATE VOID ip_filtering_config_dump(const VOID *prot_config);
PRIVATE VOID ip_filtering_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *json);
PRIVATE BOOL ip_filtering_config_get_enabled(VOID *prot_config);
PRIVATE VOID ip_filtering_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE VOID ip_filtering_config_loaded(const VOID *pg_config, VOID *pg_state, VOID *shared_state);
PRIVATE NSAED_ACTION ip_filtering_inspect(const VOID *prot_config, VOID *prot_state, XMIB_FLOW_INFO *info);
PRIVATE VOID ip_filtering_stat_dump(const VOID *config, const VOID* state);
PRIVATE VOID ip_filtering_stat_dump_json(cJSON*, const VOID *config, const VOID* state);
PRIVATE VOID ip_filtering_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur);
PRIVATE VOID* ip_filtering_state_alloc();
PRIVATE VOID ip_filtering_state_free(VOID *prot);
PRIVATE VOID ip_filtering_registered(N32 id);
PRIVATE N32 ip_filtering_get_protection_id();

EXPORT const NSAED_PROTECTION ip_filtering_protection = {
    .name = IP_FILTERING_ELEMENT_NAME,

    .config_allocator = ip_filtering_config_alloc,
    .config_deallocator = ip_filtering_config_free,
    .config_dumper = ip_filtering_config_dump,
    .config_handler = ip_filtering_config_handler,
    .config_get_enabled = ip_filtering_config_get_enabled,
    .config_set_enabled = ip_filtering_config_set_enabled,
    .config_loaded = ip_filtering_config_loaded,
    .inspector = ip_filtering_inspect,
    .stat_dumper = ip_filtering_stat_dump,
    .stat_dumper_json = ip_filtering_stat_dump_json,
    .stat_accumulator = ip_filtering_stat_add,
    .state_allocator = ip_filtering_state_alloc,
    .state_deallocator = ip_filtering_state_free,
    .registered = ip_filtering_registered,
    .get_protection_id = ip_filtering_get_protection_id,
};

PRIVATE N32 protection_id = 0;

PRIVATE VOID* ip_filtering_config_alloc()
{
    NSAED_IPFILTER_CONFIG *config = calloc(1, sizeof(NSAED_IPFILTER_CONFIG));
    if (config)
    {
        config->flist_ids = vector_new(sizeof(N32), INITIAL_FLISTS_PER_PG);
        if (config->flist_ids == NULL)
        {
            ip_filtering_config_free(config);
            return NULL;
        }
    }
    return config;
}

PRIVATE VOID ip_filtering_config_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    NSAED_IPFILTER_CONFIG* protection = (NSAED_IPFILTER_CONFIG *)prot;
    vector_release(&protection->flist_ids);
    pfset_release_ptrie(protection->drop);
    pfset_release_ptrie(protection->forward);

    free(protection);
}

PRIVATE cJSON* ip_filtering_get_cjson_for_action(cJSON *cj, NSAED_ACTION action)
{
    const TEXT* flist_name = NULL;
    switch(action)
    {
        case NSAED_ACTION_DROP:
            flist_name = "drop_filter_lists";
            break;
        case NSAED_ACTION_FORWARD:
            flist_name = "forward_filter_lists";
            break;
        default:
            log_event(BOTH_LOG,
                    IP_FILTER_NAME ": %d Invalid action id for filter list", action);
            return NULL;
    }

    cJSON *flists_json = cJSON_GetObjectItemCaseSensitive(cj, flist_name);
    if (!flists_json || !cJSON_IsArray(flists_json))
    {
        log_event(BOTH_LOG, "#NSAED-CFG IP filter lists missing/errored");
        return NULL;
    }

    return flists_json;
}

PRIVATE BOOL
ip_filtering_load_filter_lists(NSAED_IPFILTER_CONFIG *config,
                            cJSON *ip_filtering_json, INT ip_version, NSAED_ACTION action)
{
    cJSON *flists_json = ip_filtering_get_cjson_for_action(ip_filtering_json, action);
    if (flists_json == NULL)
    {
        return FALSE;
    }

    const ptrie_t * ptrie = pfset_get_ptrie(flists_json, ip_version);
    if (ptrie == NULL)
    {
        return FALSE;
    }

    switch(action)
    {
        case NSAED_ACTION_DROP:
            config->drop = ptrie;
            break;
        case NSAED_ACTION_FORWARD:
            config->forward = ptrie;
            break;
        default:
            log_event(BOTH_LOG, "%s: %d Invalid action type for IPv%d filter list",
                    IP_FILTER_NAME, action, ip_version);
            return FALSE;
    }

    return TRUE;
}

PRIVATE VOID ip_filtering_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *ip_filtering_json)
{
    NSAED_IPFILTER_CONFIG *config = prot_config;
    TEXT *action;
    cJSON *action_json = cJSON_GetObjectItemCaseSensitive(ip_filtering_json, "action");
    INT ip_version = pg_config_get_ip_version(pg_config);
    BOOL result;
    config->action = NSAED_ACTION_DROP;

    if (action_json && cJSON_IsString(action_json))
    {
        action = cJSON_GetStringValue(action_json);
        if (strcmp(action, "drop") == 0)
        {
            config->action = NSAED_ACTION_DROP;
        }
        else if (strcmp(action, "block") == 0)
        {
            config->action = NSAED_ACTION_BLOCK;
        }
        else
        {
            // Unknown action
            ip_filtering_config_set_enabled(config, FALSE);
            return;
        }
    }

    result = ip_filtering_load_filter_lists(config, ip_filtering_json, ip_version, NSAED_ACTION_DROP);
    result |= ip_filtering_load_filter_lists(config, ip_filtering_json, ip_version, NSAED_ACTION_FORWARD);
    if (!result)
    {
        log_event(BOTH_LOG, "%s: pg %d load drop and forward filter list failed",
                IP_FILTER_NAME, pg_config_get_id(pg_config));
        ip_filtering_config_set_enabled(config, FALSE);
        return;
    }


    // Collect the ids for filter lists in both the drop and forward arrays.
    for (INT i = 0; i <= 1; i++)
    {
        const TEXT *key_name = i == 0 ? "drop_filter_lists" : "forward_filter_lists";
        cJSON *flists_json;
        cJSON *flist_obj_json;
        flists_json = cJSON_GetObjectItemCaseSensitive(ip_filtering_json, key_name);
        if (flists_json != NULL) {
            cJSON_ArrayForEach(flist_obj_json, flists_json)
            {
                cJSON *id_json = cJSON_GetObjectItemCaseSensitive(flist_obj_json, "id");
                if (!cJSON_IsNumber(id_json))
                {
                    continue;
                }
                N32 id = (N32)cJSON_GetNumberValue(id_json);
                vector_push_back(config->flist_ids, &id);
            }
        }
    }
}

PRIVATE BOOL ip_filtering_config_get_enabled(VOID *prot_config)
{
    NSAED_IPFILTER_CONFIG *config = prot_config;
    return config->ipfilter_enabled;
}

PRIVATE VOID ip_filtering_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_IPFILTER_CONFIG *config = prot_config;
    config->ipfilter_enabled = state;
}

PRIVATE VOID ip_filtering_config_loaded(const VOID *prot_config, VOID *prot_state, VOID *sh)
{
    const NSAED_IPFILTER_CONFIG *config = prot_config;
    NSAED_IPFILTER_STATE *state = prot_state;

    // remove unused ids from the hash
    hash_iter_t hi;
    pair_t hp;
    container_foreach(hash, state->stats.flist_stats, hi, hp)
    {
        N32 id_from_hash = ptr_to_uint32(hp.key);
        N32 *in_use_id;
        vector_iter_t vi;
        container_foreach(vector, config->flist_ids, vi, in_use_id)
        {
            if (*in_use_id == id_from_hash)
            {
                goto found;
            }
        }

        // The id from hash was not found in current set; remove from hash.
        hi = hash_iter_delete(hi, &hp);

found:
    }

    N32 *id;
    vector_iter_t vi;
    container_foreach(vector, config->flist_ids, vi, id)
    {
        if (hash_get(state->stats.flist_stats, uint32_to_ptr(*id)) != NULL)
        {
            // flist id already in the hash.
            continue;
        }
        N64 *count = calloc(1, sizeof(N64));
        if (count == NULL)
        {
            // Nothing to be done here; when we try to increment stats for
            // this flist id the element won't be found in the hash and
            // we'll just have to deal with it when we do that lookup.
            return;
        }
        pair_t pair = { uint32_to_ptr(*id), count };
        hash_put(state->stats.flist_stats, pair);
    }
}

PRIVATE VOID ip_filtering_config_dump(const VOID *c)
{
    const NSAED_IPFILTER_CONFIG* config = c;
    rcon_printf("%s\n  Enabled: %s\n", IP_FILTER_NAME,
        IS_PROTECTION_ENABLED(config->ipfilter_enabled));
    if (!config->ipfilter_enabled)
    {
        return;
    }

    const TEXT *action_str;
    switch (config->action)
    {
        case NSAED_ACTION_DROP:
            action_str = "drop";
            break;
        case NSAED_ACTION_BLOCK:
            action_str = "block";
            break;
        default:
            action_str = "UNKNOWN";
    }
    rcon_printf("  Action: %s\n", action_str);

    N32 *id;
    vector_iter_t vi;
    rcon_printf("  Filter Lists (%llu): ", vector_count(config->flist_ids));
    container_foreach(vector, config->flist_ids, vi, id)
    {
        rcon_printf("%d ", *id);
    }
    rcon_printf("\n");
}

// Increment the hit count for the given flist id.
PRIVATE VOID incr_flist_id_count(NSAED_IPFILTER_STATS *stats, N32 flist_id)
{
    N64 *count = hash_get(stats->flist_stats, uint32_to_ptr(flist_id));
    if (count != NULL)
    {
        (*count)++;
    }
    else
    {
        log_event(BOTH_LOG, IP_FILTER_NAME ": hit list %u (unknown flist id)", flist_id);
    }
}

PRIVATE NSAED_ACTION ip_filtering_inspect(const VOID *c, VOID *s, XMIB_FLOW_INFO *info)
{
    const NSAED_IPFILTER_CONFIG* config = c; NSAED_IPFILTER_STATE* state = s;

    N32 src_addr;
    prefix_t check_prefix;
    IPV4_IPV6_ADDR haddr;

    switch (info->ip_parse_info.ip_version)
    {
        case 4:
            /* Convert src address to network byte order */
            GET_IPV4_SRC_ADDR_NET_ORDER(info, src_addr);
            prefix_init(AF_INET, (VOID *)&src_addr, 32, &check_prefix);
            break;
        case 6:
            /* Convert src address to network byte order 
             * NTOH is a lie. This is actually HTON. */
            SET_IPV6_ADDR_NTOH(haddr, &info->ip_parse_info.addr[OUTER_MOST_IP_HDR - 1].src);
            prefix_init(AF_INET6, (VOID *)&(haddr), 128, &check_prefix);
            break;
        default:
            return NSAED_ACTION_NONE;
    }

    N32 flist_id = 0;
    if (0 == ptrie_get_less_specific(config->forward, &check_prefix, NULL, (VOID**)&flist_id, 0))
    {
        state->stats.pkt_forwarded++;
        incr_flist_id_count(&state->stats, flist_id);
        return NSAED_ACTION_FORWARD;
    }
    if (0 == ptrie_get_less_specific(config->drop, &check_prefix, NULL, (VOID**)&flist_id, 0))
    {
        state->stats.stats_base.pkt_dropped++;
        state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
        incr_flist_id_count(&state->stats, flist_id);
        return config->action;
    }

    return NSAED_ACTION_NONE;
}

PRIVATE VOID ip_filtering_stat_dump(const VOID *c, const VOID *s)
{
    const NSAED_IPFILTER_STATE* state = s;
    if (state)
    {
        rcon_printf("Packets dropped by %s: %llu\n",
                IP_FILTER_NAME, state->stats.stats_base.pkt_dropped);
        rcon_printf("L3 Bytes dropped by %s: %llu\n",
                IP_FILTER_NAME, state->stats.stats_base.l3_byte_dropped);
        rcon_printf("Packets forwarded by %s: %llu\n",
                IP_FILTER_NAME, state->stats.pkt_forwarded);

        hash_iter_t hi;
        pair_t hp;
        container_foreach(hash, state->stats.flist_stats, hi, hp)
        {
            rcon_printf(IP_FILTER_NAME " filter list %u packets: %llu\n", ptr_to_uint32(hp.key), *(N64*)hp.value);
        }
    }

}

PRIVATE VOID ip_filtering_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur)
{
    NSAED_IPFILTER_STATE* total = state_total;
    const NSAED_IPFILTER_STATE* cur = state_cur;
    total->stats.stats_base.pkt_dropped += cur->stats.stats_base.pkt_dropped;
    total->stats.stats_base.l3_byte_dropped += cur->stats.stats_base.l3_byte_dropped;
    total->stats.pkt_forwarded += cur->stats.pkt_forwarded;

    hash_iter_t hi;
    pair_t hp;
    container_foreach(hash, cur->stats.flist_stats, hi, hp)
    {
        N32 flist_id = ptr_to_uint32(hp.key);
        N64 count = *(N64*)hp.value;

        N64 *total_count = hash_get(total->stats.flist_stats, uint32_to_ptr(flist_id));
        if (total_count == NULL)
        {
            // flist id not yet in the `total` hash, add it.
            total_count = calloc(1, sizeof(N64));
            if (total_count == NULL)
            {
                // Nothing to be done here; we'll just fail to report the
                // flist stat.
                log_event(BOTH_LOG, IP_FILTER_NAME ": error allocating memory in stat accumulator");
                return;
            }

            // Note: this `hash_put` is safe inside this iterator loop,
            // because we're not modifying the hash that we're iterating.
            *total_count = count;
            pair_t pair = { uint32_to_ptr(flist_id), total_count };
            hash_put(total->stats.flist_stats, pair);
        }
        else
        {
            *total_count += count;
        }
    }
}

PRIVATE VOID ip_filtering_stat_dump_json(cJSON* cj, const VOID *c, const VOID *s)
{
    const NSAED_IPFILTER_STATE* state = s;
    const NSAED_IPFILTER_STATS* stats = &state->stats;

    cJSON* ip_filtering = cJSON_AddObjectToObject(cj, "ip_filtering");
    cJSON_AddNumberToObject(ip_filtering, "packets_dropped", stats->stats_base.pkt_dropped);
    cJSON_AddNumberToObject(ip_filtering, "l3_bytes_dropped", stats->stats_base.l3_byte_dropped);
    cJSON_AddNumberToObject(ip_filtering, "packets_forwarded", stats->pkt_forwarded);

    cJSON* flist_stats = cJSON_AddObjectToObject(ip_filtering, "filter_lists");
    hash_iter_t hi;
    pair_t hp;
    container_foreach(hash, stats->flist_stats, hi, hp)
    {
        char id_str[64];
        snprintf(id_str, sizeof(id_str), "%u", ptr_to_uint32(hp.key));
        cJSON_AddNumberToObject(flist_stats, id_str, *(N64*)hp.value);
    }
}

PRIVATE INT flist_id_cmp(const VOID *id1, const VOID *id2)
{
    return ptr_to_uint32(id1) - ptr_to_uint32(id2);
}

PRIVATE N32 flist_id_hash(const VOID* id)
{
    N32 fid = ptr_to_uint32(id);
    return fnv1a_hash(&fid, sizeof(fid));
}

PRIVATE VOID* ip_filtering_state_alloc()
{
    NSAED_IPFILTER_STATE *s = calloc(1, sizeof(NSAED_IPFILTER_STATE));
    if (s == NULL)
    {
        return NULL;
    }

    s->stats.flist_stats = hash_new(INITIAL_FLISTS_PER_PG, flist_id_cmp, flist_id_hash);
    if (s->stats.flist_stats == NULL)
    {
        ip_filtering_state_free(s);
        return NULL;
    }
    return s;
}

PRIVATE VOID ip_filtering_state_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }
    NSAED_IPFILTER_STATE *s = prot;

    hash_iter_t hi;
    pair_t hp;
    container_foreach(hash, s->stats.flist_stats, hi, hp)
    {
        free(hp.value);
    }
    hash_release(&s->stats.flist_stats);
    free(prot);
}

PRIVATE VOID ip_filtering_registered(N32 id)
{
    protection_id = id;
}

PRIVATE N32 ip_filtering_get_protection_id()
{
    return protection_id;
}
#endif // ISNG_BASED_AED
#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2024                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
                                                                        *
************************************************************************/

#include <arpa/inet.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "eventlog.h"
#include "aed/aed.h"
#include "aed/aedmacros.h"
#include "aed/cJSON.h"
#include "aed/pfset.h"
#include "xmibflow.h"
#include "aed/protection_group.h"
#include "aed/ip_repfeed.h"

#define IP_REPUTATION_NAME "IP Reputation"

typedef struct
{
    BOOL enabled;
    N8 default_confidence;
    N8 confidences[IP_REPUTATION_MAX_CATEGORIES+1]; // cat ids start at 1
    NSAED_ACTION action; // NSAED_ACTION_DROP or NSAED_ACTION_BLOCK
    const IP_REPUTATION_FLIST *inbound_flist;
} NSAED_IP_REPUTATION_CONFIG;

typedef struct
{
    NSAED_PROTECTION_STATS_BASE stats_base;
    // TODO: We will fix the other members in future PRs
    N64 pkts_dropped[IP_REPUTATION_MAX_CATEGORIES+1]; // cat ids start at 1
    N64 l3_bytes_dropped[IP_REPUTATION_MAX_CATEGORIES+1]; // cat ids start at 1
} NSAED_IP_REPUTATION_STATS;

typedef struct
{
    NSAED_IP_REPUTATION_STATS stats;
} NSAED_IP_REPUTATION_STATE;

#define IP_REPUTATION_ELEMENT_NAME "ip_reputation"

PRIVATE VOID* ip_reputation_config_alloc();
PRIVATE VOID ip_reputation_config_free(VOID *prot);
PRIVATE VOID ip_reputation_config_dump(const VOID *prot_config);
PRIVATE VOID ip_reputation_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *json);
PRIVATE BOOL ip_reputation_config_get_enabled(VOID *prot_config);
PRIVATE VOID ip_reputation_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE NSAED_ACTION ip_reputation_inspect(const VOID *prot_config, VOID *prot_state, XMIB_FLOW_INFO *info);
PRIVATE VOID ip_reputation_stat_dump(const VOID *config, const VOID* state);
PRIVATE VOID ip_reputation_stat_dump_json(cJSON*, const VOID *config, const VOID* state);
PRIVATE VOID ip_reputation_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur);
PRIVATE VOID* ip_reputation_state_alloc();
PRIVATE VOID ip_reputation_state_free(VOID *prot);
PRIVATE VOID ip_reputation_registered(N32 id);
PRIVATE N32 ip_reputation_get_protection_id();

EXPORT const NSAED_PROTECTION ip_reputation_protection = {
    .name = IP_REPUTATION_ELEMENT_NAME,

    .config_allocator = ip_reputation_config_alloc,
    .config_deallocator = ip_reputation_config_free,
    .config_dumper = ip_reputation_config_dump,
    .config_handler = ip_reputation_config_handler,
    .config_get_enabled = ip_reputation_config_get_enabled,
    .config_set_enabled = ip_reputation_config_set_enabled,
    .inspector = ip_reputation_inspect,
    .stat_dumper = ip_reputation_stat_dump,
    .stat_dumper_json = ip_reputation_stat_dump_json,
    .stat_accumulator = ip_reputation_stat_add,
    .state_allocator = ip_reputation_state_alloc,
    .state_deallocator = ip_reputation_state_free,
    .registered = ip_reputation_registered,
    .get_protection_id = ip_reputation_get_protection_id,
};

PRIVATE N32 protection_id = 0;

PRIVATE VOID* ip_reputation_config_alloc()
{
    NSAED_IP_REPUTATION_CONFIG *config = calloc(1, sizeof(NSAED_IP_REPUTATION_CONFIG));
    return config;
}

PRIVATE VOID ip_reputation_config_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    NSAED_IP_REPUTATION_CONFIG* protection = (NSAED_IP_REPUTATION_CONFIG *)prot;
    free(protection);
}

PRIVATE VOID parse_categories_config(NSAED_IP_REPUTATION_CONFIG *prot_config, cJSON *categories_json)
{
    if (categories_json == NULL || !cJSON_IsObject(categories_json))
    {
        return;  /* no category settings to parse */
    }

    cJSON *cat_json;
    cJSON_ArrayForEach(cat_json, categories_json)  /* Loop through the per-category settings */
    {
        if (!cJSON_IsObject(cat_json))
        {
            log_event(BOTH_LOG, "#IP-REPUTATION invalid config object for category %s",
                      cat_json->string);
            continue;  /* cat id doesn't map to object */
        }

        INT cat_id = atoi(cat_json->string);
        if (cat_id < 1 || cat_id > IP_REPUTATION_MAX_CATEGORIES)
        {
            log_event(BOTH_LOG, "#IP-REPUTATION invalid category id %s", cat_json->string);
            continue;  /* cat id is invalid, so skip */
        }

        /**
         * categories are enabled by default, so only disable if "enabled" key
         * exists and is set to false.
         */
        cJSON *enabled = cJSON_GetObjectItem(cat_json, "enabled");
        if (enabled != NULL && cJSON_IsFalse(enabled))
        {
            prot_config->confidences[cat_id] = IP_REPUTATION_DISABLED_CONFIDENCE;
            continue;  /* category is disabled; skip parsing confidence */
        }

        cJSON *confidence_json = cJSON_GetObjectItem(cat_json, "confidence");
        if (confidence_json == NULL || !cJSON_IsNumber(confidence_json))
        {
            continue;  /* confidence key is missing, or doesn't map to number */
        }
        double confidence = cJSON_GetNumberValue(confidence_json);
        if (confidence < 0 || confidence > 100)
        {
            log_event(BOTH_LOG, "#IP-REPUTATION invalid confidence value %.0f for category %d",
                      confidence, cat_id);
            continue;  /* confidence value is out of bounds */
        }
        prot_config->confidences[cat_id] = (N8)confidence;
    }
}

PRIVATE VOID ip_reputation_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *ip_reputation_json)
{
    NSAED_IP_REPUTATION_CONFIG *config = prot_config;

    config->inbound_flist = pg_config_get_ip_rep_inbound_flist(pg_config);
    if (config->inbound_flist == NULL) {
            ip_reputation_config_set_enabled(config, FALSE);
            return;
    }

    TEXT *action;
    cJSON *action_json = cJSON_GetObjectItemCaseSensitive(ip_reputation_json, "action");
    config->action = NSAED_ACTION_DROP;
    if (action_json && cJSON_IsString(action_json))
    {
        action = cJSON_GetStringValue(action_json);
        if (strcmp(action, "drop") == 0)
        {
            config->action = NSAED_ACTION_DROP;
        }
        else if (strcmp(action, "block") == 0)
        {
            config->action = NSAED_ACTION_BLOCK;
        }
        else
        {
            // Unknown action
            ip_reputation_config_set_enabled(config, FALSE);
            return;
        }
    }

    cJSON *confidence = cJSON_GetObjectItemCaseSensitive(ip_reputation_json, "confidence");
    config->default_confidence = 0;
    if (confidence && cJSON_IsNumber(confidence))
    {
        // Bounds check on uncasted value first to ensure an invalid confidence value
        // does not happen to truncate into a valid (but unexpected) confidence value
        double uncasted_confidence = cJSON_GetNumberValue(confidence);
        if (uncasted_confidence >= 0 && uncasted_confidence <= 100)
        {
            config->default_confidence = (N8)uncasted_confidence;
            /* Initialize all categories to have the default confidence */
            for (INT i = 1; i <= IP_REPUTATION_MAX_CATEGORIES; i++)
            {
                config->confidences[i] = config->default_confidence;
            }
        }
        else
        {
            ip_reputation_config_set_enabled(config, FALSE);
            return;
        }
        cJSON *categories = cJSON_GetObjectItemCaseSensitive(ip_reputation_json, "categories");
        parse_categories_config(config, categories);
    }
    else
    {
        ip_reputation_config_set_enabled(config, FALSE);
        return;
    }
}

PRIVATE BOOL ip_reputation_config_get_enabled(VOID *prot_config)
{
    NSAED_IP_REPUTATION_CONFIG *config = prot_config;
    return config->enabled;
}

PRIVATE VOID ip_reputation_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_IP_REPUTATION_CONFIG *config = prot_config;
    config->enabled = state;
}

PRIVATE VOID ip_reputation_config_dump(const VOID *c)
{
    const NSAED_IP_REPUTATION_CONFIG* config = c;
    rcon_printf("%s\n  Enabled: %s\n", IP_REPUTATION_NAME,
        IS_PROTECTION_ENABLED(config->enabled));
    if (!config->enabled)
    {
        return;
    }
    rcon_printf("  Confidence: %hhu\n", config->default_confidence);

    const TEXT *action_str;
    switch (config->action)
    {
        case NSAED_ACTION_DROP:
            action_str = "drop";
            break;
        case NSAED_ACTION_BLOCK:
            action_str = "block";
            break;
        default:
            action_str = "UNKNOWN";
    }
    rcon_printf("  Action: %s\n", action_str);
    for (INT i = 1; i <= IP_REPUTATION_MAX_CATEGORIES; i++)
    {
        // Only print categories whose settings differ from the default
        if (config->confidences[i] == IP_REPUTATION_DISABLED_CONFIDENCE)
        {
            rcon_printf("  Category %d: disabled\n", i);
        }
        else if (config->confidences[i] != config->default_confidence) {
            rcon_printf("  Category %d Confidence: %d\n", i, config->confidences[i]);
        }
    }
}

PRIVATE NSAED_ACTION ip_reputation_inspect(const VOID *c, VOID *s, XMIB_FLOW_INFO *info)
{
    const NSAED_IP_REPUTATION_CONFIG* config = c;
    NSAED_IP_REPUTATION_STATE* state = s;
    IP_REPUTATION_RULE *match;

    // IP Reputation only supports IPv4
    if (info->ip_parse_info.ip_version != 4)
    {
        return NSAED_ACTION_NONE;
    }

    match = ip_reputation_flist_match(config->inbound_flist,
                                  info->ip_parse_info.src_addr,
                                  info->ip_parse_info.protocol,
                                  info->ip_parse_info.dest_port,
                                  config->confidences);
    if (match == NULL)
    {
        return NSAED_ACTION_NONE; /* no match, nothing to be done */
    }

    state->stats.stats_base.pkt_dropped++;
    state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
    /* increment per-category counters */
    state->stats.pkts_dropped[ip_reputation_rule_get_category(match)]++;
    state->stats.l3_bytes_dropped[ip_reputation_rule_get_category(match)] += L3_BYTES(info);
    return config->action;
}

PRIVATE VOID ip_reputation_stat_dump(const VOID *c, const VOID *s)
{
    const NSAED_IP_REPUTATION_STATE* state = s;
    if (!state)
    {
        return;
    }

    rcon_printf("Packets dropped by %s: %llu\n",
            IP_REPUTATION_NAME, state->stats.stats_base.pkt_dropped);
    rcon_printf("L3 Bytes dropped by %s: %llu\n",
            IP_REPUTATION_NAME, state->stats.stats_base.l3_byte_dropped);
    for (INT i = 1; i <= IP_REPUTATION_MAX_CATEGORIES; i++)
    {
        if (state->stats.pkts_dropped[i] == 0)
        {
            continue;
        }
        rcon_printf("Packets dropped by %s (category id: %d): %llu\n",
                IP_REPUTATION_NAME, i, state->stats.pkts_dropped[i]);
        rcon_printf("L3 Bytes dropped by %s (category id: %d): %llu\n",
                IP_REPUTATION_NAME, i, state->stats.l3_bytes_dropped[i]);
    }
}

PRIVATE VOID ip_reputation_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur)
{
    NSAED_IP_REPUTATION_STATE* total = state_total;
    const NSAED_IP_REPUTATION_STATE* cur = state_cur;
    total->stats.stats_base.pkt_dropped += cur->stats.stats_base.pkt_dropped;
    total->stats.stats_base.l3_byte_dropped += cur->stats.stats_base.l3_byte_dropped;
    for (INT i = 1; i <= IP_REPUTATION_MAX_CATEGORIES; i++)
    {
        total->stats.pkts_dropped[i] += cur->stats.pkts_dropped[i];
        total->stats.l3_bytes_dropped[i] += cur->stats.l3_bytes_dropped[i];
    }
}

PRIVATE VOID ip_reputation_stat_dump_json(cJSON* cj, const VOID *c, const VOID *s)
{
    const NSAED_IP_REPUTATION_STATE* state = s;
    const NSAED_IP_REPUTATION_STATS* stats = &state->stats;
    TEXT cat_key[4];

    cJSON* ip_reputation = cJSON_AddObjectToObject(cj, IP_REPUTATION_ELEMENT_NAME);
    cJSON_AddNumberToObject(ip_reputation, "packets_dropped", stats->stats_base.pkt_dropped);
    cJSON_AddNumberToObject(ip_reputation, "l3_bytes_dropped", stats->stats_base.l3_byte_dropped);

    /* per-category stats */
    cJSON *categories = cJSON_AddObjectToObject(ip_reputation, "categories");
    for (INT cat_id = 1; cat_id <= IP_REPUTATION_MAX_CATEGORIES; cat_id++)
    {
        if (stats->pkts_dropped[cat_id] == 0)
        {
            continue;
        }
        snprintf(cat_key, sizeof(cat_key), "%u", cat_id);
        cJSON *cat = cJSON_AddObjectToObject(categories, cat_key);
        cJSON_AddNumberToObject(cat, "packets_dropped", stats->pkts_dropped[cat_id]);
        cJSON_AddNumberToObject(cat, "l3_bytes_dropped", stats->l3_bytes_dropped[cat_id]);
    }
}

PRIVATE VOID* ip_reputation_state_alloc()
{
    NSAED_IP_REPUTATION_STATE *s = calloc(1, sizeof(NSAED_IP_REPUTATION_STATE));
    if (s == NULL)
    {
        return NULL;
    }

    return s;
}

PRIVATE VOID ip_reputation_state_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }
    NSAED_IP_REPUTATION_STATE *protection = (NSAED_IP_REPUTATION_STATE *)prot;
    free(protection);
}

PRIVATE VOID ip_reputation_registered(N32 id)
{
    protection_id = id;
}

PRIVATE N32 ip_reputation_get_protection_id()
{
    return protection_id;
}
#endif // ISNG_BASED_AED
LINPROBE_ROOT ?= ../../..
include $(LINPROBE_ROOT)/common.lin

C_LIB_SRCS =  $(shell /bin/cat src.txt )
LIBNAME = nsaed_protections.a
CFLAGS += -Wmissing-declarations

ifeq "$(ROOT)" ""
        ROOT = ./
endif

INC = -I$(LINPROBE_ROOT)/epilogue/port/linux\
      -I$(LINPROBE_ROOT)/h\
      -I$(LINPROBE_ROOT)/../common\
      -I$(LINPROBE_ROOT)/../tfaengine/communication/common\
      -I$(LINPROBE_ROOT)/decipher/h\
      -I$(LINPROBE_ROOT)/epilogue/envoy/h\
      -I$(LINPROBE_ROOT)/epilogue -I$(ROOT)\
      -I$(LINPROBE_ROOT)/linux/h\
      -I$(LINPROBE_ROOT)/confsubs\
      -I$(LINPROBE_ROOT)/linux/stubs\
      -I$(LINPROBE_ROOT)/mibmgr\
      -I$(LINPROBE_ROOT)/mibmgr/threads\
      -I$(LINPROBE_ROOT)/mibmgr/parser/inc\
      -I$(LINPROBE_ROOT)/mibmgr/parser/enterprise/inc\
      -I$(LINPROBE_ROOT)/mibmgr/common/inc\
      -I$(LINPROBE_ROOT)/mibmgr/ret/inc\
      -I$(LINPROBE_ROOT)/mibmgr/collector/inc\
      -I$(LINPROBE_ROOT)/mibmgr/collector/asiflows\
      -I/usr/include/libxml2

include $(LINPROBE_ROOT)/rules.lin


#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2024                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
                                                                        *
************************************************************************/

#include <string.h>

#include "eventlog.h"
#include "aed/aed.h"
#include "aed/action.h"
#include "aed/cJSON.h"

#define MALFORMED_NAME "Invalid Packets"
#define MALFORMED_ELEMENT_NAME "malformed"

typedef struct
{
    BOOL enabled;
    N64 mask;
} NSAED_MALFORMED_CONFIG;

typedef struct
{
    NSAED_PROTECTION_STATS_BASE stats_base;
} NSAED_MALFORMED_STATS;

typedef struct
{
    NSAED_MALFORMED_STATS stats;
} NSAED_MALFORMED_STATE;

PRIVATE VOID* malformed_config_alloc();
PRIVATE VOID malformed_config_free(VOID *prot);
PRIVATE VOID malformed_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *json);
PRIVATE BOOL malformed_config_get_enabled(VOID *prot_config);
PRIVATE VOID malformed_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE VOID malformed_config_dump(const VOID *prot_config);
PRIVATE NSAED_ACTION malformed_inspect(const VOID *prot_config, VOID *prot_state, struct XMIB_FLOW_INFO *info);
PRIVATE VOID malformed_stat_dump(const VOID *c, const VOID *s);
PRIVATE VOID malformed_stat_dump_json(cJSON *cj, const VOID *c, const VOID *s);
PRIVATE VOID malformed_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur);
PRIVATE VOID* malformed_state_alloc();
PRIVATE VOID malformed_state_free(VOID *prot);
PRIVATE VOID malformed_registered(N32 id);
PRIVATE N32 malformed_get_protection_id();

IMPORT UINT is_model_vi5000;

EXPORT const NSAED_PROTECTION malformed_protection = {
    .name = MALFORMED_ELEMENT_NAME,

    .config_allocator = malformed_config_alloc,
    .config_deallocator = malformed_config_free,
    .config_handler = malformed_config_handler,
    .config_get_enabled = malformed_config_get_enabled,
    .config_set_enabled = malformed_config_set_enabled,
    .config_dumper = malformed_config_dump,
    .inspector = malformed_inspect,
    .stat_dumper = malformed_stat_dump,
    .stat_dumper_json = malformed_stat_dump_json,
    .stat_accumulator = malformed_stat_add,
    .state_allocator = malformed_state_alloc,
    .state_deallocator = malformed_state_free,
    .registered = malformed_registered,
    .get_protection_id = malformed_get_protection_id,
};

PRIVATE N32 protection_id = 0;

PRIVATE VOID* malformed_config_alloc()
{
    return calloc(1, sizeof(NSAED_MALFORMED_CONFIG));
}

PRIVATE VOID malformed_config_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    NSAED_MALFORMED_CONFIG *config = prot;
    free(config);
}

#define PROCESS_NORMAL_CHECK(mask, malformed_json, check_name, check_mask) do {  \
    cJSON *field = cJSON_GetObjectItemCaseSensitive(malformed_json, check_name); \
    /* Normal checks default to enabled, unless disabled explicitly */           \
    if (!field || !cJSON_IsBool(field) || cJSON_IsTrue(field))                   \
        mask |= check_mask;                                                      \
} while(0)

PRIVATE VOID malformed_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *malformed_json)
{
    NSAED_MALFORMED_CONFIG *config = prot_config;

    config->mask = MALFORMED_SEVERE_CHECKS_MASK;
    PROCESS_NORMAL_CHECK(config->mask, malformed_json,
        "ipv4_protocol_eq_0", MALFORMED_IPV4_PROTOCOL_EQ_0
    );
    PROCESS_NORMAL_CHECK(config->mask, malformed_json,
        "ipv6_dup_routing_hdr", MALFORMED_IPV6_DUP_ROUTING_HDR
    );
    PROCESS_NORMAL_CHECK(config->mask, malformed_json,
        "ipv6_dup_esp_hdr", MALFORMED_IPV6_DUP_ESP_HDR
    );
    PROCESS_NORMAL_CHECK(config->mask, malformed_json,
        "ipv6_dup_ah_hdr", MALFORMED_IPV6_DUP_AH_HDR
    );
    PROCESS_NORMAL_CHECK(config->mask, malformed_json,
        "ipv6_dup_hbh_opts_hdr", MALFORMED_IPV6_DUP_HBH_OPTS_HDR
    );
    PROCESS_NORMAL_CHECK(config->mask, malformed_json,
        "ipv6_dup_fragment_hdr", MALFORMED_IPV6_DUP_FRAGMENT_HDR
    );
    PROCESS_NORMAL_CHECK(config->mask, malformed_json,
        "ipv6_dup_dest_opts_hdr", MALFORMED_IPV6_DUP_DEST_OPTS_HDR
    );
    PROCESS_NORMAL_CHECK(config->mask, malformed_json,
        "ipv6_hbh_opts_hdr_after_another_ext_hdr",
        MALFORMED_IPV6_HBH_OPTS_HDR_AFTER_ANOTHER_EXT_HDR
    );
    PROCESS_NORMAL_CHECK(config->mask, malformed_json,
        "ipv6_hbh_opts_invalid", MALFORMED_IPV6_HBH_OPTS_INVALID
    );
    PROCESS_NORMAL_CHECK(config->mask, malformed_json,
        "ipv6_hbh_opts_jumbo_payload", MALFORMED_IPV6_HBH_OPTS_JUMBO_PAYLOAD
    );
    PROCESS_NORMAL_CHECK(config->mask, malformed_json,
        "ipv6_routing_hdr_type_0", MALFORMED_IPV6_ROUTING_HDR_TYPE_0
    );
    PROCESS_NORMAL_CHECK(config->mask, malformed_json,
        "ipv6_routing_hdr_after_fragment_hdr",
        MALFORMED_IPV6_ROUTING_HDR_AFTER_FRAGMENT_HDR
    );
}

PRIVATE BOOL malformed_config_get_enabled(VOID *prot_config)
{
    NSAED_MALFORMED_CONFIG *config = prot_config;
    return config->enabled;
}

PRIVATE VOID malformed_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_MALFORMED_CONFIG *config = prot_config;
    config->enabled = state;
}

PRIVATE VOID malformed_config_dump(const VOID *prot_config)
{
    const NSAED_MALFORMED_CONFIG* config = prot_config;
    rcon_printf("%s\n  Enabled: %s\n", MALFORMED_NAME,
            IS_PROTECTION_ENABLED(config->enabled));
    if (config->enabled)
    {
        rcon_printf("  Mask: 0x%llx\n", config->mask);
    }
}

PRIVATE NSAED_ACTION malformed_inspect(const VOID *prot_config, VOID *prot_state, struct XMIB_FLOW_INFO *info)
{
    const NSAED_MALFORMED_CONFIG *config = prot_config;
    NSAED_MALFORMED_STATE *state = prot_state;

    AED_L3_L4_INFO *aed_l3_l4_info = GET_AED_L3_L4_INFO(info);

    if (aed_l3_l4_info == NULL)
    {
        return NSAED_ACTION_NONE;
    }

    if (aed_l3_l4_info->flags & config->mask)
    {
        state->stats.stats_base.pkt_dropped++;
        // Not using the global L3_BYTES macro here as malformed packets tend to
        // have incorrect values in ip_parse_info fields sometimes.
        // FCS quirk: The vSTREAM does not include 4 bytes of FCS in the frame size
        // All other ISNGs have it. Hence, we need to adjust the L3 bytes accordingly.
        state->stats.stats_base.l3_byte_dropped += \
            info->frame_size - (info->ip_hdr - info->frame_p) - (is_model_vi5000 ? 0 : 4);

        return NSAED_ACTION_DROP;
    }

    return NSAED_ACTION_NONE;
}

PRIVATE VOID malformed_stat_dump(const VOID *c, const VOID *s)
{
    const NSAED_MALFORMED_STATE* state = s;
    if (state)
    {
        rcon_printf("Packets dropped by %s: %llu\n",
                MALFORMED_NAME, state->stats.stats_base.pkt_dropped);
        rcon_printf("L3 Bytes dropped by %s: %llu\n",
                MALFORMED_NAME, state->stats.stats_base.l3_byte_dropped);
    }
}

PRIVATE VOID malformed_stat_dump_json(cJSON *cj, const VOID *c, const VOID *s)
{
    const NSAED_MALFORMED_STATE* state = s;
    const NSAED_MALFORMED_STATS* stats = &state->stats;

    cJSON* malformed = cJSON_AddObjectToObject(cj, MALFORMED_ELEMENT_NAME);
    cJSON_AddNumberToObject(malformed, "packets_dropped", stats->stats_base.pkt_dropped);
    cJSON_AddNumberToObject(malformed, "l3_bytes_dropped", stats->stats_base.l3_byte_dropped);
}

PRIVATE VOID malformed_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur)
{
    NSAED_MALFORMED_STATE* total = state_total;
    const NSAED_MALFORMED_STATE* cur = state_cur;
    total->stats.stats_base.pkt_dropped += cur->stats.stats_base.pkt_dropped;
    total->stats.stats_base.l3_byte_dropped += cur->stats.stats_base.l3_byte_dropped;
}

PRIVATE VOID* malformed_state_alloc()
{
    return calloc(1, sizeof(NSAED_MALFORMED_STATE));
}

PRIVATE VOID malformed_state_free(VOID *prot)
{
    free(prot);
}

PRIVATE VOID malformed_registered(N32 id)
{
    protection_id = id;
}

PRIVATE N32 malformed_get_protection_id()
{
    return protection_id;
}

#endif // ISNG_BASED_AED
#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2024                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
                                                                        *
************************************************************************/

#include <netinet/in.h>
#include <string.h>

#include "eventlog.h"
#include "aed/aed.h"
#include "aed/action.h"
#include "aed/cJSON.h"
#include "aed/regex.h"
#include "aed/foundation/bit_vector.h"

#define PLREGEX_NAME "Payload Regular Expression"
#define PLREGEX_ELEMENT_NAME "payload_regex"
#define KEY_COMPILED_ID "compiled_id"
#define KEY_MATCH_SRC_PORT "match_src_port"
#define KEY_TCP_PORTS "tcp_ports"
#define KEY_UDP_PORTS "udp_ports"
#define KEY_INCLUDE_HEADERS "include_headers"

// TODO: Should we add a key for action as well and use it just like other keys? 
// Seems unnecessary but helps in consistency.
#define PORT_MAX 65535
#define SRC_PORT(info) (info->ip_parse_info.src_port)
#define DEST_PORT(info) (info->ip_parse_info.dest_port)

typedef struct
{
    BOOL enabled;
    BOOL match_src_port;
    BOOL include_headers;
    struct bit_vector *tcp_ports;
    struct bit_vector *udp_ports;
    TEXT *compiled_id;
    NSAED_REGEX regex;
    NSAED_ACTION action;
} NSAED_PLREGEX_CONFIG;

typedef struct
{
    NSAED_PROTECTION_STATS_BASE stats_base;
} NSAED_PLREGEX_STATS;

typedef struct
{
    NSAED_PLREGEX_STATS stats;
} NSAED_PLREGEX_STATE;

PRIVATE VOID* plregex_config_alloc();
PRIVATE VOID plregex_config_free(VOID *prot);
PRIVATE VOID plregex_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *json);
PRIVATE BOOL plregex_config_get_enabled(VOID *prot_config);
PRIVATE VOID plregex_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE VOID plregex_config_dump(const VOID *prot_config);
PRIVATE struct bit_vector* plregex_config_alloc_ports();
PRIVATE VOID plregex_config_free_ports(struct bit_vector** ports);
PRIVATE VOID plregex_config_init_ports(cJSON *cj_ports, struct bit_vector** ports);

PRIVATE NSAED_ACTION plregex_inspect(const VOID *prot_config, VOID *prot_state, struct XMIB_FLOW_INFO *info);
PRIVATE VOID plregex_stat_dump(const VOID *config, const VOID *state);
PRIVATE VOID plregex_stat_dump_json(cJSON* cj, const VOID *config, const VOID *state);
PRIVATE VOID plregex_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur);
PRIVATE VOID* plregex_state_alloc();
PRIVATE VOID plregex_state_free(VOID *prot);
PRIVATE VOID plregex_registered(N32 id);
PRIVATE N32 plregex_get_protection_id();
PRIVATE BOOL plregex_validate_port(const struct bit_vector* ports, N16 port);

EXPORT const NSAED_PROTECTION plregex_protection = {
    .name = PLREGEX_ELEMENT_NAME,

    .config_allocator = plregex_config_alloc,
    .config_deallocator = plregex_config_free,
    .config_handler = plregex_config_handler,
    .config_get_enabled = plregex_config_get_enabled,
    .config_set_enabled = plregex_config_set_enabled,
    .config_dumper = plregex_config_dump,
    .inspector = plregex_inspect,
    .stat_dumper = plregex_stat_dump,
    .stat_dumper_json = plregex_stat_dump_json,
    .stat_accumulator = plregex_stat_add,
    .state_allocator = plregex_state_alloc,
    .state_deallocator = plregex_state_free,
    .registered = plregex_registered,
    .get_protection_id = plregex_get_protection_id,
};

PRIVATE N32 protection_id = 0;

PRIVATE VOID* plregex_config_alloc()
{
    NSAED_PLREGEX_CONFIG* config = calloc(1, sizeof(NSAED_PLREGEX_CONFIG));
    if (config)
    {
        config->tcp_ports = plregex_config_alloc_ports();
        config->udp_ports = plregex_config_alloc_ports();
        if (config->tcp_ports == NULL || config->udp_ports == NULL)
        {
            log_event(DBG_LOG, "#NSAED-CFG payload regex config failed: Unable to configure port lists");
            plregex_config_free(config);
            return NULL;
        }
    }

    return config;
}

PRIVATE VOID plregex_config_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    NSAED_PLREGEX_CONFIG *config = prot;

    plregex_config_free_ports(&config->tcp_ports);
    plregex_config_free_ports(&config->udp_ports);

    if (nsaed_regex_is_valid(config->regex))
    {
        nsaed_regex_unload(config->regex);
    }

    if (config->compiled_id != NULL)
    {
        free(config->compiled_id);
    }

    free(config);
}

PRIVATE struct bit_vector* plregex_config_alloc_ports()
{
    // Create a bit vector with nbits = PORT_MAX
    return bit_vector_create(PORT_MAX);
}

PRIVATE VOID plregex_config_free_ports(struct bit_vector** ports)
{
    bit_vector_destroy(ports);
}

/*
* Freeing the memory for port list in the following cases to ensure that
* the inspection is skipped for respective protocols.
* 1. When value is a string other than `all`
* 2. When list is empty
*/
PRIVATE VOID plregex_config_init_ports(cJSON *cj_ports, struct bit_vector** ports)
{
    // `<proto>_ports` key missing in config - Set default = `all`
    if (!cj_ports)
    {
        bit_vector_set(*ports);
        return;
    }

    if (cJSON_IsString(cj_ports))
    {
        if (strcmp(cJSON_GetStringValue(cj_ports), "all") == 0)
        {
            // All ports should be matched
            bit_vector_set(*ports);
        }
        else
        {
            log_event(DBG_LOG, "#NSAED-CFG payload regex - Invalid value for port list");
            plregex_config_free_ports(ports);
        }
        return;
    }

    if (cJSON_IsArray(cj_ports))
    {
        // Empty list
        if (cJSON_GetArraySize(cj_ports) == 0)
        {
            plregex_config_free_ports(ports);
            return;
        }

        cJSON* cj_port;
        cJSON_ArrayForEach(cj_port, cj_ports)
        {
            if (!cJSON_IsNumber(cj_port))
            {
                continue;
            }
            // ports are stored in HBO and fetched from parsed info in HBO
            // during inspection.
            bit_vector_set_bit(*ports, (INT)cJSON_GetNumberValue(cj_port));
        }
        return;
    }
}

PRIVATE VOID plregex_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *plregex_json)
{
    #define PARSE_BOOL_KEY(cj, jsonkey, config_member) do {                 \
        cJSON *match_json = cJSON_GetObjectItemCaseSensitive(cj, jsonkey);  \
        if (match_json && cJSON_IsBool(match_json))                         \
            config_member = cJSON_IsTrue(match_json) ? TRUE : FALSE;        \
    } while(0)

    NSAED_PLREGEX_CONFIG *config = prot_config;

    // Setting defaults to handle keys missing in config
    config->match_src_port = FALSE;
    config->include_headers = FALSE;
    config->action = NSAED_ACTION_DROP;

    PARSE_BOOL_KEY(plregex_json, KEY_MATCH_SRC_PORT, config->match_src_port);
    PARSE_BOOL_KEY(plregex_json, KEY_INCLUDE_HEADERS, config->include_headers);

    cJSON *tcp_ports_json = cJSON_GetObjectItemCaseSensitive(plregex_json, KEY_TCP_PORTS);
    cJSON *udp_ports_json = cJSON_GetObjectItemCaseSensitive(plregex_json, KEY_UDP_PORTS);
    plregex_config_init_ports(tcp_ports_json, &config->tcp_ports);
    plregex_config_init_ports(udp_ports_json, &config->udp_ports);

    cJSON *action_json = cJSON_GetObjectItemCaseSensitive(plregex_json, "action");
    if (action_json && cJSON_IsString(action_json))
    {
        TEXT* action = cJSON_GetStringValue(action_json);
        if (strcmp(action, "drop") == 0)
        {
            config->action = NSAED_ACTION_DROP;
        }
        else if (strcmp(action, "block") == 0)
        {
            config->action = NSAED_ACTION_BLOCK;
        }
        else
        {
            // Unknown action
            plregex_config_set_enabled(config, FALSE);
            return;
        }
    }

    cJSON *compiled_id_json = cJSON_GetObjectItemCaseSensitive(plregex_json, KEY_COMPILED_ID);
    if (compiled_id_json && cJSON_IsString(compiled_id_json))
    {
        TEXT *compiled_id = cJSON_GetStringValue(compiled_id_json);
        config->regex = nsaed_regex_load(compiled_id);
        if (nsaed_regex_is_valid(config->regex))
        {
            log_event(DBG_LOG, "#NSAED-CFG payload regex loaded \"%s\"", compiled_id);
            // save it for config dump
            config->compiled_id = strdup(compiled_id);
            return;
        }
        else
        {
            log_event(BOTH_LOG, "#NSAED-CFG payload regex load \"%s\" failed", compiled_id);
        }
    }
    else
    {
        log_event(BOTH_LOG, "#NSAED-CFG invalid payload regex config, "
                "\"%s\" is not specified or not a string", KEY_COMPILED_ID);
    }

    plregex_config_set_enabled(config, FALSE);
}

PRIVATE BOOL plregex_config_get_enabled(VOID *prot_config)
{
    NSAED_PLREGEX_CONFIG *config = prot_config;
    return config->enabled;
}

PRIVATE VOID plregex_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_PLREGEX_CONFIG *config = prot_config;
    config->enabled = state;
}

PRIVATE VOID plregex_config_dump(const VOID *prot_config)
{
    #define DUMP_PORTS(proto_ports) do {                        \
        if (!(proto_ports))                                     \
            rcon_printf("none\n");                              \
        else if (bit_vector_all_set(proto_ports))               \
            rcon_printf("all\n");                               \
        else                                                    \
        {                                                       \
            for (INT port = 0; port <= PORT_MAX; ++port)        \
            {                                                   \
                if (bit_vector_is_set(proto_ports, port))       \
                    rcon_printf("%d ", port);                   \
            }                                                   \
            rcon_printf("\n");                                  \
        }                                                       \
    } while(0)

    const NSAED_PLREGEX_CONFIG* config = prot_config;
    rcon_printf("%s\n  Enabled: %s\n", PLREGEX_NAME,
            IS_PROTECTION_ENABLED(config->enabled));
    if (config->enabled)
    {
        rcon_printf("  Compiled ID: %s\n", config->compiled_id);
        rcon_printf("  Include Headers: %s\n",
            (config->include_headers ? "yes": "no"));
        rcon_printf("  Match Port: %s\n",
            (config->match_src_port ? "source": "destination"));
        rcon_printf("    TCP Ports: ");
        DUMP_PORTS(config->tcp_ports);
        rcon_printf("    UDP Ports: ");
        DUMP_PORTS(config->udp_ports);

        const TEXT *action_str;
        switch (config->action)
        {
            case NSAED_ACTION_DROP:
                action_str = "drop";
                break;
            case NSAED_ACTION_BLOCK:
                action_str = "block";
                break;
            default:
                action_str = "UNKNOWN";
        }
        rcon_printf("  Action: %s\n", action_str);
    }
}

PRIVATE INLINE BOOL
plregex_validate_port(const struct bit_vector* ports, N16 port)
{
    if (ports == NULL)
    {
        return FALSE;
    }
    return bit_vector_is_set(ports, port);
}

PRIVATE NSAED_ACTION
plregex_inspect(const VOID *prot_config, VOID *prot_state, struct XMIB_FLOW_INFO *info)
{
    const NSAED_PLREGEX_CONFIG *config = prot_config;
    NSAED_PLREGEX_STATE *state = prot_state;
    N16 inspect_port = config->match_src_port ? SRC_PORT(info): DEST_PORT(info);
    BOOL port_matched = TRUE;

    switch (info->ip_parse_info.protocol)
    {
        case IPPROTO_TCP:
            port_matched = plregex_validate_port(config->tcp_ports, inspect_port);
            break;
        case IPPROTO_UDP:
            port_matched = plregex_validate_port(config->udp_ports, inspect_port);
            break;
        default:
            return NSAED_ACTION_NONE;
    }

    if (!port_matched)
    {
        return NSAED_ACTION_NONE;
    }

    #define PLREGEX_MATCH(regex, data, len) (data && nsaed_regex_match(regex, data, len))
    size_t hdr_len = info->ip_parse_info.ip_hdr_len;
    size_t payload_len = info->ip_parse_info.ip_payload_len;
    // Check IP header and payload if include_header = true
    BOOL match = config->include_headers ?
                PLREGEX_MATCH(config->regex, info->ip_hdr, hdr_len + payload_len):
                PLREGEX_MATCH(config->regex, info->l4_hdr, payload_len);
    if (match)
    {
        state->stats.stats_base.pkt_dropped++;
        state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
        return config->action;
    }

    return NSAED_ACTION_NONE;
}

PRIVATE VOID plregex_stat_dump(const VOID *c, const VOID *s)
{
    const NSAED_PLREGEX_STATE* state = s;
    if (state)
    {
        rcon_printf("Packets dropped by %s: %llu\n",
                PLREGEX_NAME, state->stats.stats_base.pkt_dropped);
        rcon_printf("L3 Bytes dropped by %s: %llu\n",
                PLREGEX_NAME, state->stats.stats_base.l3_byte_dropped);
    }
}

PRIVATE VOID plregex_stat_dump_json(cJSON* cj, const VOID *c, const VOID *s)
{
    const NSAED_PLREGEX_STATE* state = s;
    const NSAED_PLREGEX_STATS* stats = &state->stats;

    cJSON* dnsrl = cJSON_AddObjectToObject(cj, "payload_regex");
    cJSON_AddNumberToObject(dnsrl, "packets_dropped", stats->stats_base.pkt_dropped);
    cJSON_AddNumberToObject(dnsrl, "l3_bytes_dropped", stats->stats_base.l3_byte_dropped);
}

PRIVATE VOID plregex_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur)
{
    NSAED_PLREGEX_STATE* total = state_total;
    const NSAED_PLREGEX_STATE* cur = state_cur;
    total->stats.stats_base.pkt_dropped += cur->stats.stats_base.pkt_dropped;
    total->stats.stats_base.l3_byte_dropped += cur->stats.stats_base.l3_byte_dropped;
}

PRIVATE VOID* plregex_state_alloc()
{
    return calloc(1, sizeof(NSAED_PLREGEX_STATE));
}

PRIVATE VOID plregex_state_free(VOID *prot)
{
    free(prot);
}

PRIVATE VOID plregex_registered(N32 id)
{
    protection_id = id;
}

PRIVATE N32 plregex_get_protection_id()
{
    return protection_id;
}

#endif // ISNG_BASED_AED

#ifndef PROTECTION_H
#define PROTECTION_H
#if ISNG_BASED_AED
/************************************************************************
*                   W A R N I N G                                       *
*                   ~~~~~~~~~~~~~                                       *
*                   Copyright (c) 2024                                  *
*                   NetScout Systems, Inc.                              *
*                   Westford, MA 01886                                  *
*                   All Rights Reserved                                 *
*                                                                       *
* This software is part of Licensed material, which is the property     *
* of NetScout Systems, Inc.  Unauthorized use, duplication or           *
* distribution is strictly prohibited by Federal law.  No title to and  *
* ownership of this software is hereby transferred.                     *
*                                                                       *
************************************************************************/

/************************************************************************
*                                                                       *
* Module Name:  protection.h                                            *
* Component of: nsprobe AED                                             *
* Programmer:   Brian St. Pierre                                        *
*                                                                       *
* Description:                                                          *
*   Definitions for working with nsAED protections.                     *
*                                                                       *
* Revision History:                                                     *
*                                                                       *
* Vers  Date           Who             Why                              *
* 001   08 Mar 2024    bstpierre       Module Created                   *
*                                                                       *
************************************************************************/
#include "fsdstd.h"
#include "aed/action.h"

typedef struct NSAED_PG_CONFIG NSAED_PG_CONFIG;
typedef struct NSAED_PG_STATE NSAED_PG_STATE;
typedef struct NSAED_INSP_THREAD NSAED_INSP_THREAD;
struct NSAED_ROOT;
struct XMIB_FLOW_INFO;
typedef struct cJSON cJSON;

typedef VOID* (*NSAED_CONFIG_ALLOCATOR_F)();
typedef VOID (*NSAED_CONFIG_DEALLOCATOR_F)(VOID *protection);
typedef VOID (*NSAED_CONFIG_HANDLER_F)(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *json);
typedef BOOL (*NSAED_CONFIG_GET_BOOL_F)(VOID *prot_config);
typedef VOID (*NSAED_CONFIG_SET_BOOL_F)(VOID *prot_config, BOOL state);
typedef VOID (*NSAED_CONFIG_DUMPER_F)(const VOID *pg_config);
typedef VOID (*NSAED_CONFIG_LOADED_F)(const VOID *pg_config, VOID *pg_state, VOID *pg_shared_state);
typedef NSAED_ACTION (*NSAED_INSPECTOR_F)(const VOID *pg_config, VOID *pg_state, struct XMIB_FLOW_INFO*);
typedef VOID* (*NSAED_STATE_ALLOCATOR_F)();
typedef VOID (*NSAED_STATE_DEALLOCATOR_F)(VOID *protection);
typedef VOID* (*NSAED_STATE_SHARED_ALLOCATOR_F)();
typedef VOID (*NSAED_STATE_SHARED_DEALLOCATOR_F)(VOID *protection);
typedef VOID (*NSAED_STAT_DUMPER_F)(const VOID* config, const VOID* state);
typedef VOID (*NSAED_STAT_DUMPER_JSON_F)(cJSON*, const VOID* config, const VOID* state);
typedef VOID (*NSAED_STAT_ACCUMULATOR_F)(const VOID* config, VOID* state_total, const VOID* state_cur);
typedef VOID (*NSAED_REGISTERED_F)(UINT id);
typedef N32 (*NSAED_GET_PROTECTION_ID_F)();
typedef VOID (*NSAED_TICK_F)(const VOID* prot_config, VOID* prot_state, NSAED_PG_STATE *pg_state, NSAED_INSP_THREAD *it);

#define IS_PROTECTION_ENABLED(state) (state == TRUE) ? "True": "False"
#define L3_BYTES(info) (info->ip_parse_info.ip_hdr_len + info->ip_parse_info.ip_payload_len)

#define NSAED_FEATURE_GEOIP (1 << 0L)
#define NSAED_FEATURE_REVERSE_CLASS (1 << 1L)
#define NSAED_FEATURE_SRCSTATE (1 << 2L)
#define NSAED_FEATURE_SOCKET (1 << 3L)

typedef struct NSAED_PROTECTION
{
    const TEXT *name;

    // features allows a protection to set which features are required at the PG
    // level.
    N32 features;

    // srcstate_blocksize should store the blocksize of the srcstate
    // for the protection.
    const N32 srcstate_blocksize;

    // srcstate_blocksize should store the blocksize of the sktcache
    // for the protection.
    const N32 sktcache_blocksize;

    // config_allocator returns a heap-allocated block of memory containing
    // config for this protection. Generally this is a pointer to an opaque
    // config struct defined by the protection. All fields must be
    // initialized to good values. NULL return is considered an error.
    //
    // Naming: PRIVATE VOID* <prefix>_config_alloc();
    NSAED_CONFIG_ALLOCATOR_F config_allocator;

    // config_deallocator frees an object previously allocated by
    // `config_allocator` for this protection. Must recursively free any
    // sub-objects that were allocated. Must handle a NULL input.
    //
    // Naming: PRIVATE VOID <prefix>_config_free(VOID*);
    NSAED_CONFIG_DEALLOCATOR_F config_deallocator;

    // config_handler takes pg config, protection config, and a pointer to
    // a json config object for this protection. It loads values from the
    // json object into the protection object. It may alter the pg config
    // if needed (for example, to set reverse classification.) Should be
    // robust to missing values in the json (provide defaults as
    // appropriate). Should perform minimal validation of json inputs
    // (avoid crashes but don't add too many guardrails).
    //
    // Naming: PRIVATE VOID <prefix>_config_handler(NSAED_PG_CONFIG*, VOID *, cJSON *)
    NSAED_CONFIG_HANDLER_F config_handler;

    // config_dumper generates brief output of this protection's config
    // values to `rcon_printf` (localconsole). Mandatory first line of
    // output is "<protection name>: <enabled|disabled>\n". Config values
    // should only be dumped if the protection is enabled.
    //
    // Naming: PRIVATE VOID <prefix>_config_dump(const VOID *)
    NSAED_CONFIG_DUMPER_F config_dumper;

    // config_get_enabled can be used to test if a given config is enabled
    // or not from outside the given protection. This function is invoked with
    // a pointer to the protection's config.
    //
    // Naming: PRIVATE BOOL <prefix>_config_get_enabled(const VOID *config)
    NSAED_CONFIG_GET_BOOL_F config_get_enabled;

    // config_set_enabled can be used to set if a given config is enabled
    // or not from outside the given protection. This function is invoked with
    // a pointer to the protection's config and the enabled state to set.
    //
    // Naming: PRIVATE BOOL <prefix>_config_set_enabled(VOID *config, BOOL state)
    NSAED_CONFIG_SET_BOOL_F config_set_enabled;

    // config_loaded is called after all config has been fully loaded and
    // PG state has been synchronized. The function is invoked with
    // pointers to the protection's config, state, and shared state, and gives
    // the protection a chance to sync its internal config, internal state, and
    // shared state. This function is optional; if NULL it will be ignored.
    //
    // If the protection does not use shared state, that pointer will be NULL.
    //
    // Naming: PRIVATE VOID <prefix>_config_loaded(const VOID *config, VOID *state, VOID *shared)
    NSAED_CONFIG_LOADED_F config_loaded;

    // inspector is called for every packet. It is passed the protection's
    // config, state, and XMIB_FLOW_INFO* for the packet. It must check the
    // packet and return an NSAED_ACTION. If the protection is disabled in
    // the config, it must return NSAED_ACTION_NONE.
    //
    // Naming: PRIVATE NSAED_ACTION <prefix>_inspect(const VOID* c, VOID* s, XMIB_FLOW_INFO*)
    NSAED_INSPECTOR_F inspector;

    // stat_dumper generates brief stat output to `rcon_printf`
    // (localconsole). The function is passed a pointer to protection
    // state. Lines should be (roughly) in the form of "Packets
    // <dropped|forwarded> by <Protection Name>: NNN\n".
    //
    // Naming: PRIVATE VOID <prefix>_stat_dump(const VOID *s)
    NSAED_STAT_DUMPER_F stat_dumper;

    // stat_dumper_json generates json objects representing this
    // protection's stat info. It receives pointers to an existing json
    // object (the parent stats object) and the protection's state. It
    // should add a json object to the parent using this protection's
    // code prefix as the key, and then add keys to that object with
    // numeric stat values. Keys should be (roughly) in the form
    // "packets_<dropped|forwarded>".
    //
    // Naming: PRIVATE VOID <prefix>_stat_dump_json(cJSON*, const VOID*)
    NSAED_STAT_DUMPER_JSON_F stat_dumper_json;

    // stat_accumulator is used to sum several of this protection's stat
    // struct into a single struct: generally for summing several threads'
    // worth of information into a summary object. It receives two pointers
    // to the protection's state: the accumulator (non const) and the stats
    // to add (const). It should add the latter's counters to the former.
    //
    // Naming: PRIVATE VOID <prefix>_stat_add(VOID* state_total, const VOID* state_cur)
    NSAED_STAT_ACCUMULATOR_F stat_accumulator;

    // state_allocator returns a heap-allocated block of memory containing
    // state for this protection. Generally this is a pointer to an opaque
    // state struct defined by the protection. All fields must be
    // initialized to good values. NULL return is considered an error.
    //
    // Naming: PRIVATE VOID* <prefix>_state_alloc()
    NSAED_STATE_ALLOCATOR_F state_allocator;

    // state_deallocator frees an object previously allocated by
    // `state_allocator` for this protection. Must recursively free any
    // sub-objects that were allocated. Must handle a NULL input.
    //
    // Naming: PRIVATE VOID <prefix>_state_free(VOID *prot)
    NSAED_STATE_DEALLOCATOR_F state_deallocator;

    // state_shared_allocator returns a heap-allocated block of memory
    // containing shared state for this protection. Generally this is a
    // pointer to an opaque state struct defined by the protection. All
    // fields must be initialized to good values. NULL return is considered
    // an error.
    //
    // Naming: PRIVATE VOID* <prefix>_state_shared_alloc()
    NSAED_STATE_SHARED_ALLOCATOR_F state_shared_allocator;

    // state_shared_deallocator frees an object previously allocated by
    // `state_shared_allocator` for this protection. Must recursively free
    // any sub-objects that were allocated. Must handle a NULL input.
    //
    // Naming: PRIVATE VOID <prefix>_state_shared_free(VOID *prot)
    NSAED_STATE_SHARED_DEALLOCATOR_F state_shared_deallocator;

    // registered() will be called to let the protection know what it's ID is at
    // runtime. The protection should save this ID such that it can reference it
    // later when doing lookups in the TBHL.
    //
    // Naming: PRIVATE VOID <prefix>_registered(N32 id)
    NSAED_REGISTERED_F registered;

    // get_protection_id() should return the ID assigned to this protection with
    // the registered() function above.
    //
    // Naming: PRIVATE VOID <prefix>_get_protection_id()
    NSAED_GET_PROTECTION_ID_F get_protection_id;

    // tick() will be called when the thread timer expires.
    //
    // Naming: PRIVATE VOID <prefix>_tick()
    NSAED_TICK_F tick;
} NSAED_PROTECTION;

typedef struct {
    atomic_uint_fast64_t pkt_dropped;
    atomic_uint_fast64_t l3_byte_dropped;
} NSAED_PROTECTION_STATS_BASE;

IMPORT const NSAED_PROTECTION connlimit_protection;
IMPORT const NSAED_PROTECTION connreset_protection;
IMPORT const NSAED_PROTECTION dns_ndqf_protection;
IMPORT const NSAED_PROTECTION dns_ra_protection;
IMPORT const NSAED_PROTECTION dns_regex_protection;
IMPORT const NSAED_PROTECTION dnsform_protection;
IMPORT const NSAED_PROTECTION dnsrl_protection;
IMPORT const NSAED_PROTECTION fcap_filtering_protection;
IMPORT const NSAED_PROTECTION geoipfilter_protection;
IMPORT const NSAED_PROTECTION geoiprate_protection;
IMPORT const NSAED_PROTECTION ip_filtering_protection;
IMPORT const NSAED_PROTECTION ip_reputation_protection;
IMPORT const NSAED_PROTECTION malformed_protection;
IMPORT const NSAED_PROTECTION plregex_protection;
IMPORT const NSAED_PROTECTION ratelimit_protection;
IMPORT const NSAED_PROTECTION synackflood_protection;
IMPORT const NSAED_PROTECTION synflood_protection;
IMPORT const NSAED_PROTECTION tcpflood_protection;
IMPORT const NSAED_PROTECTION zombie_protection;

#endif // ISNG_BASED_AED
#endif // PROTECTION_H
#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2024                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
*                                                                       *
************************************************************************/

#include <inttypes.h>
#include "eventlog.h"
#include "aed/aed.h"
#include "aed/aedmacros.h"
#include "aed/cJSON.h"
#include "aed/tokenshare.h"
#include "xmibflow.h"
#include "aed/arf/api.h"

#define RATELIMIT_NAME "Traffic Rate Limiting"
#define RATELIMIT_ELEMENT_NAME "ratelimit"

typedef struct
{
    BOOL enabled;
    TEXT *arf_id;
    arf_t *arf;
    N64  pps;
    N64  bps;
} NSAED_RATELIMIT_CONFIG;

typedef struct
{
    NSAED_PROTECTION_STATS_BASE stats_base;
} NSAED_RATELIMIT_STATS;

typedef struct
{
    tokenshare rate_pps;
    tokenshare rate_bps;
} NSAED_RATELIMIT_STATE_SHARED;

typedef struct
{
    NSAED_RATELIMIT_STATS stats;
    NSAED_RATELIMIT_STATE_SHARED *shared;
    arf_t *arf;
    arf_handle_t *arf_handle;
} NSAED_RATELIMIT_STATE;


PRIVATE VOID* ratelimit_config_alloc();
PRIVATE VOID ratelimit_config_dump(const VOID *prot_config);
PRIVATE VOID ratelimit_config_free(VOID *prot);
PRIVATE BOOL ratelimit_config_get_enabled(VOID *prot_config);
PRIVATE VOID ratelimit_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *json);
PRIVATE VOID ratelimit_config_loaded(const VOID *pg_config, VOID *pg_state, VOID *shared_state);
PRIVATE VOID ratelimit_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE N32 ratelimit_get_protection_id();
PRIVATE NSAED_ACTION ratelimit_inspect(const VOID *prot_config, VOID *prot_state, XMIB_FLOW_INFO *info);
PRIVATE VOID ratelimit_registered(N32 id);
PRIVATE VOID ratelimit_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur);
PRIVATE VOID ratelimit_stat_dump(const VOID *config, const VOID* state);
PRIVATE VOID ratelimit_stat_dump_json(cJSON*, const VOID *config, const VOID* state);
PRIVATE VOID* ratelimit_state_alloc();
PRIVATE VOID ratelimit_state_free(VOID *prot);
PRIVATE VOID* ratelimit_state_shared_alloc();
PRIVATE VOID ratelimit_state_shared_free(VOID *shared);

EXPORT const NSAED_PROTECTION ratelimit_protection = {
    .name = RATELIMIT_ELEMENT_NAME,

    .config_allocator = ratelimit_config_alloc,
    .config_deallocator = ratelimit_config_free,
    .config_dumper = ratelimit_config_dump,
    .config_get_enabled = ratelimit_config_get_enabled,
    .config_handler = ratelimit_config_handler,
    .config_loaded = ratelimit_config_loaded,
    .config_set_enabled = ratelimit_config_set_enabled,
    .get_protection_id = ratelimit_get_protection_id,
    .inspector = ratelimit_inspect,
    .registered = ratelimit_registered,
    .stat_accumulator = ratelimit_stat_add,
    .stat_dumper = ratelimit_stat_dump,
    .stat_dumper_json = ratelimit_stat_dump_json,
    .state_allocator = ratelimit_state_alloc,
    .state_deallocator = ratelimit_state_free,
    .state_shared_allocator = ratelimit_state_shared_alloc,
    .state_shared_deallocator = ratelimit_state_shared_free,
};

PRIVATE N32 protection_id = 0;

PRIVATE VOID* ratelimit_config_alloc()
{
    return calloc(1, sizeof(NSAED_RATELIMIT_CONFIG));
}

PRIVATE VOID ratelimit_config_dump(const VOID *c)
{
    const NSAED_RATELIMIT_CONFIG* config = c;
    rcon_printf("%s\n  Enabled: %s\n", RATELIMIT_NAME,
        IS_PROTECTION_ENABLED(config->enabled));
    if (!config->enabled)
    {
        return;
    }
    rcon_printf("  ARF ID: %s\n", config->arf_id);
    rcon_printf("  PPS: %" PRIu64 "\n", config->pps);
    rcon_printf("  BPS: %" PRIu64 "\n", config->bps);
}

PRIVATE VOID ratelimit_config_free(VOID *prot)
{
    NSAED_RATELIMIT_CONFIG *config = (NSAED_RATELIMIT_CONFIG*)prot;
    if (config == NULL)
    {
        return;
    }
    if (config->arf != NULL)
    {
        arf_release(&config->arf);
    }
    if (config->arf_id)
    {
        free(config->arf_id);
    }
    free(config);
}

PRIVATE BOOL ratelimit_config_get_enabled(VOID *prot_config)
{
    NSAED_RATELIMIT_CONFIG *config = prot_config;
    return config->enabled;
}

PRIVATE VOID ratelimit_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *ratelimit_json)
{
    NSAED_RATELIMIT_CONFIG *config = prot_config;
    cJSON *arf_id_json = cJSON_GetObjectItemCaseSensitive(ratelimit_json, "arf_id");
    if (arf_id_json && cJSON_IsString(arf_id_json))
    {
        TEXT *arf_id = cJSON_GetStringValue(arf_id_json);
        config->arf = arf_get(arf_id, pg_config_get_ip_version(pg_config));
        if (config->arf != NULL)
        {
            log_event(BOTH_LOG, "#NSAED-CFG %s loaded \"%s\"", RATELIMIT_NAME, arf_id);
            config->arf_id = strdup(arf_id);  // save for config dump
        }
        else
        {
            log_event(BOTH_LOG, "#NSAED-CFG %s load \"%s\" failed", RATELIMIT_NAME, arf_id);
        }
    }
    cJSON *pps_json = cJSON_GetObjectItemCaseSensitive(ratelimit_json, "pps");
    if (pps_json && cJSON_IsNumber(pps_json))
    {
        config->pps = cJSON_GetNumberValue(pps_json);
    }
    cJSON *bps_json = cJSON_GetObjectItemCaseSensitive(ratelimit_json, "bps");
    if (bps_json && cJSON_IsNumber(bps_json))
    {
        config->bps = cJSON_GetNumberValue(bps_json);
    }
}

PRIVATE VOID ratelimit_config_loaded(const VOID *prot_config, VOID *prot_state, VOID *sh)
{
    NSAED_RATELIMIT_CONFIG *config = (NSAED_RATELIMIT_CONFIG*)prot_config;
    NSAED_RATELIMIT_STATE *state = (NSAED_RATELIMIT_STATE*)prot_state;
    NSAED_RATELIMIT_STATE_SHARED *shared = sh;
    state->shared = shared;

    if (config->arf != state->arf)
    {
        // arf has changed, release the current arf handle
        if (state->arf_handle != NULL)
        {
            arf_release_handle(&state->arf_handle);
            state->arf = NULL;
        }

        if (config->arf != NULL)
        {
            state->arf_handle = arf_get_handle(config->arf);
            if (state->arf_handle != NULL)
            {
                // save the arf pointer for next config state syncing
                state->arf = config->arf;
            }
            else
            {
                log_event(BOTH_LOG, "#NSAED-CFG-STATE-SYNCING %s create arf "
                        "handle for \"%s\" failed", RATELIMIT_ELEMENT_NAME, config->arf_id);
            }
        }
    }
}

PRIVATE VOID ratelimit_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_RATELIMIT_CONFIG *config = prot_config;
    config->enabled = state;
}

PRIVATE N32 ratelimit_get_protection_id()
{
    return protection_id;
}

PRIVATE NSAED_ACTION ratelimit_inspect(const VOID *c, VOID *s, XMIB_FLOW_INFO *info)
{
    const NSAED_RATELIMIT_CONFIG* config = c;
    NSAED_RATELIMIT_STATE* state = s;
    N32 tag_id;

    if (state->arf_handle != NULL &&
        arf_match_flow_info(state->arf_handle, info, &tag_id) == NSAED_ACTION_NONE)
    {
        // FCAP configured, but packet doesn't match, so skip rate-limiting.
        return NSAED_ACTION_NONE;
    }

    if (config->bps)
    {
        N32 ip_len = info->ip_parse_info.ip_hdr_len + info->ip_parse_info.ip_payload_len;
        tokenshare_fill(&state->shared->rate_bps, info->frame_time_us, config->bps / 8, config->bps / 8);
        if (tokenshare_consume(&state->shared->rate_bps, ip_len))
        {
            // Not enough tokens: drop the packet.
            state->stats.stats_base.pkt_dropped++;
            state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
            return NSAED_ACTION_DROP;
        }
    }

    if (config->pps)
    {
        tokenshare_fill(&state->shared->rate_pps, info->frame_time_us, config->pps, config->pps);
        if (tokenshare_consume(&state->shared->rate_pps, 1))
        {
            // Not enough tokens: drop the packet.
            state->stats.stats_base.pkt_dropped++;
            state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
            return NSAED_ACTION_DROP;
        }
    }
    return NSAED_ACTION_NONE;
}

PRIVATE VOID ratelimit_registered(N32 id)
{
    protection_id = id;
}

PRIVATE VOID ratelimit_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur)
{
    NSAED_RATELIMIT_STATE* total = state_total;
    const NSAED_RATELIMIT_STATE* cur = state_cur;
    total->stats.stats_base.pkt_dropped += cur->stats.stats_base.pkt_dropped;
    total->stats.stats_base.l3_byte_dropped += cur->stats.stats_base.l3_byte_dropped;
}

PRIVATE VOID ratelimit_stat_dump(const VOID *c, const VOID *s)
{
    const NSAED_RATELIMIT_STATE* state = s;
    if (state)
    {
        rcon_printf("Packets dropped by %s: %llu\n",
                RATELIMIT_NAME, state->stats.stats_base.pkt_dropped);
        rcon_printf("L3 Bytes dropped by %s: %llu\n",
                RATELIMIT_NAME, state->stats.stats_base.l3_byte_dropped);
    }
}

PRIVATE VOID ratelimit_stat_dump_json(cJSON* cj, const VOID *c, const VOID *s)
{
    const NSAED_RATELIMIT_STATE* state = s;
    const NSAED_RATELIMIT_STATS* stats = &state->stats;

    cJSON* ratelimit = cJSON_AddObjectToObject(cj, RATELIMIT_ELEMENT_NAME);
    cJSON_AddNumberToObject(ratelimit, "packets_dropped", stats->stats_base.pkt_dropped);
    cJSON_AddNumberToObject(ratelimit, "l3_bytes_dropped", stats->stats_base.l3_byte_dropped);
}

PRIVATE VOID* ratelimit_state_alloc()
{
    return calloc(1, sizeof(NSAED_RATELIMIT_STATE));
}

PRIVATE VOID ratelimit_state_free(VOID *prot)
{
    NSAED_RATELIMIT_STATE *state = (NSAED_RATELIMIT_STATE *)prot;
    // DO NOT destry or release the arf_t, it's owned by the config thread
    // and is only for determining if a new arf handle is needed.
    if (state->arf_handle != NULL)
    {
        arf_release_handle(&state->arf_handle);
    }
    free(state);
}

PRIVATE VOID* ratelimit_state_shared_alloc()
{
    NSAED_RATELIMIT_STATE_SHARED *s = NULL;
    if (posix_memalign((VOID**)&s, sizeof(tokenshare), sizeof(NSAED_RATELIMIT_STATE_SHARED)) != 0)
    {
        return NULL;
    }
    memset(s, 0, sizeof(NSAED_RATELIMIT_STATE_SHARED));
    return s;
}

PRIVATE VOID ratelimit_state_shared_free(VOID *shared)
{
    free(shared);
}

#endif // ISNG_BASED_AED
connlimit.c
connreset.c
dnsform.c
dnsrl.c
dns_ndqf.c
dns_ra.c
dns_regex.c
fcap_filtering.c
geoipfilter.c
geoiprate.c
ip_filtering.c
ip_reputation.c
malformed.c
plregex.c
ratelimit.c
synackflood.c
synflood.c
tcpflood.c
zombie.c
#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2025                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
*                                                                       *
************************************************************************/
#include <netinet/ip.h>
#include <netinet/ip6.h>
#include <netinet/tcp.h>

#include "eventlog.h"
#include "aed/aed.h"
#include "aed/aedmacros.h"
#include "aed/cJSON.h"
#include "aed/foundation/aging_bloom_filter.h"
#include "aed/foundation/hash_functions.h"
#include "ppformat.h"
#include "xmibflow.h"

#define SYNACKFLOOD_NAME "TCP SYNACK Flooding"
#define SYNACKFLOOD_ELEMENT_NAME "synackflood"

IMPORT N32 currentUpTimeMSec;

typedef struct
{
    BOOL enabled;
    N32 aging;
    N32 capacity;
    N32 precision;
} NSAED_SYNACKFLOOD_CONFIG;

typedef struct
{
    NSAED_PROTECTION_STATS_BASE stats_base;
} NSAED_SYNACKFLOOD_STATS;

typedef struct
{
    NSAED_SYNACKFLOOD_STATS stats;
    BOOL warmed_up;
    struct aging_bloom_filter *bfilter;
} NSAED_SYNACKFLOOD_STATE;

PRIVATE VOID* synackflood_config_alloc();
PRIVATE VOID synackflood_config_dump(const VOID *prot_config);
PRIVATE VOID synackflood_config_free(VOID *prot);
PRIVATE BOOL synackflood_config_get_enabled(VOID *prot_config);
PRIVATE VOID synackflood_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *json);
PRIVATE VOID synackflood_config_loaded(const VOID *pg_config, VOID *pg_state, VOID *shared_state);
PRIVATE VOID synackflood_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE N32 synackflood_get_protection_id();
PRIVATE NSAED_ACTION synackflood_inspect(const VOID *prot_config, VOID *prot_state, XMIB_FLOW_INFO *info);
PRIVATE VOID synackflood_registered(N32 id);
PRIVATE VOID synackflood_tick(const VOID *prot_config, VOID *prot_state, NSAED_PG_STATE *pg_state, NSAED_INSP_THREAD *);
PRIVATE VOID synackflood_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur);
PRIVATE VOID synackflood_stat_dump(const VOID *config, const VOID* state);
PRIVATE VOID synackflood_stat_dump_json(cJSON*, const VOID *config, const VOID* state);
PRIVATE VOID* synackflood_state_alloc();
PRIVATE VOID synackflood_state_free(VOID *prot);

PRIVATE VOID on_outbound(NSAED_SYNACKFLOOD_STATE *state, XMIB_FLOW_INFO *info);
PRIVATE NSAED_ACTION on_inbound(NSAED_SYNACKFLOOD_STATE *state, XMIB_FLOW_INFO* info);

EXPORT const NSAED_PROTECTION synackflood_protection = {
    .name = SYNACKFLOOD_ELEMENT_NAME,
    .features = NSAED_FEATURE_REVERSE_CLASS,

    .config_allocator = synackflood_config_alloc,
    .config_deallocator = synackflood_config_free,
    .config_dumper = synackflood_config_dump,
    .config_get_enabled = synackflood_config_get_enabled,
    .config_handler = synackflood_config_handler,
    .config_loaded = synackflood_config_loaded,
    .config_set_enabled = synackflood_config_set_enabled,
    .get_protection_id = synackflood_get_protection_id,
    .inspector = synackflood_inspect,
    .registered = synackflood_registered,
    .stat_accumulator = synackflood_stat_add,
    .stat_dumper = synackflood_stat_dump,
    .stat_dumper_json = synackflood_stat_dump_json,
    .state_allocator = synackflood_state_alloc,
    .state_deallocator = synackflood_state_free,
    .tick = synackflood_tick,
};

PRIVATE N32 protection_id = 0;

PRIVATE VOID* synackflood_config_alloc()
{
    return calloc(1, sizeof(NSAED_SYNACKFLOOD_CONFIG));
}

PRIVATE VOID synackflood_config_dump(const VOID *c)
{
    const NSAED_SYNACKFLOOD_CONFIG* config = c;

    rcon_printf("%s\n  Enabled: %s\n", SYNACKFLOOD_NAME,
        IS_PROTECTION_ENABLED(config->enabled));
    if (config->enabled)
    {
        rcon_printf("  Aging: %u\n", config->aging);
        rcon_printf("  Capacity: %u\n", config->capacity);
        rcon_printf("  Precision: %u\n", config->precision);
    }
}

PRIVATE VOID synackflood_config_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    free(prot);
}

PRIVATE BOOL synackflood_config_get_enabled(VOID *prot_config)
{
    NSAED_SYNACKFLOOD_CONFIG *config = prot_config;
    return config->enabled;
}

PRIVATE VOID synackflood_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *synackflood_json)
{
    NSAED_SYNACKFLOOD_CONFIG *config = prot_config;
    cJSON *aging = cJSON_GetObjectItemCaseSensitive(synackflood_json, "aging");
    cJSON *capacity = cJSON_GetObjectItemCaseSensitive(synackflood_json, "capacity");
    cJSON *precision = cJSON_GetObjectItemCaseSensitive(synackflood_json, "precision");

    config->aging = 60;
    config->capacity = 1000000;
    config->precision = 3;

    if (aging && cJSON_IsNumber(aging))
    {
        config->aging = (INT)cJSON_GetNumberValue(aging);
    }

    if (capacity && cJSON_IsNumber(capacity))
    {
        config->capacity = (INT)cJSON_GetNumberValue(capacity);
    }

    if (precision && cJSON_IsNumber(precision))
    {
        config->precision = (INT)cJSON_GetNumberValue(precision);
    }
}

PRIVATE VOID synackflood_config_loaded(const VOID *prot_config, VOID *prot_state, VOID *shared_state)
{
    const NSAED_SYNACKFLOOD_CONFIG *config = prot_config;
    NSAED_SYNACKFLOOD_STATE *state = prot_state;
    if (state->bfilter == NULL)
    {
        state->bfilter = aging_bloom_filter_create(config->capacity, config->precision, config->aging * 1000ULL);
        if (state->bfilter == NULL)
        {
            log_event(BOTH_LOG, "#NSAED-SYNACK: failed to allocate bloom filter");
            exit(1);
        }
    }
    else
    {
        aging_bloom_filter_set_params(state->bfilter, config->capacity, config->precision, config->aging * 1000ULL);
    }
}

PRIVATE VOID synackflood_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_SYNACKFLOOD_CONFIG *config = prot_config;
    config->enabled = state;
}

PRIVATE N32 synackflood_get_protection_id()
{
    return protection_id;
}

PRIVATE NSAED_ACTION synackflood_inspect(const VOID *c, VOID *s, XMIB_FLOW_INFO *info)
{
    NSAED_SYNACKFLOOD_STATE* state = s;
    NSAED_ACTION action = NSAED_ACTION_NONE;
    BOOL outbound;

    if (info->ip_parse_info.protocol != IPPROTO_TCP)
    {
        return action;   // not a TCP packet
    }

    outbound = !nsaed_is_external_ifn(info->orig_ifn);

    if (outbound)
    {
        on_outbound(state, info);
    }
    else if (state->warmed_up)
    {
        action = on_inbound(state, info);
    }
    return action;
}

PRIVATE VOID on_outbound(NSAED_SYNACKFLOOD_STATE *state, XMIB_FLOW_INFO *info)
{
    if ((info->tcp_flags & (TCP_SYN | TCP_ACK)) == TCP_SYN)
    {
        N32 h1 = hash_four_tuple(&info->ip_parse_info, inline_mixer32_hash, TRUE);
        N32 h2 = hash_four_tuple(&info->ip_parse_info, fnv1a_hash, TRUE);
        aging_bloom_filter_set(state->bfilter, h1, h2);
    }

}

PRIVATE NSAED_ACTION on_inbound(NSAED_SYNACKFLOOD_STATE *state, XMIB_FLOW_INFO* info)
{
    if ((info->tcp_flags & (TCP_SYN | TCP_ACK)) == (TCP_SYN | TCP_ACK))
    {
        N32 h1 = hash_four_tuple(&info->ip_parse_info, inline_mixer32_hash, FALSE);
        N32 h2 = hash_four_tuple(&info->ip_parse_info, fnv1a_hash, FALSE);
        if (!aging_bloom_filter_search(state->bfilter, h1, h2))
        {
            state->stats.stats_base.pkt_dropped += 1;
            state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
            return NSAED_ACTION_DROP;
        }
    }
    return NSAED_ACTION_NONE;
}

PRIVATE VOID synackflood_registered(N32 id)
{
    protection_id = id;
}

PRIVATE VOID synackflood_tick(const VOID *prot_config, VOID *prot_state, NSAED_PG_STATE *pg_state, NSAED_INSP_THREAD *)
{
    NSAED_SYNACKFLOOD_STATE *state = prot_state;
    ABF_AGEOUT_RESULT result = aging_bloom_filter_ageout(state->bfilter, currentUpTimeMSec);
    if (result == ABF_AGEOUT_NO_MEMORY)
    {
        log_event(BOTH_LOG, "#NSAED-SYNACKFLOOD: failed to allocate bloom filter");
        exit(1);
    }
    state->warmed_up = (state->warmed_up || result == ABF_AGEOUT_EXPIRED);
}

PRIVATE VOID synackflood_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur)
{
    NSAED_SYNACKFLOOD_STATE* total = state_total;
    const NSAED_SYNACKFLOOD_STATE* cur = state_cur;
    total->stats.stats_base.pkt_dropped += cur->stats.stats_base.pkt_dropped;
    total->stats.stats_base.l3_byte_dropped += cur->stats.stats_base.l3_byte_dropped;
}

PRIVATE VOID synackflood_stat_dump(const VOID *c, const VOID *s)
{
    const NSAED_SYNACKFLOOD_STATE* state = s;
    if (state)
    {
        rcon_printf("Packets dropped by %s: %llu\n",
                SYNACKFLOOD_NAME, state->stats.stats_base.pkt_dropped);
        rcon_printf("L3 Bytes dropped by %s: %llu\n",
                SYNACKFLOOD_NAME, state->stats.stats_base.l3_byte_dropped);
    }
}

PRIVATE VOID synackflood_stat_dump_json(cJSON* cj, const VOID *c, const VOID *s)
{
    const NSAED_SYNACKFLOOD_STATE* state = s;
    const NSAED_SYNACKFLOOD_STATS* stats = &state->stats;

    cJSON* synackflood = cJSON_AddObjectToObject(cj, SYNACKFLOOD_ELEMENT_NAME);
    cJSON_AddNumberToObject(synackflood, "packets_dropped", stats->stats_base.pkt_dropped);
    cJSON_AddNumberToObject(synackflood, "l3_bytes_dropped", stats->stats_base.l3_byte_dropped);
}

PRIVATE VOID* synackflood_state_alloc()
{
    return calloc(1, sizeof(NSAED_SYNACKFLOOD_STATE));
}

PRIVATE VOID synackflood_state_free(VOID *prot)
{
    free(prot);
}
#endif // ISNG_BASED_AED
#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2024                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
*                                                                       *
************************************************************************/

#include <netinet/ip.h>
#include <netinet/ip6.h>
#include <netinet/tcp.h>

#include "cksum.h"
#include "eventlog.h"
#include "ppformat.h"
#include "xmibflow.h"
#include "aed/aed.h"
#include "aed/aedmacros.h"
#include "aed/cJSON.h"
#include "aed/foundation/aging_bloom_filter.h"
#include "aed/foundation/hash_functions.h"

IMPORT N32 currentUpTimeMSec;

#define SYNFLOOD_NAME "Spoofed SYN Flood Prevention"
#define SYNFLOOD_ELEMENT_NAME "synflood"

// default config for the bloom filters
#define SYNFLOOD_CHALLENGED_AGING 5     // in seconds
#define SYNFLOOD_CHALLENGED_CAPACITY 1000000
#define SYNFLOOD_CHALLENGED_PRECISION 4
#define SYNFLOOD_AUTHENTICATED_AGING 60
#define SYNFLOOD_AUTHENTICATED_CAPACITY 4000000
#define SYNFLOOD_AUTHENTICATED_PRECISION 4

typedef struct
{
    N32 aging_ms;
    N32 capacity;
    N32 precision;
} NSAED_SYNFLOOD_BLOOM_CONFIG;

typedef struct
{
    BOOL enabled;
    NSAED_SYNFLOOD_BLOOM_CONFIG challenged;
    NSAED_SYNFLOOD_BLOOM_CONFIG authenticated;
} NSAED_SYNFLOOD_CONFIG;

typedef struct
{
    NSAED_PROTECTION_STATS_BASE stats_base;
    N64 syn_challenged;
    N64 src_authenticated;
} NSAED_SYNFLOOD_STATS;

typedef struct
{
    NSAED_SYNFLOOD_STATS stats;
    struct aging_bloom_filter *challenged;
    struct aging_bloom_filter *authenticated;
    N32 salt[2];
    // idx flips every time a new salt is generated - can be only 0 or 1
    N8 current_salt_idx;
} NSAED_SYNFLOOD_STATE;

// packed struct to hold the 4-tuple, sequence number, and salt
#pragma pack(push, 1) // Ensure no padding in the struct
typedef struct {
    N32 src_addr;
    N32 dest_addr;
    N32 tcp_seq;
    N32 salt;
    N16 src_port;
    N16 dest_port;
} SYNCOOKIE_DATA_IPV4;

typedef struct {
    IPV6_ADDR src_addr;
    IPV6_ADDR dest_addr;
    N32 tcp_seq;
    N32 salt;
    N16 src_port;
    N16 dest_port;
} SYNCOOKIE_DATA_IPV6;
#pragma pack(pop)

PRIVATE VOID* synflood_config_alloc();
PRIVATE VOID synflood_config_dump(const VOID *prot_config);
PRIVATE VOID synflood_config_free(VOID *prot);
PRIVATE BOOL synflood_config_get_enabled(VOID *prot_config);
PRIVATE VOID synflood_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *json);
PRIVATE VOID synflood_config_loaded(const VOID *pg_config, VOID *pg_state, VOID *shared_state);
PRIVATE VOID synflood_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE N32 synflood_get_protection_id();
PRIVATE NSAED_ACTION synflood_inspect(const VOID *prot_config, VOID *prot_state, XMIB_FLOW_INFO *info);
PRIVATE VOID synflood_registered(N32 id);
PRIVATE VOID synflood_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur);
PRIVATE VOID synflood_stat_dump(const VOID *config, const VOID* state);
PRIVATE VOID synflood_stat_dump_json(cJSON*, const VOID *config, const VOID* state);
PRIVATE VOID* synflood_state_alloc();
PRIVATE VOID synflood_state_free(VOID *prot);
PRIVATE VOID synflood_tick(const VOID *prot_config, VOID *prot_state, NSAED_PG_STATE *pg_state, NSAED_INSP_THREAD *);

EXPORT const NSAED_PROTECTION synflood_protection = {
    .name = SYNFLOOD_ELEMENT_NAME,

    .config_allocator = synflood_config_alloc,
    .config_deallocator = synflood_config_free,
    .config_dumper = synflood_config_dump,
    .config_get_enabled = synflood_config_get_enabled,
    .config_handler = synflood_config_handler,
    .config_loaded = synflood_config_loaded,
    .config_set_enabled = synflood_config_set_enabled,
    .get_protection_id = synflood_get_protection_id,
    .inspector = synflood_inspect,
    .registered = synflood_registered,
    .stat_accumulator = synflood_stat_add,
    .stat_dumper = synflood_stat_dump,
    .stat_dumper_json = synflood_stat_dump_json,
    .state_allocator = synflood_state_alloc,
    .state_deallocator = synflood_state_free,
    .tick = synflood_tick,
};

PRIVATE N32 protection_id = 0;

PRIVATE VOID* synflood_config_alloc()
{
    NSAED_SYNFLOOD_CONFIG *config = calloc(1, sizeof(NSAED_SYNFLOOD_CONFIG));
    if (config != NULL)
    {
        config->challenged.aging_ms = SYNFLOOD_CHALLENGED_AGING * 1000;
        config->challenged.capacity = SYNFLOOD_CHALLENGED_CAPACITY;
        config->challenged.precision = SYNFLOOD_CHALLENGED_PRECISION;
        config->authenticated.aging_ms = SYNFLOOD_AUTHENTICATED_AGING * 1000;
        config->authenticated.capacity = SYNFLOOD_AUTHENTICATED_CAPACITY;
        config->authenticated.precision = SYNFLOOD_AUTHENTICATED_PRECISION;
    }
    return config;
}

PRIVATE INLINE VOID bloom_config_dump(const NSAED_SYNFLOOD_BLOOM_CONFIG *bcfg, const char *name)
{
}

PRIVATE VOID synflood_config_dump(const VOID *c)
{
    const NSAED_SYNFLOOD_CONFIG* config = c;
    rcon_printf("%s\n  Enabled: %s\n", SYNFLOOD_NAME,
        IS_PROTECTION_ENABLED(config->enabled));
    if (!config->enabled)
    {
        return;
    }
    rcon_printf("  Challenged aging: %u seconds\n",
        config->challenged.aging_ms / 1000);
    rcon_printf("  Challenged capacity: %u\n",
        config->challenged.capacity);
    rcon_printf("  Challenged precision: %u\n",
        config->challenged.precision);
    rcon_printf("  Authenticated aging: %u seconds\n",
        config->authenticated.aging_ms / 1000);
    rcon_printf("  Authenticated capacity: %u\n",
        config->authenticated.capacity);
    rcon_printf("  Authenticated precision: %u\n",
        config->authenticated.precision);
}

PRIVATE VOID synflood_config_free(VOID *prot)
{
    free(prot);
}

PRIVATE BOOL synflood_config_get_enabled(VOID *prot_config)
{
    NSAED_SYNFLOOD_CONFIG *config = prot_config;
    return config->enabled;
}

PRIVATE INLINE VOID load_bloom_config(cJSON *synflood_json, const char *node,
                                      NSAED_SYNFLOOD_BLOOM_CONFIG *bcfg)
{
    cJSON *bcfg_json = cJSON_GetObjectItemCaseSensitive(synflood_json, node);
    if (bcfg_json != NULL && cJSON_IsObject(bcfg_json))
    {
        cJSON *key = cJSON_GetObjectItemCaseSensitive(bcfg_json, "aging");
        if (key && cJSON_IsNumber(key))
        {
            bcfg->aging_ms = (INT)cJSON_GetNumberValue(key) * 1000;
        }

        key = cJSON_GetObjectItemCaseSensitive(bcfg_json, "capacity");
        if (key && cJSON_IsNumber(key))
        {
            bcfg->capacity = (INT)cJSON_GetNumberValue(key);
        }

        key = cJSON_GetObjectItemCaseSensitive(bcfg_json, "precision");
        if (key && cJSON_IsNumber(key))
        {
            bcfg->precision = (INT)cJSON_GetNumberValue(key);
        }
    }
}

PRIVATE VOID synflood_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *synflood_json)
{
    NSAED_SYNFLOOD_CONFIG *config = prot_config;
    load_bloom_config(synflood_json, "challenged", &config->challenged);
    load_bloom_config(synflood_json, "authenticated", &config->authenticated);
}

PRIVATE INLINE VOID create_bloom_filter(struct aging_bloom_filter **ppbfilter,
                                        const NSAED_SYNFLOOD_BLOOM_CONFIG *bcfg,
                                        const char *name)
{
    *ppbfilter = aging_bloom_filter_create(bcfg->capacity,
            bcfg->precision, bcfg->aging_ms);
    if (*ppbfilter == NULL)
    {
        log_event(BOTH_LOG, "#NSAED-SYNFLOOD: failed to allocate %s bloom "
                "filter. Exiting.", name);
        exit(1);
    }
}

PRIVATE INLINE VOID reconfig_bloom_filter(struct aging_bloom_filter *bfilter,
                                          const NSAED_SYNFLOOD_BLOOM_CONFIG *bcfg)
{
    aging_bloom_filter_set_params(bfilter, bcfg->capacity,
            bcfg->precision, bcfg->aging_ms);
}

PRIVATE VOID synflood_config_loaded(const VOID *prot_config, VOID *prot_state, VOID *shared_state)
{
    const NSAED_SYNFLOOD_CONFIG *config = prot_config;
    NSAED_SYNFLOOD_STATE *state = prot_state;

    if (state->challenged == NULL)
    {
        // The state is not initialized, and both bloom filters are NULL.
        assert(state->authenticated == NULL);
        create_bloom_filter(&state->challenged, &config->challenged, "challenged");
        create_bloom_filter(&state->authenticated, &config->authenticated, "authenticated");

        // For simplicity, the first salt will be used for two aging periods.
        state->salt[0] = state->salt[1] = rand();
        // TODO remove this log when the protection is fully implemented
        log_event(BOTH_LOG, "#NSAED-SYNFLOOD: thread %lu initial salt is %u",
                pthread_self(), state->salt[0]);
    }
    else
    {
        assert(state->authenticated != NULL);
        reconfig_bloom_filter(state->challenged, &config->challenged);
        reconfig_bloom_filter(state->authenticated, &config->authenticated);
    }
}

PRIVATE VOID synflood_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_SYNFLOOD_CONFIG *config = prot_config;
    config->enabled = state;
}

PRIVATE N32 synflood_get_protection_id()
{
    return protection_id;
}

PRIVATE VOID
synflood_gen_hashes(const XMIB_FLOW_INFO *info, N32 *h1, N32 *h2)
{
    const IP_PARSER_INFO *ip_info = &info->ip_parse_info;
    if (ip_info->ip_version == 4)
    {
        N32 addr = ip_info->src_addr;
        *h1 = fnv1a_hash(&addr, sizeof(N32));
        *h2 = inline_mixer_hash(&addr, sizeof(N32));
    }
    else
    {
        const IPV6_ADDR *addr = &(ip_info->addr[OUTER_MOST_IP_HDR - 1].src);
        *h1 = fnv1a_hash(addr, sizeof(*addr));
        *h2 = inline_mixer_hash(addr, sizeof(*addr));
    }
}

PRIVATE INLINE VOID mark_source_present(const XMIB_FLOW_INFO *info,
        struct aging_bloom_filter *bfilter, N64 *stat_counter)
{
    N32 h1, h2;
    synflood_gen_hashes(info, &h1, &h2);
    aging_bloom_filter_set(bfilter, h1, h2);

    (*stat_counter)++;
}

// Check if the source address is authenticated. May modify the bloom filter
PRIVATE BOOL is_authenticated(const XMIB_FLOW_INFO *info, NSAED_SYNFLOOD_STATE *state)
{
    N32 h1, h2;
    synflood_gen_hashes(info, &h1, &h2);
    switch (aging_bloom_filter_search(state->authenticated, h1, h2))
    {
    case ABF_FOUND_AGED:
        // If the source can only be found in the aged bloom filter, save it
        // in the current bloom filter. This keeps the source authenticated if
        // traffic is seen from that source within the aging timeout.
        aging_bloom_filter_set(state->authenticated, h1, h2);
        // FALLTHROUGH
    case ABF_FOUND_CURRENT:
        return TRUE;
    default:    // ABF_FOUND_NONE
        return FALSE;
    }
}

PRIVATE VOID set_authenticated(const XMIB_FLOW_INFO *info, NSAED_SYNFLOOD_STATE *state)
{
    mark_source_present(info, state->authenticated, &state->stats.src_authenticated);
}

PRIVATE BOOL is_challenged(const XMIB_FLOW_INFO *info, const NSAED_SYNFLOOD_STATE *state)
{
    N32 h1, h2;
    synflood_gen_hashes(info, &h1, &h2);
    return aging_bloom_filter_search(state->challenged, h1, h2) != ABF_FOUND_NONE;
}

PRIVATE VOID set_challenged(const XMIB_FLOW_INFO *info, NSAED_SYNFLOOD_STATE *state)
{
    mark_source_present(info, state->challenged, &state->stats.syn_challenged);
}

/*
    * Byte ordering:
    * IP_PARSER_INFO - HBO, tcphdr - NBO
*/
PRIVATE N32 get_cookie_hash_v4(const IP_PARSER_INFO *ip_info, N32 seq, N32 salt)
{
    SYNCOOKIE_DATA_IPV4 data = {
        .src_port = ip_info->src_port,
        .dest_port = ip_info->dest_port,
        .src_addr = ip_info->src_addr,
        .dest_addr = ip_info->dest_addr,
        .tcp_seq = seq,
        .salt = salt,
    };
    return inline_mixer_hash(&data, sizeof(SYNCOOKIE_DATA_IPV4));
}

PRIVATE N32 get_cookie_hash_v6(const IP_PARSER_INFO *ip_info, N32 seq, N32 salt)
{
    SYNCOOKIE_DATA_IPV6 data = {
        .src_port = ip_info->src_port,
        .dest_port = ip_info->dest_port,
        .src_addr = ip_info->addr[OUTER_MOST_IP_HDR - 1].src,
        .dest_addr = ip_info->addr[OUTER_MOST_IP_HDR - 1].dest,
        .tcp_seq = seq,
        .salt = salt,
    };
    return inline_mixer_hash(&data, sizeof(SYNCOOKIE_DATA_IPV6));
}

/* Return the client ISN in network byte order. The TCP segment is expected
 * to be the SYN or ACK of the 3-way handshake.
 */
PRIVATE INLINE N32 get_client_isn(const struct tcphdr *tcp)
{
    if (tcp->syn)
    {
        return tcp->seq;
    }
    else
    {
        N32 isn = ntohl(tcp->seq) - 1;
        return htonl(isn);
    }
}

PRIVATE N32 gen_cookie(const XMIB_FLOW_INFO *info, const NSAED_SYNFLOOD_STATE *state, BOOL use_last_salt)
{
    N32 salt = state->salt[use_last_salt ? !state->current_salt_idx : state->current_salt_idx];
    const struct tcphdr *tcp = (struct tcphdr *)info->l4_hdr;
    const N32 client_isn = get_client_isn(tcp);
    const IP_PARSER_INFO *ip_info = &info->ip_parse_info;
    return ((ip_info->ip_version == 4)?
            get_cookie_hash_v4(ip_info, client_isn, salt):
            get_cookie_hash_v6(ip_info, client_isn, salt));
}

/*
 * Send a TCP segment within the session identified by `info` to the source
 * address, with tcp.seq be `tcp_seq` (network byte order), and the tcp.flags
 * be `tcp_flags`.
 *
 * Supported TCP flags: TCP_SYN, TCP_ACK, TCP_RST
 */
PRIVATE BOOL send_tcp_reply(const XMIB_FLOW_INFO *info, N32 tcp_seq, N8 tcp_flags)
{
    #define TTL_DEFAULT 64
    #define WINDOW_DEFAULT (16 * 1024)
    #define IS_FLAG_SET(flag)   ((tcp_flags & flag) == flag)

    struct ethhdr *eth = NULL;
    struct iphdr *ip = NULL;
    struct ip6_hdr *ip6  = NULL;
    struct tcphdr *tcp = NULL;

    const struct ethhdr *eth_rcvd = (VOID *)(info->ip_hdr - sizeof(struct ethhdr));
    const IP_PARSER_INFO *ip_info = &info->ip_parse_info;
    const struct tcphdr *tcp_rcvd = (struct tcphdr *)info->l4_hdr;

    const uint32_t PKT_SIZE = sizeof(*eth) + sizeof(*tcp) +
        (ip_info->ip_version == 4 ? sizeof(*ip) : sizeof(*ip6));

    AED_CHALLENGE_PKT* pkt = aed_add_challenge_pkt(info->insp_id, info->pbi, info->orig_ifn, PKT_SIZE);
    if (pkt == NULL)
    {
        return FALSE;
    }

    eth = (struct ethhdr *)pkt->payload;
    memcpy(eth->h_source, &eth_rcvd->h_dest, sizeof(eth->h_source));
    memcpy(eth->h_dest, &eth_rcvd->h_source, sizeof(eth->h_dest));

    if (ip_info->ip_version == 4)
    {
        eth->h_proto = htons(ETH_P_IP);

        ip = (struct iphdr *)(eth + 1);
        ip->version = 4;
        ip->ihl = sizeof(*ip) / 4;
        ip->tos = 0;
        ip->tot_len = htons(sizeof(*ip) + sizeof(*tcp));
        // Using an IP-ID different from the received IP-ID and hoping that
        // it's not in use currently (e.g. by a fragment).
        ip->id = htons(info->ipid + 1337);
        ip->frag_off = 0;
        ip->ttl = TTL_DEFAULT;
        ip->protocol = IPPROTO_TCP;
        ip->saddr = htonl(ip_info->dest_addr);
        ip->daddr = htonl(ip_info->src_addr);
        ip->check = 0;
        ip->check = ~ip_cksum((unsigned char *)ip, sizeof(*ip));

        tcp = (struct tcphdr *)(ip + 1);
    }
    else
    {
        eth->h_proto = htons(ETH_P_IPV6);

        ip6 = (struct ip6_hdr *)(eth + 1);
        ip6->ip6_flow = 0;
        ip6->ip6_vfc = 0x60; // do this after assigning flow, since that field
                             // covers the vfc field
        ip6->ip6_plen = htons(sizeof(*tcp));
        ip6->ip6_nxt = IPPROTO_TCP;
        ip6->ip6_hlim = TTL_DEFAULT;

        GET_IPV6_ADDR_HTON_PTR(((IPV6_ADDR *)&ip6->ip6_src), ip_info->addr[OUTER_MOST_IP_HDR - 1].dest);
        GET_IPV6_ADDR_HTON_PTR(((IPV6_ADDR *)&ip6->ip6_dst), ip_info->addr[OUTER_MOST_IP_HDR - 1].src);
        tcp = (struct tcphdr *)(ip6 + 1);
    }

    tcp->source = htons(ip_info->dest_port);
    tcp->dest = htons(ip_info->src_port);
    tcp->seq = tcp_seq;
    tcp->ack_seq = htonl(ntohl(tcp_rcvd->seq) + 1);

    tcp->res1 = 0;
    tcp->doff = sizeof(*tcp) / 4;
    tcp->fin  = 0;
    tcp->syn  = IS_FLAG_SET(TCP_SYN);
    tcp->rst  = IS_FLAG_SET(TCP_RST);
    tcp->psh  = 0;
    tcp->ack  = IS_FLAG_SET(TCP_ACK);
    tcp->urg  = 0;
    tcp->res2 = 0;

    tcp->window = htons(WINDOW_DEFAULT);
    tcp->check = 0;
    tcp->urg_ptr = 0;

    tcp->check = ~tcp_cksum(eth + 1, ip_info->ip_version == 6, (VOID *)tcp, sizeof(*tcp));
    return TRUE;
}

PRIVATE INLINE BOOL send_synack(const XMIB_FLOW_INFO *info, N32 tcp_seq)
{
    return send_tcp_reply(info, tcp_seq, TCP_SYN | TCP_ACK);
}

PRIVATE INLINE BOOL send_rst(const XMIB_FLOW_INFO *info, N32 tcp_seq)
{
    return send_tcp_reply(info, tcp_seq, TCP_RST);
}

PRIVATE NSAED_ACTION synflood_inspect(const VOID *c, VOID *s, XMIB_FLOW_INFO *info)
{
    NSAED_SYNFLOOD_STATE* state = s;

    if (info->ip_parse_info.protocol != IPPROTO_TCP)
    {
        return NSAED_ACTION_NONE;
    }

    // The inspector is interested in SYN and ACK, but not SYN-ACK. The ACK in
    // the 3-way handshake may have piggybacking PSH, and this should not
    // prevent the inspector from verifying the cookie in it.
    switch (info->tcp_flags & (TCP_SYN | TCP_ACK))
    {
    case TCP_SYN:
        if (is_authenticated(info, state))
        {
            return NSAED_ACTION_NONE;
        }
        if (!is_challenged(info, state))
        {
            N32 cookie = gen_cookie(info, state, FALSE);
            if (send_synack(info, htonl(cookie)))
            {
                // Mark the source as challenged only if the SYN-ACK is
                // successfully sent, otherwise we would block SYNs from the
                // source until the challenged bloom filter is aged out.
                set_challenged(info, state);
            }
        }
        state->stats.stats_base.pkt_dropped++;
        state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
        return NSAED_ACTION_DROP;

    case TCP_ACK:
        if (is_authenticated(info, state) || !is_challenged(info, state))
        {
            return NSAED_ACTION_NONE;
        }
        else
        {
            struct tcphdr *tcp = (struct tcphdr *)info->l4_hdr;
            // get the ISN of the server
            N32 isn = ntohl(tcp->ack_seq) - 1;
            N32 cookie = gen_cookie(info, state, FALSE);
            if (isn == cookie ||
                    // try the last salt if the current salt doesn't work
                    isn == (cookie = gen_cookie(info, state, TRUE)))
            {
                // Send RST to the client as a courtesy, and it doesn't change
                // the fact that the source is authenticated whether the RST is
                // sent successfully or not.
                send_rst(info, tcp->ack_seq);
                set_authenticated(info, state);
            }
        }
        state->stats.stats_base.pkt_dropped++;
        state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
        return NSAED_ACTION_DROP;

    default:
        return NSAED_ACTION_NONE;
    }
}

PRIVATE VOID synflood_registered(N32 id)
{
    protection_id = id;
}

PRIVATE VOID synflood_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur)
{
    NSAED_SYNFLOOD_STATE* total = state_total;
    const NSAED_SYNFLOOD_STATE* cur = state_cur;
    total->stats.stats_base.pkt_dropped += cur->stats.stats_base.pkt_dropped;
    total->stats.stats_base.l3_byte_dropped += cur->stats.stats_base.l3_byte_dropped;
    total->stats.syn_challenged += cur->stats.syn_challenged;
    total->stats.src_authenticated += cur->stats.src_authenticated;
}

PRIVATE VOID synflood_stat_dump(const VOID *c, const VOID *s)
{
    const NSAED_SYNFLOOD_STATE* state = s;
    if (state)
    {
        rcon_printf("Packets dropped by %s: %llu\n",
                SYNFLOOD_NAME, state->stats.stats_base.pkt_dropped);
        rcon_printf("L3 Bytes dropped by %s: %llu\n",
                SYNFLOOD_NAME, state->stats.stats_base.l3_byte_dropped);
        rcon_printf("SYN segments challenged by %s: %llu\n",
                SYNFLOOD_NAME, state->stats.syn_challenged);
        rcon_printf("Sources authenticated by %s: %llu\n",
                SYNFLOOD_NAME, state->stats.src_authenticated);
    }
}

PRIVATE VOID synflood_stat_dump_json(cJSON* cj, const VOID *c, const VOID *s)
{
    const NSAED_SYNFLOOD_STATE* state = s;
    const NSAED_SYNFLOOD_STATS* stats = &state->stats;

    cJSON* synflood = cJSON_AddObjectToObject(cj, SYNFLOOD_ELEMENT_NAME);
    cJSON_AddNumberToObject(synflood, "packets_dropped", stats->stats_base.pkt_dropped);
    cJSON_AddNumberToObject(synflood, "l3_bytes_dropped", stats->stats_base.l3_byte_dropped);
    cJSON_AddNumberToObject(synflood, "syn_challenged", stats->syn_challenged);
    cJSON_AddNumberToObject(synflood, "src_authenticated", stats->src_authenticated);
}

PRIVATE VOID* synflood_state_alloc()
{
    // The state will be initialized when the protection config is available.
    return calloc(1, sizeof(NSAED_SYNFLOOD_STATE));
}

PRIVATE VOID synflood_state_free(VOID *prot)
{
    if (prot == NULL)
        return;

    NSAED_SYNFLOOD_STATE *state = prot;
    aging_bloom_filter_destroy(state->challenged);
    aging_bloom_filter_destroy(state->authenticated);
    free(state);
}

PRIVATE INLINE BOOL age_bloom_filter(struct aging_bloom_filter *bfilter, const char *name)
{
    if (aging_bloom_filter_has_expired(bfilter, currentUpTimeMSec))
    {
        if (aging_bloom_filter_ageout_now(bfilter, currentUpTimeMSec))
        {
            // TODO remove this log when the protection is fully implemented
            log_event(BOTH_LOG, "#NSAED-SYNFLOOD: thread %lu %s bloom filter "
                    "has been aged out successfully", pthread_self(), name);
            return TRUE;
        }
        else
        {
            log_event(BOTH_LOG, "#NSAED-SYNFLOOD: %s bloom filter has expired, "
                    "but new bloom filter cannot be created. Exiting.", name);
            exit(1);
        }
    }
    return FALSE;
}

PRIVATE INLINE VOID age_salt(NSAED_SYNFLOOD_STATE *state)
{
    N32 new_salt = rand();
    state->current_salt_idx = !state->current_salt_idx;
    // TODO remove this log when the protection is fully implemented
    log_event(BOTH_LOG, "#NSAED-SYNFLOOD: thread %lu salt %u is aged out, and "
            "new salt %u is generated", pthread_self(),
            state->salt[state->current_salt_idx], new_salt);
    state->salt[state->current_salt_idx] = new_salt;
}

PRIVATE VOID synflood_tick(const VOID *prot_config, VOID *prot_state, NSAED_PG_STATE *pg_state, NSAED_INSP_THREAD *)
{
    NSAED_SYNFLOOD_STATE *state = prot_state;
    if (age_bloom_filter(state->challenged, "challenged"))
    {
        // Age salt using the same timeout used by the challenged bloom filter, so
        // that the salt for challenging a source is always available if the source
        // is not aged out from the challenged bloom filter.
        age_salt(state);
    }
    age_bloom_filter(state->authenticated, "authenticated");
}
#endif // ISNG_BASED_AED
#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2025                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
*                                                                       *
************************************************************************/

#include <netinet/ip.h>

#include "eventlog.h"
#include "ppformat.h"
#include "aed/aed.h"
#include "aed/aedmacros.h"
#include "aed/cJSON.h"
#include "xmibflow.h"
#include "aed/foundation/aging_bloom_filter.h"
#include "aed/foundation/hash_functions.h"

#define TCPFLOOD_NAME "TCP Flooding"
#define TCPFLOOD_ELEMENT_NAME "tcpflood"

// Default config for the bloom ftiler
#define TCPFLOOD_AGING 300          // 5 minutes
#define TCPFLOOD_CAPACITY 1000000
#define TCPFLOOD_PRECISION 3
#define TCPFLOOD_WARMUP 30

IMPORT N32 currentUpTimeMSec;

typedef struct
{
    BOOL enabled;
    N32 aging_ms;
    N32 capacity;
    N32 precision;
    N32 warmup_ms;
} NSAED_TCPFLOOD_CONFIG;

typedef struct
{
    NSAED_PROTECTION_STATS_BASE stats_base;
} NSAED_TCPFLOOD_STATS;

typedef struct
{
    NSAED_TCPFLOOD_STATS stats;
    N64 warmup_time;
    BOOL warmed_up;
    struct aging_bloom_filter *bfilter;
} NSAED_TCPFLOOD_STATE;

PRIVATE VOID* tcpflood_config_alloc();
PRIVATE VOID tcpflood_config_dump(const VOID *prot_config);
PRIVATE VOID tcpflood_config_free(VOID *prot);
PRIVATE BOOL tcpflood_config_get_enabled(VOID *prot_config);
PRIVATE VOID tcpflood_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *json);
PRIVATE VOID tcpflood_config_loaded(const VOID *pg_config, VOID *pg_state, VOID *shared_state);
PRIVATE VOID tcpflood_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE N32 tcpflood_get_protection_id();
PRIVATE NSAED_ACTION tcpflood_inspect(const VOID *prot_config, VOID *prot_state, XMIB_FLOW_INFO *info);
PRIVATE VOID tcpflood_registered(N32 id);
PRIVATE VOID tcpflood_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur);
PRIVATE VOID tcpflood_stat_dump(const VOID *config, const VOID* state);
PRIVATE VOID tcpflood_stat_dump_json(cJSON*, const VOID *config, const VOID* state);
PRIVATE VOID* tcpflood_state_alloc();
PRIVATE VOID tcpflood_state_free(VOID *prot);
PRIVATE VOID tcpflood_tick(const VOID *prot_config, VOID *prot_state, NSAED_PG_STATE *pg_state, NSAED_INSP_THREAD *);

EXPORT const NSAED_PROTECTION tcpflood_protection = {
    .name = TCPFLOOD_ELEMENT_NAME,
    .features = NSAED_FEATURE_REVERSE_CLASS,

    .config_allocator = tcpflood_config_alloc,
    .config_deallocator = tcpflood_config_free,
    .config_dumper = tcpflood_config_dump,
    .config_get_enabled = tcpflood_config_get_enabled,
    .config_handler = tcpflood_config_handler,
    .config_loaded = tcpflood_config_loaded,
    .config_set_enabled = tcpflood_config_set_enabled,
    .get_protection_id = tcpflood_get_protection_id,
    .inspector = tcpflood_inspect,
    .registered = tcpflood_registered,
    .stat_accumulator = tcpflood_stat_add,
    .stat_dumper = tcpflood_stat_dump,
    .stat_dumper_json = tcpflood_stat_dump_json,
    .state_allocator = tcpflood_state_alloc,
    .state_deallocator = tcpflood_state_free,
    .tick = tcpflood_tick,
};

PRIVATE N32 protection_id = 0;

PRIVATE VOID* tcpflood_config_alloc()
{
    NSAED_TCPFLOOD_CONFIG *config = calloc(1, sizeof(NSAED_TCPFLOOD_CONFIG));
    if (config == NULL) {
        return NULL;
    }
    config->aging_ms = TCPFLOOD_AGING * 1000;
    config->capacity = TCPFLOOD_CAPACITY;
    config->precision = TCPFLOOD_PRECISION;
    config->warmup_ms = TCPFLOOD_WARMUP * 1000ULL;
    return config;
}

PRIVATE VOID tcpflood_config_dump(const VOID *c)
{
    const NSAED_TCPFLOOD_CONFIG* config = c;
    rcon_printf("%s\n  Enabled: %s\n", TCPFLOOD_NAME,
        IS_PROTECTION_ENABLED(config->enabled));
    if (!config->enabled)
    {
        return;
    }
    rcon_printf("  Aging: %u seconds\n", config->aging_ms / 1000);
    rcon_printf("  Capacity: %u\n", config->capacity);
    rcon_printf("  Precision: %u\n", config->precision);
    rcon_printf("  Warmup: %u seconds\n", config->warmup_ms / 1000);
}

PRIVATE VOID tcpflood_config_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    free(prot);
}

PRIVATE BOOL tcpflood_config_get_enabled(VOID *prot_config)
{
    NSAED_TCPFLOOD_CONFIG *config = prot_config;
    return config->enabled;
}

PRIVATE VOID tcpflood_tick(const VOID *prot_config, VOID *prot_state, NSAED_PG_STATE *pg_state, NSAED_INSP_THREAD *)
{
    const NSAED_TCPFLOOD_CONFIG *config = prot_config;
    NSAED_TCPFLOOD_STATE *state = prot_state;
    if (aging_bloom_filter_ageout(state->bfilter, currentUpTimeMSec) == ABF_AGEOUT_NO_MEMORY)
    {
        log_event(BOTH_LOG, "#NSAED-TCPFLOOD: failed to allocate bloom filter");
        exit(1);
    }
    if (!state->warmed_up && currentUpTimeMSec - state->warmup_time >= config->warmup_ms)
    {
        state->warmed_up = TRUE;
    }
}

PRIVATE VOID tcpflood_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *tcpflood_json)
{
    NSAED_TCPFLOOD_CONFIG *config = prot_config;
    cJSON *aging = cJSON_GetObjectItemCaseSensitive(tcpflood_json, "aging");
    cJSON *capacity = cJSON_GetObjectItemCaseSensitive(tcpflood_json, "capacity");
    cJSON *precision = cJSON_GetObjectItemCaseSensitive(tcpflood_json, "precision");
    cJSON *warmup = cJSON_GetObjectItemCaseSensitive(tcpflood_json, "warmup");

    if (aging && cJSON_IsNumber(aging)) {
        config->aging_ms = (INT)cJSON_GetNumberValue(aging) * 1000ULL;
    }
    if (capacity && cJSON_IsNumber(capacity)) {
        config->capacity = (INT)cJSON_GetNumberValue(capacity);
    }
    if (precision && cJSON_IsNumber(precision)) {
        config->precision = (INT)cJSON_GetNumberValue(precision);
    }
    if (warmup && cJSON_IsNumber(warmup)) {
        config->warmup_ms = (INT)cJSON_GetNumberValue(warmup) * 1000ULL;
    }
}

PRIVATE VOID tcpflood_config_loaded(const VOID *prot_config, VOID *prot_state, VOID *shared_state)
{
    const NSAED_TCPFLOOD_CONFIG *config = prot_config;
    NSAED_TCPFLOOD_STATE *state = prot_state;
    if (state->bfilter == NULL)
    {
        state->bfilter = aging_bloom_filter_create(config->capacity, config->precision, config->aging_ms);
        if (state->bfilter == NULL)
        {
            log_event(BOTH_LOG, "#NSAED-TCPFLOOD: failed to allocate bloom filter");
            exit(1);

        }
        state->warmup_time = currentUpTimeMSec;
    }
    else
    {
        aging_bloom_filter_set_params(state->bfilter, config->capacity, config->precision, config->aging_ms);
    }
}

PRIVATE VOID tcpflood_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_TCPFLOOD_CONFIG *config = prot_config;
    config->enabled = state;
}

PRIVATE N32 tcpflood_get_protection_id()
{
    return protection_id;
}

PRIVATE NSAED_ACTION tcpflood_inspect_inbound(const NSAED_TCPFLOOD_CONFIG *config, NSAED_TCPFLOOD_STATE *state, XMIB_FLOW_INFO *info)
{
    uint32_t h1, h2;
    ABF_SEARCH_RESULT res;

    if (!state->warmed_up)
    {
        return NSAED_ACTION_NONE;   // still in warmup
    }
    if (!(info->tcp_flags & (TCP_ACK | TCP_FIN | TCP_RST)))
    {
        return NSAED_ACTION_NONE; // none of ACK, FIN, or RST set
    }

    // search bloom filter for four-tuple
    h1 = hash_four_tuple(&info->ip_parse_info, inline_mixer32_hash, FALSE);
    h2 = hash_four_tuple(&info->ip_parse_info, fnv1a_hash, FALSE);
    res = aging_bloom_filter_search(state->bfilter, h1, h2);
    if (res == ABF_FOUND_NONE) {
        // four-tuple not in bloom filter; drop packet
       return NSAED_ACTION_DROP;
    }
    // four-tuple in bloom filter; pass packet
    return NSAED_ACTION_NONE;
}

PRIVATE NSAED_ACTION tcpflood_inspect_outbound(const NSAED_TCPFLOOD_CONFIG *config, NSAED_TCPFLOOD_STATE *state, XMIB_FLOW_INFO *info)
{
    uint32_t h1, h2;

    if (!(info->tcp_flags & (TCP_SYN | TCP_ACK)))
    {
        return NSAED_ACTION_NONE;   // none of SYN, ACK set.
    }

    // insert four-tuple into bloom filter, inverting source & dest
    h1 = hash_four_tuple(&info->ip_parse_info, inline_mixer32_hash, TRUE);
    h2 = hash_four_tuple(&info->ip_parse_info, fnv1a_hash, TRUE);
    aging_bloom_filter_set(state->bfilter, h1, h2);

    return NSAED_ACTION_NONE;
}

PRIVATE NSAED_ACTION tcpflood_inspect(const VOID *c, VOID *s, XMIB_FLOW_INFO *info)
{
    const NSAED_TCPFLOOD_CONFIG* config = c;
    NSAED_TCPFLOOD_STATE* state = s;
    NSAED_ACTION action;

    // determine action
    BOOL outbound = !nsaed_is_external_ifn(info->orig_ifn);
    if (info->ip_parse_info.protocol != IPPROTO_TCP)
    {
        action = NSAED_ACTION_NONE;   // not a TCP packet
    }
    else if (outbound)
    {
        action = tcpflood_inspect_outbound(config, state, info);
    }
    else
    {
        action = tcpflood_inspect_inbound(config, state, info);
    }

    // update stats
    if (action == NSAED_ACTION_DROP)
    {
        state->stats.stats_base.pkt_dropped++;
        state->stats.stats_base.l3_byte_dropped += L3_BYTES(info);
    }

    return action;
}

PRIVATE VOID tcpflood_registered(N32 id)
{
    protection_id = id;
}

PRIVATE VOID tcpflood_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur)
{
    NSAED_TCPFLOOD_STATE* total = state_total;
    const NSAED_TCPFLOOD_STATE* cur = state_cur;
    total->stats.stats_base.pkt_dropped += cur->stats.stats_base.pkt_dropped;
    total->stats.stats_base.l3_byte_dropped += cur->stats.stats_base.l3_byte_dropped;
    // TODO add any extra stats
}

PRIVATE VOID tcpflood_stat_dump(const VOID *c, const VOID *s)
{
    const NSAED_TCPFLOOD_STATE* state = s;
    if (state)
    {
        rcon_printf("Packets dropped by %s: %llu\n",
                TCPFLOOD_NAME, state->stats.stats_base.pkt_dropped);
        rcon_printf("L3 Bytes dropped by %s: %llu\n",
                TCPFLOOD_NAME, state->stats.stats_base.l3_byte_dropped);
        // TODO dump any extra stats
    }
}

PRIVATE VOID tcpflood_stat_dump_json(cJSON* cj, const VOID *c, const VOID *s)
{
    const NSAED_TCPFLOOD_STATE* state = s;
    const NSAED_TCPFLOOD_STATS* stats = &state->stats;

    cJSON* tcpflood = cJSON_AddObjectToObject(cj, TCPFLOOD_ELEMENT_NAME);
    cJSON_AddNumberToObject(tcpflood, "packets_dropped", stats->stats_base.pkt_dropped);
    cJSON_AddNumberToObject(tcpflood, "l3_bytes_dropped", stats->stats_base.l3_byte_dropped);
    // TODO dump any extra stats
}

PRIVATE VOID* tcpflood_state_alloc()
{
    return calloc(1, sizeof(NSAED_TCPFLOOD_STATE));
}

PRIVATE VOID tcpflood_state_free(VOID *prot)
{
    free(prot);
}
#endif // ISNG_BASED_AED
connlimit
connreset
dns_ndqf
dns_ra
dnsrl
dns_regex
dnsform
fcap_filtering
geoipfilter
geoiprate
ip_filtering
ip_reputation
malformed
plregex
ratelimit
synackflood
synflood
tcpflood
zombie
synflood
dns_regex
plregex
ratelimit
synackflood
tcpflood
geoiprate
dnsrl
dns_ndqf
connlimit
synflood
connlimit
dns_ndqf
dns_ra
dns_regex
dnsform
dnsrl
geoipfilter
geoiprate
ip_filtering
ip_reputation
malformed
plregex
synackflood
synflood
ratelimit
tcpflood
connlimit
dns_ndqf
dns_ra
dns_regex
dnsform
dnsrl
geoipfilter
geoiprate
ip_filtering
ip_reputation
malformed
plregex
synackflood
synflood
ratelimit
tcpflood
fcap_filtering
#if ISNG_BASED_AED
/************************************************************************
*                              W A R N I N G                            *
*                              ~~~~~~~~~~~~~                            *
*                           Copyright (c) 2024                          *
*                          NetScout Systems, Inc.                       *
*                            Westford, MA 01886                         *
*                           All Rights Reserved                         *
*                                                                       *
* This software is part of Licensed material, which is the property of  *
* NetScout Systems, Inc.  Unauthorized use, duplication or distribution *
* is strictly prohibited by Federal law.  No title to and ownership of  *
* this software is hereby transferred.                                  *
                                                                        *
************************************************************************/
#include <string.h>

#include "eventlog.h"
#include "aed/aed.h"
#include "xmibip.h"
#include "aed/srcstate.h"
#include "aed/tokenbucket.h"
#include "aed/cJSON.h"
#include "aed/arf/api.h"
#include "rconapi.h"
#include "xmibflow.h"

#define ZOMBIE_NAME "Rate-Based Blocking"
#define FLEX_ZOMBIE_NAME "Flexible Rate-Based Blocking"
#define ZOMBIE_ELEMENT_NAME "zombie"
#define KEY_ARF_ID "arf_id"

#define MAX_FLEX 8
// 1 global + 8 FCAP
#define MAX_LIMITERS (1 + MAX_FLEX)
#define GLOBAL_ZOMBIE 0

#define ZOMBIE_SRCSTATE_BLOCKSIZE (sizeof(ZOMBIE_LIMITER) * MAX_LIMITERS)

struct XMIB_FLOW_INFO;
struct NSAED_ROOT;
struct NSAED_STATS;

typedef struct
{
    BOOL enabled;
    // 0 means bps/pps rate limit is not set
    N32 bps;
    N32 pps;
} NSAED_ZOMBIE_FILTER_CONFIG;

typedef struct
{
    // enabled: _any_ part of this protection is enabled
    BOOL enabled;
    TEXT *arf_id;
    arf_t *arf;
    NSAED_ACTION action;
    NSAED_ZOMBIE_FILTER_CONFIG filter[MAX_LIMITERS];
} NSAED_ZOMBIE_CONFIG;

typedef struct
{
    // TODO: This member might not be needed. We will fix the other members in
    // the future PRs
    NSAED_PROTECTION_STATS_BASE stats_base;
    N64 pkt_dropped[MAX_LIMITERS];
    N64 l3_byte_dropped[MAX_LIMITERS];
} NSAED_ZOMBIE_STATS;

typedef struct
{
    TOKENBUCKET tb_bytes;
    TOKENBUCKET tb_pkts;
} ZOMBIE_LIMITER;

typedef struct
{
    NSAED_ZOMBIE_STATS stats;
    arf_t *arf;
    arf_handle_t *arf_handle;
} NSAED_ZOMBIE_STATE;

PRIVATE VOID* zombie_config_alloc();
PRIVATE VOID zombie_config_free(VOID *prot);
PRIVATE VOID* zombie_state_alloc();
PRIVATE VOID zombie_state_free(VOID *prot);
PRIVATE VOID zombie_stat_dump(const VOID *c, const VOID *s);
PRIVATE VOID zombie_stat_dump_json(cJSON *cj, const VOID *c, const VOID *s);
PRIVATE VOID zombie_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur);
PRIVATE NSAED_ACTION zombie_inspect(const VOID *prot_config, VOID *prot_state, struct XMIB_FLOW_INFO *info);
PRIVATE VOID zombie_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *zombie_json);
PRIVATE BOOL zombie_config_get_enabled(VOID *prot_config);
PRIVATE VOID zombie_config_set_enabled(VOID *prot_config, BOOL state);
PRIVATE VOID zombie_config_dump(const VOID *c);
PRIVATE VOID zombie_config_loaded(const VOID *prot_config, VOID *prot_state, VOID *shared_state);
PRIVATE VOID zombie_registered(N32 id);
PRIVATE N32 zombie_get_protection_id();

EXPORT const NSAED_PROTECTION zombie_protection = {
    .name = ZOMBIE_ELEMENT_NAME,
    .features = NSAED_FEATURE_SRCSTATE,
    .srcstate_blocksize = ZOMBIE_SRCSTATE_BLOCKSIZE,

    .config_allocator = zombie_config_alloc,
    .config_deallocator = zombie_config_free,
    .config_handler = zombie_config_handler,
    .config_get_enabled = zombie_config_get_enabled,
    .config_set_enabled = zombie_config_set_enabled,
    .config_dumper = zombie_config_dump,
    .config_loaded = zombie_config_loaded,
    .state_allocator = zombie_state_alloc,
    .state_deallocator = zombie_state_free,
    .inspector = zombie_inspect,
    .stat_dumper = zombie_stat_dump,
    .stat_dumper_json = zombie_stat_dump_json,
    .stat_accumulator = zombie_stat_add,
    .registered = zombie_registered,
    .get_protection_id = zombie_get_protection_id,
};

PRIVATE N32 protection_id = 0;

PRIVATE NSAED_ACTION zombie_limiter_eval(ZOMBIE_LIMITER *limiter, XMIB_FLOW_INFO *info,
                                        N64 *pkt_dropped, N64 *l3_byte_dropped,
                                        const NSAED_ZOMBIE_FILTER_CONFIG *filter)
{
    // returns NSAED_ACTION_DROP if a tokenbucket_consume has no tokens to left to consume
    //     this means a traffic source has exceeded its rate limit
    // return NSAED_ACTION_NONE if tokenbucket_consume still has tokens
    //     this means a traffic source is below its rate limit
    if (filter->bps)
    {
        // Compare L3 length against floor(bps/8) to match pktengine
        N32 bytes = filter->bps / 8;
        tokenbucket_fill(&limiter->tb_bytes, info->frame_time_us, bytes, bytes);
        N16 ip_len = info->ip_parse_info.ip_hdr_len + info->ip_parse_info.ip_payload_len;
        if (tokenbucket_consume(&limiter->tb_bytes, ip_len))
        {
            // Not enough tokens: drop the packet.
            (*pkt_dropped)++;
            *l3_byte_dropped += L3_BYTES(info);
            return NSAED_ACTION_DROP;
        }
    }

    if (filter->pps)
    {
        tokenbucket_fill(&limiter->tb_pkts, info->frame_time_us, filter->pps, filter->pps);
        if (tokenbucket_consume(&limiter->tb_pkts, 1))
        {
            // Not enough tokens: drop the packet.
            (*pkt_dropped)++;
            *l3_byte_dropped += L3_BYTES(info);
            return NSAED_ACTION_DROP;
        }
    }
    return NSAED_ACTION_NONE;
}


PRIVATE BOOL zombie_config_set_rate_limit(NSAED_ZOMBIE_FILTER_CONFIG *filter_config, cJSON *json)
{
    cJSON *bps = cJSON_GetObjectItemCaseSensitive(json, "bps");
    cJSON *pps = cJSON_GetObjectItemCaseSensitive(json, "pps");

    filter_config->bps = 0;
    filter_config->pps = 0;

    if (bps && cJSON_IsNumber(bps))
    {
        filter_config->bps = (N32)cJSON_GetNumberValue(bps);
    }
    if (pps && cJSON_IsNumber(pps))
    {
        filter_config->pps = (N32)cJSON_GetNumberValue(pps);
    }
    // The specific filter is enabled if at least one of bps/pps limits is set
    filter_config->enabled = (filter_config->bps || filter_config->pps);
    return filter_config->enabled;
}

PRIVATE VOID zombie_stat_dump(const VOID *c, const VOID *s)
{
    const NSAED_ZOMBIE_STATE* state = s;
    const NSAED_ZOMBIE_STATS* stats = &state->stats;
    if (stats == NULL)
    {
        return;
    }
    rcon_printf("Packets dropped by %s: %llu\n",
            ZOMBIE_NAME, stats->pkt_dropped[GLOBAL_ZOMBIE]);
    rcon_printf("L3 Bytes dropped by %s: %llu\n",
            ZOMBIE_NAME, stats->l3_byte_dropped[GLOBAL_ZOMBIE]);
    for (INT i = 1; i < MAX_LIMITERS; i++)
    {
        rcon_printf("Packets dropped by %s (id: %d): %llu\n",
                FLEX_ZOMBIE_NAME, i, stats->pkt_dropped[i]);
        rcon_printf("L3 Bytes dropped by %s (id: %d): %llu\n",
                FLEX_ZOMBIE_NAME, i, stats->l3_byte_dropped[i]);
    }
}

PRIVATE VOID zombie_stat_dump_json(cJSON *cj, const VOID *c, const VOID *s)
{
    const NSAED_ZOMBIE_STATE* state = s;
    const NSAED_ZOMBIE_STATS* stats = &state->stats;

    cJSON* zombie = cJSON_AddObjectToObject(cj, zombie_protection.name);
    cJSON_AddNumberToObject(zombie, "packets_dropped", stats->pkt_dropped[GLOBAL_ZOMBIE]);
    cJSON_AddNumberToObject(zombie, "l3_bytes_dropped", stats->l3_byte_dropped[GLOBAL_ZOMBIE]);

    // per tag stats
    cJSON* filters = cJSON_AddObjectToObject(zombie, "filters");
    for (N32 tag_id = 1; tag_id < MAX_LIMITERS; ++tag_id)
    {
        char tag_str[64];
        snprintf(tag_str, sizeof(tag_str), "%d", tag_id);
        cJSON* tag = cJSON_AddObjectToObject(filters, tag_str);
        cJSON_AddNumberToObject(tag, "packets_dropped", stats->pkt_dropped[tag_id]);
        cJSON_AddNumberToObject(tag, "l3_bytes_dropped", stats->l3_byte_dropped[tag_id]);
    }
}

PRIVATE VOID zombie_stat_add(const VOID* config, VOID* state_total, const VOID* state_cur)
{
    NSAED_ZOMBIE_STATE* total = state_total;
    const NSAED_ZOMBIE_STATE* cur = state_cur;
    for (INT i = 0; i < MAX_LIMITERS; i++)
    {
        total->stats.pkt_dropped[i] += cur->stats.pkt_dropped[i];
        total->stats.l3_byte_dropped[i] += cur->stats.l3_byte_dropped[i];
    }
}

PRIVATE VOID zombie_config_loaded(const VOID *prot_config, VOID *prot_state, VOID *sh)
{
    const NSAED_ZOMBIE_CONFIG *config = prot_config;
    NSAED_ZOMBIE_STATE *state = prot_state;

    if (config->arf != state->arf)
    {
        // arf has changed, release the current arf handle
        if (state->arf_handle != NULL)
        {
            arf_release_handle(&state->arf_handle);
            state->arf = NULL;
        }

        if (config->arf != NULL)
        {
            state->arf_handle = arf_get_handle(config->arf);
            if (state->arf_handle != NULL)
            {
                // save the arf pointer for next config state syncing
                state->arf = config->arf;
            }
            else
            {
                log_event(BOTH_LOG, "#NSAED-CFG-STATE-SYNCING %s create arf "
                        "handle for \"%s\" failed", FLEX_ZOMBIE_NAME, config->arf_id);
            }
        }
    }
}

PRIVATE NSAED_ACTION zombie_inspect(const VOID *c, VOID* s, XMIB_FLOW_INFO *info)
{
    const NSAED_ZOMBIE_CONFIG *config = c;
    NSAED_ZOMBIE_STATE *state = s;
    ZOMBIE_LIMITER *limiter;
    N32 match_tags[MAX_FLEX];

    switch (info->ip_parse_info.ip_version)
    {
        case 4:
        case 6:
            break;
        default:
            // Not IP? Don't inspect.
            return NSAED_ACTION_NONE;
    }

    if (!info->srcstate)
    {
        log_event(BOTH_LOG, ZOMBIE_NAME ": Missing srcstate");
        return NSAED_ACTION_NONE;
    }
    limiter = srcstate_get_protection(info->srcstate, zombie_get_protection_id());

    if (config->filter[GLOBAL_ZOMBIE].enabled)
    {
        if (zombie_limiter_eval(&limiter[GLOBAL_ZOMBIE], info,
                                &(state->stats.pkt_dropped[GLOBAL_ZOMBIE]),
                                &(state->stats.l3_byte_dropped[GLOBAL_ZOMBIE]),
                                &(config->filter[GLOBAL_ZOMBIE])) == NSAED_ACTION_DROP)
        {
            return config->action;
        }
    }

    // No arf_handle? Don't attempt to inspect flex zombie
    if (state->arf_handle == NULL)
    {
        return NSAED_ACTION_NONE;
    }

    INT total_tag_matches = arf_match_flow_info_all_tags(state->arf_handle, info, MAX_FLEX, match_tags);
    for (INT i = 0; i < total_tag_matches; i++)
    {
        N32 tag = match_tags[i];
        if (tag > MAX_FLEX)
        {
            log_event(BOTH_LOG, "#NSAED-INSPECT %s: OOB TAG ID - %d", FLEX_ZOMBIE_NAME, tag);
            break;
        }
        if (zombie_limiter_eval(&limiter[tag], info,
                                &(state->stats.pkt_dropped[tag]),
                                &(state->stats.l3_byte_dropped[tag]),
                                &(config->filter[tag])) == NSAED_ACTION_DROP)
        {
            return config->action;
        }
    }

    return NSAED_ACTION_NONE;
}

PRIVATE VOID zombie_config_handler(NSAED_PG_CONFIG *pg_config, VOID *prot_config, cJSON *zombie_json)
{
    NSAED_ZOMBIE_CONFIG *config = prot_config;
    BOOL enabled = FALSE;

    enabled |= zombie_config_set_rate_limit(&config->filter[GLOBAL_ZOMBIE], zombie_json);

    // Parse and map action string
    config->action = NSAED_ACTION_DROP;
    cJSON *action_json = cJSON_GetObjectItemCaseSensitive(zombie_json, "action");
    if (action_json && cJSON_IsString(action_json))
    {
        TEXT* action = cJSON_GetStringValue(action_json);
        if (strcmp(action, "drop") == 0)
        {
            config->action = NSAED_ACTION_DROP;
        }
        else if (strcmp(action, "block") == 0)
        {
            config->action = NSAED_ACTION_BLOCK;
        }
        else
        {
            zombie_config_set_enabled(config, FALSE);
            return;
        }
    }

    cJSON *arf_id_json = cJSON_GetObjectItemCaseSensitive(zombie_json, KEY_ARF_ID);
    if (!arf_id_json || !cJSON_IsString(arf_id_json))
    {
        // arf is not specified or is invalid. Don't even attempt to load the flex zombie filters
        zombie_config_set_enabled(config, enabled);
        return;
    }

    TEXT *arf_id = cJSON_GetStringValue(arf_id_json);
    config->arf = arf_get(arf_id, pg_config_get_ip_version(pg_config));
    if (config->arf == NULL)
    {
        log_event(BOTH_LOG, "#NSAED-CFG %s load \"%s\" failed", FLEX_ZOMBIE_NAME, arf_id);
        // arf failed to load. Don't even attempt to load the flex zombie filters
        zombie_config_set_enabled(config, enabled);
        return;
    }

    log_event(DBG_LOG, "#NSAED-CFG %s loaded \"%s\"", FLEX_ZOMBIE_NAME, arf_id);
    // save it for config dump
    config->arf_id = strdup(arf_id);

    cJSON *filters_json = cJSON_GetObjectItemCaseSensitive(zombie_json, "filters");
    cJSON *filter_json;
    cJSON_ArrayForEach(filter_json, filters_json)
    {
        cJSON *tag_json = cJSON_GetObjectItemCaseSensitive(filter_json, "tag");
        if (!cJSON_IsNumber(tag_json))
        {
            continue;
        }
        N32 id = (N32)cJSON_GetNumberValue(tag_json);

        enabled |= zombie_config_set_rate_limit(&config->filter[id], filter_json);
    }

    zombie_config_set_enabled(config, enabled);
}

PRIVATE BOOL zombie_config_get_enabled(VOID *prot_config)
{
    NSAED_ZOMBIE_CONFIG *config = prot_config;
    return config->enabled;
}

PRIVATE VOID zombie_config_set_enabled(VOID *prot_config, BOOL state)
{
    NSAED_ZOMBIE_CONFIG *config = prot_config;
    config->enabled = state;
}

PRIVATE VOID zombie_config_dump(const VOID *c)
{
    const NSAED_ZOMBIE_CONFIG *config = c;
    rcon_printf("%s\n  Enabled: %s\n", ZOMBIE_NAME,
        IS_PROTECTION_ENABLED(config->enabled));

    // Get action string from configured action
    const TEXT *action_str;
    switch (config->action)
    {
        case NSAED_ACTION_DROP:
            action_str = "drop";
            break;
        case NSAED_ACTION_BLOCK:
            action_str = "block";
            break;
        default:
            action_str = "UNKNOWN";
    }

    if (config->enabled)
    {
        rcon_printf("  ARF ID: %s\n", config->arf_id);
        rcon_printf("  Action: %s\n", action_str);
    }

    if (config->filter[GLOBAL_ZOMBIE].enabled)
    {
        rcon_printf("  BPS: %u\n", config->filter[GLOBAL_ZOMBIE].bps);
        rcon_printf("  PPS: %u\n", config->filter[GLOBAL_ZOMBIE].pps);
    }
    // Start at 1 since GLOBAL_ZOMBIE has already been handled
    for (INT i = 1; i < MAX_LIMITERS; i++)
    {
        if (!config->filter[i].enabled)
        {
            continue;
        }
        rcon_printf("  (ID %d) BPS: %u\n", i, config->filter[i].bps);
        rcon_printf("  (ID %d) PPS: %u\n", i, config->filter[i].pps);
    }
}

PRIVATE VOID* zombie_config_alloc()
{
    return calloc(1, sizeof(NSAED_ZOMBIE_CONFIG));
}

PRIVATE VOID zombie_config_free(VOID *prot)
{
    if (prot == NULL)
    {
        return;
    }

    NSAED_ZOMBIE_CONFIG *config = prot;
    if (config->arf != NULL)
    {
        arf_release(&config->arf);
    }
    if (config->arf_id != NULL)
    {
        free(config->arf_id);
    }
    free(prot);
}

PRIVATE VOID* zombie_state_alloc()
{
    return calloc(1, sizeof(NSAED_ZOMBIE_STATE));
}

PRIVATE VOID zombie_state_free(VOID *prot)
{
    free(prot);
}

PRIVATE VOID zombie_registered(N32 id)
{
    protection_id = id;
}

PRIVATE N32 zombie_get_protection_id()
{
    return protection_id;
}
#endif //ISNG_BASED_AED
